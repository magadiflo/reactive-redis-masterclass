# Secci√≥n 08: Chat Application con WebSocket

---

## Introducci√≥n al Chat Application

Antes de construir una aplicaci√≥n de chat en tiempo real, es importante entender la diferencia entre
`Server-Sent Events (SSE)` y `WebSocket`, ya que ambos permiten comunicaci√≥n en tiempo real pero con enfoques distintos.

### SSE (Server-Sent Events)

- `Unidireccional`: Solo el servidor puede enviar mensajes al cliente.
- `Formato`: Exclusivamente texto (no soporta binario).
- `Uso t√≠pico`: Casos donde el cliente solo necesita recibir actualizaciones, por ejemplo:
    - Cotizaciones de bolsa.
    - Actualizaci√≥n en tiempo real de m√©tricas o logs.
    - Actualizaci√≥n de precios.

### WebSocket

- `Bidireccional`: Tanto cliente como servidor pueden enviarse mensajes.
- `Formato`: Soporta texto y binario.
- `Uso t√≠pico`: Casos donde se requiere interacci√≥n entre ambos lados, por ejemplo:
    - Aplicaciones de chat.
    - Juegos multijugador en tiempo real.
    - Colaboraci√≥n en vivo (ej. Google Docs).

### Ejemplo con una sola instancia

Crear una aplicaci√≥n de chat con `WebSocket` es sencillo:

- Tenemos una aplicaci√≥n corriendo.
- Dos usuarios se conectan a esa aplicaci√≥n.
- Ambos intercambian mensajes a trav√©s del canal WebSocket.

![01.png](assets/section-08/01.png)

### El reto con m√∫ltiples instancias

En entornos de producci√≥n, es com√∫n que la aplicaci√≥n se despliegue en m√∫ltiples instancias (por ejemplo, en Kubernetes
o detr√°s de un balanceador de carga).

¬øQu√© sucede en ese caso?

- `Usuario A` puede estar conectado a la `instancia 1`.
- `Usuario B` puede estar conectado a la `instancia 2`.
- Si un mensaje se env√≠a desde A, este nunca llegar√° a B porque est√°n en instancias diferentes.

Para resolver este problema necesitamos un `canal de comunicaci√≥n compartido entre todas las instancias`.

Aqu√≠ es donde entra `Redis` con su funcionalidad de `Pub/Sub (Publicar/Suscribirse)`. `Redis` act√∫a como un message
broker que garantiza que todos los mensajes sean entregados a los clientes sin importar a qu√© instancia est√©n
conectados.

![02.png](assets/section-08/02.png)

## WebSocketSession

En el proyecto `redis-spring` creamos un servicio llamado `ChatRoomService` que implementa la interfaz
`WebSocketHandler`. Esta interfaz define el m√©todo `handle(...)`, el cual ser√° invocado cada vez que un cliente
establezca una conexi√≥n `WebSocket` con nuestro servidor.

### ¬øQu√© es un WebSocketSession?

`WebSocketSession` *representa la conexi√≥n persistente entre el cliente y el servidor.* El cliente puede ser una
aplicaci√≥n web (navegador) o m√≥vil, y a trav√©s de esta sesi√≥n se gestionan tanto los mensajes entrantes como los
mensajes salientes.

Recordemos que los `WebSocket` permiten comunicaci√≥n `bidireccional`
(comunicaci√≥n en ambos sentidos: cliente ‚Üí servidor y servidor ‚Üí cliente) y `full-duplex`
(ambos sentidos pueden operar simult√°neamente, sin bloquearse entre s√≠).

Esto significa que en una aplicaci√≥n de chat:

- El `cliente (frontend)` env√≠a mensajes ‚Üí funciona como `publisher`.
- El `servidor (backend)` los recibe ‚Üí act√∫a como `subscriber` mediante `session.receive()`.
- A su vez, el servidor tambi√©n puede `enviar mensajes` a los clientes ‚Üí en este caso, `session.send(...)` act√∫a como
  `publisher`, y el cliente debe estar suscrito a esos mensajes.

En otras palabras:

- `session.receive()` nos entrega un flujo reactivo `(Flux<WebSocketMessage>)` con todo lo que los clientes escriben.
- `session.send(Publisher<WebSocketMessage>)` nos permite enviar datos reactivos al cliente conectado.

A continuaci√≥n se muestra la clase `ChatRoomService` con la implementaci√≥n del `WebSocketHandler` y la definici√≥n
del m√©todo `handle(...)`.

````java

@Slf4j
@Service
public class ChatRoomService implements WebSocketHandler {
    @Override
    public Mono<Void> handle(WebSocketSession session) {
        //subscribe
        session.receive();

        //publisher
        session.send();
        return null;
    }
}
````

## Chat Messages Broadcasting

En esta etapa integramos `Redis` `Pub/Sub` mediante `Redisson` para que los mensajes puedan compartirse entre m√∫ltiples
instancias de nuestra aplicaci√≥n.

Esto resuelve el problema de que, si dos clientes est√°n conectados a instancias diferentes, ambos puedan seguir
comunic√°ndose sin importar en qu√© nodo est√©n.

El flujo de comunicaci√≥n es:

1. Un cliente env√≠a un mensaje por `WebSocket` ‚Üí el servidor lo recibe con `session.receive()`.
2. Ese mensaje se publica en un canal de `Redis` `(topic.publish(...))`.
3. `Redis` reenv√≠a autom√°ticamente ese mensaje a todas las instancias suscritas al canal.
4. Cada instancia recibe el mensaje y lo reenv√≠a a los clientes `WebSocket` `(session.send(...))`.

De esta forma, `Redis` act√∫a como un `message broker` que garantiza el `broadcast global`.

````java

@Slf4j
@RequiredArgsConstructor
@Service
public class ChatRoomService implements WebSocketHandler {

    private final RedissonReactiveClient client;

    @Override
    public Mono<Void> handle(WebSocketSession session) {
        String room = "dummy"; // Canal de Redis (puede ser din√°mico)
        RTopicReactive topic = this.client.getTopic(room, StringCodec.INSTANCE);

        //Subscribe: recibir mensajes del cliente y publicarlos en Redis
        Mono<Void> incomingFlux = session.receive()
                .map(WebSocketMessage::getPayloadAsText)
                .flatMap(topic::publish) // publica el mensaje en Redis
                .doOnError(throwable -> log.error(throwable.getMessage()))
                .doFinally(signalType -> log.info("Subscriber finally {}", signalType))
                .then(); // convierte el Flux<Long> en Mono<Void>, dejando claro que no usamos los valores

        //Publisher: escuchar mensajes desde Redis y enviarlos al cliente WebSocket
        Flux<WebSocketMessage> outgoingFlux = topic.getMessages(String.class)
                .map(session::textMessage) // convierte los mensajes en formato WebSocket
                .doOnError(throwable -> log.error(throwable.getMessage()))
                .doFinally(signalType -> log.info("Publisher finally {}", signalType));

        // Ejecutar ambos flujos en paralelo mientras dure la sesi√≥n WebSocket
        return session.send(outgoingFlux)
                .and(incomingFlux);
    }
}
````

### üîë Puntos clave

- `Canal de Redis (RTopicReactive)`. Redis maneja los mensajes de manera centralizada, permitiendo que todas las
  instancias reciban lo publicado en ese canal.

- `Flujo de entrada (session.receive())`. Los mensajes entrantes desde el cliente se convierten a texto y se publican
  en `Redis` mediante `topic.publish(...)`.

- `Flujo de salida (session.send(...))`. `topic.getMessages(...)` expone un `Flux` con todos los mensajes publicados en
  `Redis`. Cada mensaje se transforma en un `WebSocketMessage` y se env√≠a al cliente conectado.

- `Backpressure y memoria`. Redis `Pub/Sub` no tiene almacenamiento persistente (no es como un `queue`), por lo que los
  mensajes solo se entregan a los clientes conectados en ese momento. Si un cliente no est√° conectado, perder√° los
  mensajes.

- `Canales din√°micos`. En este ejemplo se usa `dummy`, pero en un chat real el nombre del canal deber√≠a asociarse a la
  sala de chat o a un identificador din√°mico.

- `Combinaci√≥n de flujos con .and(...)`. Usamos `.and(...)` para `ejecutar en paralelo` el flujo de salida
  (enviar mensajes) y el de entrada (publicar en Redis). `.and(...)` ignora los valores y espera a que ambos flujos
  terminen para cerrar la sesi√≥n `WebSocket`.

- `.and(...)` es un operador de combinaci√≥n de `Reactor`.
    - Se aplica sobre un `Mono<Void>` y recibe otro `Publisher<?>`.
    - Devuelve un `Mono<Void>` que:
        - `Ejecuta ambos flujos en paralelo`.
        - Se completa solo cuando ambos han finalizado (o uno falla).
- En este caso:
    - `session.send(outgoingFlux)` mantiene el flujo de mensajes hacia el cliente.
    - `incomingFlux` mantiene vivo el flujo de publicaci√≥n en Redis.

As√≠ logramos que enviar y recibir mensajes ocurran simult√°neamente durante toda la sesi√≥n `WebSocket`.

üìå Conclusi√≥n:
> El uso de `.and(...)` en este servicio asegura que tanto la publicaci√≥n de mensajes en Redis como la entrega de
> mensajes a los clientes `ocurran en paralelo`, y que el ciclo de vida completo quede controlado por `WebFlux`.
>
> Al usar `.then()` sobre `incomingFlux`, dejamos claro que los valores emitidos por `Redis` no se usan, haciendo
> el c√≥digo m√°s limpio y expresivo.

## WebSocket Config

Para habilitar la comunicaci√≥n por `WebSocket` en nuestra aplicaci√≥n usamos la clase de configuraci√≥n
`ChatRoomSocketConfig`.

````java

@RequiredArgsConstructor
@Configuration
public class ChatRoomSocketConfig {

    private final ChatRoomService chatRoomService;

    @Bean
    public HandlerMapping handlerMapping() {
        Map<String, WebSocketHandler> urlMap = Map.of(
                "/chat", this.chatRoomService
        );
        return new SimpleUrlHandlerMapping(urlMap, -1);
    }
}
````

üîé Explicaci√≥n

- `HandlerMapping` personalizado
    - Se crea un `SimpleUrlHandlerMapping` que expone el endpoint `/chat`.
    - Cada vez que un cliente se conecte a esta ruta, `Spring` delegar√° la sesi√≥n al `ChatRoomService`.
    - El par√°metro `-1` define la prioridad de este mapeo. Un valor negativo asegura que esta configuraci√≥n no
      interfiera con otros mapeos m√°s espec√≠ficos (por ejemplo, de controladores `@RestController`).

### ¬øQu√© significa ese `-1`?

`Spring` utiliza un mecanismo de ordenamiento para decidir qu√© `HandlerMapping` se eval√∫a primero cuando llega una
solicitud. Este orden se define con un n√∫mero entero:

| Valor de orden                                      | Prioridad       | ¬øQu√© implica?                                      |
|-----------------------------------------------------|-----------------|----------------------------------------------------|
| `Integer.MIN_VALUE` o valores muy bajos (como` -1`) | Alta prioridad  | Se eval√∫a antes que otros mappings con orden mayor |
| `0` o valores positivos                             | Menor prioridad | Se eval√∫an despu√©s.                                |

En nuestro caso espec√≠fico:

````bash
return new SimpleUrlHandlerMapping(urlMap, -1);
````

- El `-1` indica que este `HandlerMapping` tiene alta prioridad.
- Garantiza que las peticiones a `/chat` se redirijan directamente al `WebSocket` y no a otros controladores
  `@RestController` que podr√≠an tener el mismo path.
- Esto es √∫til cuando tienes m√∫ltiples `HandlerMapping` en tu aplicaci√≥n (por ejemplo, uno para `WebSocket` y otro para
  controladores HTTP normales).
- Al darle prioridad alta, Spring intentar√° resolver primero las rutas `WebSocket` antes de pasar a otros mapeos.

#### ¬øY si no se especifica?

Si no se define el orden, Spring usa un valor por defecto `(Ordered.LOWEST_PRECEDENCE)`, lo que podr√≠a hacer que este
mapping se eval√∫e despu√©s de otros, y eso podr√≠a causar que no se resuelva correctamente la ruta `/chat`.

#### Ejemplo pr√°ctico

Supongamos que tenemos el `@RestController` con:

````java

@GetMapping("/chat")
public String test() {
    return "REST endpoint";
}
````

Y nuestro `SimpleUrlHandlerMapping` est√° configurado con `orden -1`, entonces:

- Una petici√≥n `WebSocket` a `ws://localhost:8080/chat` ir√° al `WebSocketHandler`.
- Una petici√≥n `HTTP GET` a `http://localhost:8080/chat` seguir√° funcionando, porque son distintos protocolos.
- Pero `si no usas -1`, `Spring` podr√≠a resolver primero el `RestController` y nunca entrar al `WebSocket`.

> El par√°metro `-1` establece la prioridad del mapeo `WebSocket`, indicando que este `HandlerMapping` debe evaluarse
> antes que los mapeos por defecto. De esta forma, aseguramos que las conexiones a `/chat` sean manejadas correctamente
> por el `ChatRoomService` y no interfieran con otros endpoints.

La clase `ChatRoomService` implementa la l√≥gica central del `WebSocket`.

````java

@Slf4j
@RequiredArgsConstructor
@Service
public class ChatRoomService implements WebSocketHandler {

    private final RedissonReactiveClient client;

    @Override
    public Mono<Void> handle(WebSocketSession session) {
        String room = this.getChatRoomName(session);
        RTopicReactive topic = this.client.getTopic(room, StringCodec.INSTANCE);

        //subscribe
        Mono<Void> incomingFlux = session.receive()
                .map(WebSocketMessage::getPayloadAsText)
                .flatMap(topic::publish)
                .doOnError(throwable -> log.error(throwable.getMessage()))
                .doFinally(signalType -> log.info("Subscriber finally {}", signalType))
                .then();

        //publisher
        Flux<WebSocketMessage> outgoingFlux = topic.getMessages(String.class)
                .map(session::textMessage)
                .doOnError(throwable -> log.error(throwable.getMessage()))
                .doFinally(signalType -> log.info("Publisher finally {}", signalType));

        return session.send(outgoingFlux)
                .and(incomingFlux);
    }

    private String getChatRoomName(WebSocketSession session) {
        URI uri = session.getHandshakeInfo().getUri();
        return UriComponentsBuilder.fromUri(uri)
                .build()
                .getQueryParams()
                .toSingleValueMap()
                .getOrDefault("room", "default");
    }
}
````

üîé Explicaci√≥n

- Selecci√≥n din√°mica de salas `(getChatRoomName(...))`
    - El nombre de la sala de chat se extrae del par√°metro `room` en la `URL` del `WebSocket`.
    - Ejemplo de conexi√≥n desde el cliente: `ws://localhost:8080/chat?room=sala1`.
    - Si no se env√≠a un par√°metro `room`, se asigna autom√°ticamente `default`.


- Flujo de entrada `(incomingFlux)`
    - Cada mensaje recibido desde el cliente se publica en el canal Redis asociado a la sala.
    - Usamos `.then()` para ignorar los valores (Long) que devuelve publish y quedarnos √∫nicamente con la se√±al de
      finalizaci√≥n.


- Flujo de salida `(outgoingFlux)`
    - Escucha en el canal Redis y env√≠a todos los mensajes publicados hacia el cliente actual.
    - De esta forma, todos los clientes conectados a la misma sala reciben lo que cualquiera env√≠e.


- Combinaci√≥n con `.and(...)`
    - `session.send(outgoingFlux)` gestiona los mensajes que enviamos al cliente.
    - `incomingFlux` gestiona los mensajes entrantes que publicamos en Redis.
    - Con `.and(...)` ejecutamos ambos en paralelo, esperando a que terminen antes de cerrar la sesi√≥n.

‚ö° Beneficio principal

> Con esta configuraci√≥n, cualquier n√∫mero de instancias de tu aplicaci√≥n puede manejar clientes de m√∫ltiples salas en
> paralelo. `Redis` act√∫a como el punto de sincronizaci√≥n que asegura que los mensajes lleguen a todos los clientes de
> la misma sala, sin importar a qu√© instancia est√©n conectados.

**Nota**
> En la clase `CityService` comentamos esta anotaci√≥n `@Scheduled(fixedRate = 10_000)` dado que el m√©todo anotado
> con ese `scheduled` usa un servicio que deber√≠amos levantar, pero en nuestro caso no necesitamos trabajar con
> ning√∫n servicio externo.

## WebSocket Test Client

Para validar el correcto funcionamiento de nuestro backend de chat con `WebSocket`, podemos utilizar una extensi√≥n de
navegador que act√∫e como cliente `WebSocket gen√©rico`.

### üîå Instalaci√≥n de la extensi√≥n

En este caso, utilizamos la extensi√≥n gratuita disponible en `Microsoft Edge` (tambi√©n existe en `Chrome Web Store`).

![03.png](assets/section-08/03.png)

Al abrir la extensi√≥n, se nos muestra una interfaz gr√°fica simple para conectarnos a un servidor `WebSocket`.

![04.png](assets/section-08/04.png)

### üì° Prueba de conexi√≥n

1. Abrimos dos ventanas de la extensi√≥n.
2. Nos conectamos al endpoint configurado en nuestro backend: `ws://localhost:8080/chat`
3. Desde la primera ventana, enviamos un mensaje de prueba.
4. Verificamos que el mensaje aparece en la segunda ventana de la extensi√≥n.

![05.png](assets/section-08/05.png)

### üîé Explicaci√≥n

- Cada ventana de la extensi√≥n representa un cliente WebSocket distinto.
- Al enviar un mensaje desde un cliente, este se publica en el canal Redis y se reenv√≠a autom√°ticamente a todos los
  dem√°s clientes conectados a la misma sala (room).
- Esto confirma que la siguiente l√≥gica est√° funcionando correctamente:
    - `session.receive()` ‚Üí Redis publish
    - Redis subscribe ‚Üí `session.send()`

## üíª Chat Application - HTML Template

Para probar nuestro chat con `WebSocket` directamente en el navegador, creamos una plantilla HTML en:

````bash
src/main/resources/static/index.html 
````

De esta manera, al levantar la aplicaci√≥n podremos acceder a: `http://localhost:8080/index.html`

````html
<!doctype html>
<html lang="en">
<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet"
          integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
    <!--------------------------------------------------------------------------------------------->
    <title>Redis Chat Demo</title>
</head>
<body style="background-color: #E5E7E9;">
<div class="container mt-5">

    <!-- Nombre del usuario -->
    <div class="input-group mb-3">
        <span class="input-group-text" id="basic-addon1">Name</span>
        <input type="text" class="form-control" placeholder="Name" id="name">
    </div>

    <!-- Nombre de la sala -->
    <div class="input-group mb-3">
        <span class="input-group-text" id="basic-addon1">Room</span>
        <input type="text" class="form-control" placeholder="Room" id="room">
    </div>

    <!-- Bot√≥n para iniciar la conexi√≥n -->
    <div class="mb-3" id="start-control">
        <button class="form-control btn btn-secondary" type="button" id="start">Start</button>
    </div>

    <!-- Contenedor del chat (visible solo tras iniciar) -->
    <div id="chat-div" class="invisible">
        <!-- Historial de mensajes -->
        <div class="mb-3">
            <label for="exampleFormControlTextarea1" class="form-label">Messages</label>
            <div class="form-control overflow-auto" style="height:250px;" id="history">

            </div>
        </div>
        <!-- Entrada de mensajes -->
        <div class="input-group mb-3">
            <input type="text" class="form-control" placeholder="Type your message here" id="message">
            <button class="btn btn-secondary" type="button" id="send">Send</button>
        </div>

    </div>

</div>

<!-- L√≥gica de WebSocket -->
<script>
    // will be executed after pressing start button
    const chatFunction = () => {
        // Datos del usuario y sala
        const name = document.getElementById('name').value;
        const room = document.getElementById('room').value;
        const history = document.getElementById('history');
        const message = document.getElementById('message');
        const send = document.getElementById('send');
        const chatDiv = document.getElementById('chat-div');
        const startControl = document.getElementById('start-control');

        // Mostrar chat y ocultar controles de inicio
        chatDiv.classList.remove('invisible');
        startControl.classList.add('invisible');

        // Construcci√≥n din√°mica del URI. Ejm. ws://localhost:8080/chat?room=some-name
        const uri = `ws://${window.location.hostname}:${window.location.port}/chat?room=${room}`;
        websocket = new WebSocket(uri);

        // Manejo de mensajes entrantes
        websocket.onmessage = (evt) => {
            let obj = JSON.parse(evt.data);
            let ele = document.createElement('p');
            ele.innerHTML = `<b>${obj.sender}:</b>&nbsp;${obj.message}`;
            history.appendChild(ele);
        }
        
        // Eventos de conexi√≥n y desconexi√≥n
        websocket.onopen = (evt) => {
            let ele = document.createElement('p');
            ele.innerHTML = `<b>CONNECTED</b>`;
            history.appendChild(ele);
        }

        websocket.onclose = (evt) => {
            let ele = document.createElement('p');
            ele.innerHTML = `<b>DISCONNECTED</b>`;
            history.appendChild(ele);
        }

        // Env√≠o de mensajes
        const sendMessage = () => {
            let obj = {
                sender: name,
                message: message.value
            }
            message.value = '';

            websocket.send(JSON.stringify(obj));
        }
        send.addEventListener('click', sendMessage);
    }

    document.getElementById('start').addEventListener('click', chatFunction);
</script>
<!--------------------------------------------------------------------------------------------->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM"
        crossorigin="anonymous"></script>
</body>
</html>
````

üîé Explicaci√≥n

- Formulario inicial
    - Permite ingresar el nombre de usuario y el nombre de la sala (room).
    - Tras presionar "Start", se construye la URL de conexi√≥n WebSocket:
      `ws://localhost:8080/chat?room=<nombre-de-la-sala>`
- Eventos de WebSocket
    - `onopen`: Muestra que la conexi√≥n se abri√≥.
    - `onclose`: Muestra que la conexi√≥n se cerr√≥.
    - `onmessage`: Cada vez que el servidor publica un mensaje, se renderiza en el historial.
- Env√≠o de mensajes
    - Los mensajes enviados se transforman en JSON con la estructura:
    ````json 
    {
     "sender": "Alice",
     "message": "Hola a todos!"
    }
    ````
    - El backend recibe ese JSON, lo publica en Redis y lo reenv√≠a a todos los clientes de la misma sala.

‚úÖ Resultado esperado

Al abrir varias ventanas del navegador con index.html y conectarse a la misma sala:

1. Cada usuario podr√° escribir mensajes.
2. Todos los dem√°s ver√°n los mensajes en tiempo real.

üëâ Esto convierte a tu aplicaci√≥n en un chat distribuido con Redis + WebSocket funcionando de extremo a extremo.

## Chat Application - Demo y tarea asignada

Ejecutamos nuestra aplicaci√≥n y abrimos dos pesta√±as apuntando a `http://localhost:8080`. Luego, nos conectamos a la
sala `redis-course` e ingresamos un nombre para cada usuario. Finalmente damos en `Start`.

![06.png](assets/section-08/06.png)

Veamos en funcionamiento nuestro chat, inicialmente con dos usuarios conectados a la misma sala, posteriormente
se nos une un nuevo usuario.

![07.png](assets/section-08/07.png)
