# Sección 08: Chat Application con WebSocket

---

## Introducción al Chat Application

Antes de construir una aplicación de chat en tiempo real, es importante entender la diferencia entre
`Server-Sent Events (SSE)` y `WebSocket`, ya que ambos permiten comunicación en tiempo real pero con enfoques distintos.

### SSE (Server-Sent Events)

- `Unidireccional`: Solo el servidor puede enviar mensajes al cliente.
- `Formato`: Exclusivamente texto (no soporta binario).
- `Uso típico`: Casos donde el cliente solo necesita recibir actualizaciones, por ejemplo:
    - Cotizaciones de bolsa.
    - Actualización en tiempo real de métricas o logs.
    - Actualización de precios.

### WebSocket

- `Bidireccional`: Tanto cliente como servidor pueden enviarse mensajes.
- `Formato`: Soporta texto y binario.
- `Uso típico`: Casos donde se requiere interacción entre ambos lados, por ejemplo:
    - Aplicaciones de chat.
    - Juegos multijugador en tiempo real.
    - Colaboración en vivo (ej. Google Docs).

### Ejemplo con una sola instancia

Crear una aplicación de chat con `WebSocket` es sencillo:

- Tenemos una aplicación corriendo.
- Dos usuarios se conectan a esa aplicación.
- Ambos intercambian mensajes a través del canal WebSocket.

![01.png](assets/section-08/01.png)

### El reto con múltiples instancias

En entornos de producción, es común que la aplicación se despliegue en múltiples instancias (por ejemplo, en Kubernetes
o detrás de un balanceador de carga).

¿Qué sucede en ese caso?

- `Usuario A` puede estar conectado a la `instancia 1`.
- `Usuario B` puede estar conectado a la `instancia 2`.
- Si un mensaje se envía desde A, este nunca llegará a B porque están en instancias diferentes.

Para resolver este problema necesitamos un `canal de comunicación compartido entre todas las instancias`.

Aquí es donde entra `Redis` con su funcionalidad de `Pub/Sub (Publicar/Suscribirse)`. `Redis` actúa como un message
broker que garantiza que todos los mensajes sean entregados a los clientes sin importar a qué instancia estén
conectados.

![02.png](assets/section-08/02.png)

## WebSocketSession

En el proyecto `redis-spring` creamos un servicio llamado `ChatRoomService` que implementa la interfaz
`WebSocketHandler`. Esta interfaz define el método `handle(...)`, el cual será invocado cada vez que un cliente
establezca una conexión `WebSocket` con nuestro servidor.

### ¿Qué es un WebSocketSession?

`WebSocketSession` *representa la conexión persistente entre el cliente y el servidor.* El cliente puede ser una
aplicación web (navegador) o móvil, y a través de esta sesión se gestionan tanto los mensajes entrantes como los
mensajes salientes.

Recordemos que los `WebSocket` permiten comunicación `bidireccional`
(comunicación en ambos sentidos: cliente → servidor y servidor → cliente) y `full-duplex`
(ambos sentidos pueden operar simultáneamente, sin bloquearse entre sí).

Esto significa que en una aplicación de chat:

- El `cliente (frontend)` envía mensajes → funciona como `publisher`.
- El `servidor (backend)` los recibe → actúa como `subscriber` mediante `session.receive()`.
- A su vez, el servidor también puede `enviar mensajes` a los clientes → en este caso, `session.send(...)` actúa como
  `publisher`, y el cliente debe estar suscrito a esos mensajes.

En otras palabras:

- `session.receive()` nos entrega un flujo reactivo `(Flux<WebSocketMessage>)` con todo lo que los clientes escriben.
- `session.send(Publisher<WebSocketMessage>)` nos permite enviar datos reactivos al cliente conectado.

A continuación se muestra la clase `ChatRoomService` con la implementación del `WebSocketHandler` y la definición
del método `handle(...)`.

````java

@Slf4j
@Service
public class ChatRoomService implements WebSocketHandler {
    @Override
    public Mono<Void> handle(WebSocketSession session) {
        //subscribe
        session.receive();

        //publisher
        session.send();
        return null;
    }
}
````
