# Secci√≥n 08: Chat Application con WebSocket

---

## Introducci√≥n al Chat Application

Antes de construir una aplicaci√≥n de chat en tiempo real, es importante entender la diferencia entre
`Server-Sent Events (SSE)` y `WebSocket`, ya que ambos permiten comunicaci√≥n en tiempo real pero con enfoques distintos.

### SSE (Server-Sent Events)

- `Unidireccional`: Solo el servidor puede enviar mensajes al cliente.
- `Formato`: Exclusivamente texto (no soporta binario).
- `Uso t√≠pico`: Casos donde el cliente solo necesita recibir actualizaciones, por ejemplo:
    - Cotizaciones de bolsa.
    - Actualizaci√≥n en tiempo real de m√©tricas o logs.
    - Actualizaci√≥n de precios.

### WebSocket

- `Bidireccional`: Tanto cliente como servidor pueden enviarse mensajes.
- `Formato`: Soporta texto y binario.
- `Uso t√≠pico`: Casos donde se requiere interacci√≥n entre ambos lados, por ejemplo:
    - Aplicaciones de chat.
    - Juegos multijugador en tiempo real.
    - Colaboraci√≥n en vivo (ej. Google Docs).

### Ejemplo con una sola instancia

Crear una aplicaci√≥n de chat con `WebSocket` es sencillo:

- Tenemos una aplicaci√≥n corriendo.
- Dos usuarios se conectan a esa aplicaci√≥n.
- Ambos intercambian mensajes a trav√©s del canal WebSocket.

![01.png](assets/section-08/01.png)

### El reto con m√∫ltiples instancias

En entornos de producci√≥n, es com√∫n que la aplicaci√≥n se despliegue en m√∫ltiples instancias (por ejemplo, en Kubernetes
o detr√°s de un balanceador de carga).

¬øQu√© sucede en ese caso?

- `Usuario A` puede estar conectado a la `instancia 1`.
- `Usuario B` puede estar conectado a la `instancia 2`.
- Si un mensaje se env√≠a desde A, este nunca llegar√° a B porque est√°n en instancias diferentes.

Para resolver este problema necesitamos un `canal de comunicaci√≥n compartido entre todas las instancias`.

Aqu√≠ es donde entra `Redis` con su funcionalidad de `Pub/Sub (Publicar/Suscribirse)`. `Redis` act√∫a como un message
broker que garantiza que todos los mensajes sean entregados a los clientes sin importar a qu√© instancia est√©n
conectados.

![02.png](assets/section-08/02.png)

## WebSocketSession

En el proyecto `redis-spring` creamos un servicio llamado `ChatRoomService` que implementa la interfaz
`WebSocketHandler`. Esta interfaz define el m√©todo `handle(...)`, el cual ser√° invocado cada vez que un cliente
establezca una conexi√≥n `WebSocket` con nuestro servidor.

### ¬øQu√© es un WebSocketSession?

`WebSocketSession` *representa la conexi√≥n persistente entre el cliente y el servidor.* El cliente puede ser una
aplicaci√≥n web (navegador) o m√≥vil, y a trav√©s de esta sesi√≥n se gestionan tanto los mensajes entrantes como los
mensajes salientes.

Recordemos que los `WebSocket` permiten comunicaci√≥n `bidireccional`
(comunicaci√≥n en ambos sentidos: cliente ‚Üí servidor y servidor ‚Üí cliente) y `full-duplex`
(ambos sentidos pueden operar simult√°neamente, sin bloquearse entre s√≠).

Esto significa que en una aplicaci√≥n de chat:

- El `cliente (frontend)` env√≠a mensajes ‚Üí funciona como `publisher`.
- El `servidor (backend)` los recibe ‚Üí act√∫a como `subscriber` mediante `session.receive()`.
- A su vez, el servidor tambi√©n puede `enviar mensajes` a los clientes ‚Üí en este caso, `session.send(...)` act√∫a como
  `publisher`, y el cliente debe estar suscrito a esos mensajes.

En otras palabras:

- `session.receive()` nos entrega un flujo reactivo `(Flux<WebSocketMessage>)` con todo lo que los clientes escriben.
- `session.send(Publisher<WebSocketMessage>)` nos permite enviar datos reactivos al cliente conectado.

A continuaci√≥n se muestra la clase `ChatRoomService` con la implementaci√≥n del `WebSocketHandler` y la definici√≥n
del m√©todo `handle(...)`.

````java

@Slf4j
@Service
public class ChatRoomService implements WebSocketHandler {
    @Override
    public Mono<Void> handle(WebSocketSession session) {
        //subscribe
        session.receive();

        //publisher
        session.send();
        return null;
    }
}
````

## Chat Messages Broadcasting

En esta etapa integramos `Redis` `Pub/Sub` mediante `Redisson` para que los mensajes puedan compartirse entre m√∫ltiples
instancias de nuestra aplicaci√≥n.

Esto resuelve el problema de que, si dos clientes est√°n conectados a instancias diferentes, ambos puedan seguir
comunic√°ndose sin importar en qu√© nodo est√©n.

El flujo de comunicaci√≥n es:

1. Un cliente env√≠a un mensaje por `WebSocket` ‚Üí el servidor lo recibe con `session.receive()`.
2. Ese mensaje se publica en un canal de `Redis` `(topic.publish(...))`.
3. `Redis` reenv√≠a autom√°ticamente ese mensaje a todas las instancias suscritas al canal.
4. Cada instancia recibe el mensaje y lo reenv√≠a a los clientes `WebSocket` `(session.send(...))`.

De esta forma, `Redis` act√∫a como un `message broker` que garantiza el `broadcast global`.

````java

@Slf4j
@RequiredArgsConstructor
@Service
public class ChatRoomService implements WebSocketHandler {

    private final RedissonReactiveClient client;

    @Override
    public Mono<Void> handle(WebSocketSession session) {
        String room = "dummy"; // Canal de Redis (puede ser din√°mico)
        RTopicReactive topic = this.client.getTopic(room, StringCodec.INSTANCE);

        //Subscribe: recibir mensajes del cliente y publicarlos en Redis
        Mono<Void> incomingFlux = session.receive()
                .map(WebSocketMessage::getPayloadAsText)
                .flatMap(topic::publish) // publica el mensaje en Redis
                .doOnError(throwable -> log.error(throwable.getMessage()))
                .doFinally(signalType -> log.info("Subscriber finally {}", signalType))
                .then(); // convierte el Flux<Long> en Mono<Void>, dejando claro que no usamos los valores

        //Publisher: escuchar mensajes desde Redis y enviarlos al cliente WebSocket
        Flux<WebSocketMessage> outgoingFlux = topic.getMessages(String.class)
                .map(session::textMessage) // convierte los mensajes en formato WebSocket
                .doOnError(throwable -> log.error(throwable.getMessage()))
                .doFinally(signalType -> log.info("Publisher finally {}", signalType));

        // Ejecutar ambos flujos en paralelo mientras dure la sesi√≥n WebSocket
        return session.send(outgoingFlux)
                .and(incomingFlux);
    }
}
````

### üîë Puntos clave

- `Canal de Redis (RTopicReactive)`. Redis maneja los mensajes de manera centralizada, permitiendo que todas las
  instancias reciban lo publicado en ese canal.

- `Flujo de entrada (session.receive())`. Los mensajes entrantes desde el cliente se convierten a texto y se publican
  en `Redis` mediante `topic.publish(...)`.

- `Flujo de salida (session.send(...))`. `topic.getMessages(...)` expone un `Flux` con todos los mensajes publicados en
  `Redis`. Cada mensaje se transforma en un `WebSocketMessage` y se env√≠a al cliente conectado.

- `Backpressure y memoria`. Redis `Pub/Sub` no tiene almacenamiento persistente (no es como un `queue`), por lo que los
  mensajes solo se entregan a los clientes conectados en ese momento. Si un cliente no est√° conectado, perder√° los
  mensajes.

- `Canales din√°micos`. En este ejemplo se usa `dummy`, pero en un chat real el nombre del canal deber√≠a asociarse a la
  sala de chat o a un identificador din√°mico.

- `Combinaci√≥n de flujos con .and(...)`. Usamos `.and(...)` para `ejecutar en paralelo` el flujo de salida
  (enviar mensajes) y el de entrada (publicar en Redis). `.and(...)` ignora los valores y espera a que ambos flujos
  terminen para cerrar la sesi√≥n `WebSocket`.

- `.and(...)` es un operador de combinaci√≥n de `Reactor`.
    - Se aplica sobre un `Mono<Void>` y recibe otro `Publisher<?>`.
    - Devuelve un `Mono<Void>` que:
        - `Ejecuta ambos flujos en paralelo`.
        - Se completa solo cuando ambos han finalizado (o uno falla).
- En este caso:
    - `session.send(outgoingFlux)` mantiene el flujo de mensajes hacia el cliente.
    - `incomingFlux` mantiene vivo el flujo de publicaci√≥n en Redis.

As√≠ logramos que enviar y recibir mensajes ocurran simult√°neamente durante toda la sesi√≥n `WebSocket`.

üìå Conclusi√≥n:
> El uso de `.and(...)` en este servicio asegura que tanto la publicaci√≥n de mensajes en Redis como la entrega de
> mensajes a los clientes `ocurran en paralelo`, y que el ciclo de vida completo quede controlado por `WebFlux`.
>
> Al usar `.then()` sobre `incomingFlux`, dejamos claro que los valores emitidos por `Redis` no se usan, haciendo
> el c√≥digo m√°s limpio y expresivo.

## WebSocket Config

Para habilitar la comunicaci√≥n por `WebSocket` en nuestra aplicaci√≥n usamos la clase de configuraci√≥n
`ChatRoomSocketConfig`.

````java

@RequiredArgsConstructor
@Configuration
public class ChatRoomSocketConfig {

    private final ChatRoomService chatRoomService;

    @Bean
    public HandlerMapping handlerMapping() {
        Map<String, WebSocketHandler> urlMap = Map.of(
                "/chat", this.chatRoomService
        );
        return new SimpleUrlHandlerMapping(urlMap, -1);
    }
}
````

üîé Explicaci√≥n

- `HandlerMapping` personalizado
    - Se crea un `SimpleUrlHandlerMapping` que expone el endpoint `/chat`.
    - Cada vez que un cliente se conecte a esta ruta, `Spring` delegar√° la sesi√≥n al `ChatRoomService`.
    - El par√°metro `-1` define la prioridad de este mapeo. Un valor negativo asegura que esta configuraci√≥n no
      interfiera con otros mapeos m√°s espec√≠ficos (por ejemplo, de controladores `@RestController`).

### ¬øQu√© significa ese `-1`?

`Spring` utiliza un mecanismo de ordenamiento para decidir qu√© `HandlerMapping` se eval√∫a primero cuando llega una
solicitud. Este orden se define con un n√∫mero entero:

| Valor de orden                                      | Prioridad       | ¬øQu√© implica?                                      |
|-----------------------------------------------------|-----------------|----------------------------------------------------|
| `Integer.MIN_VALUE` o valores muy bajos (como` -1`) | Alta prioridad  | Se eval√∫a antes que otros mappings con orden mayor |
| `0` o valores positivos                             | Menor prioridad | Se eval√∫an despu√©s.                                |

En nuestro caso espec√≠fico:

````bash
return new SimpleUrlHandlerMapping(urlMap, -1);
````

- El `-1` indica que este `HandlerMapping` tiene alta prioridad.
- Garantiza que las peticiones a `/chat` se redirijan directamente al `WebSocket` y no a otros controladores
  `@RestController` que podr√≠an tener el mismo path.
- Esto es √∫til cuando tienes m√∫ltiples `HandlerMapping` en tu aplicaci√≥n (por ejemplo, uno para `WebSocket` y otro para
  controladores HTTP normales).
- Al darle prioridad alta, Spring intentar√° resolver primero las rutas `WebSocket` antes de pasar a otros mapeos.

#### ¬øY si no se especifica?

Si no se define el orden, Spring usa un valor por defecto `(Ordered.LOWEST_PRECEDENCE)`, lo que podr√≠a hacer que este
mapping se eval√∫e despu√©s de otros, y eso podr√≠a causar que no se resuelva correctamente la ruta `/chat`.

#### Ejemplo pr√°ctico

Supongamos que tenemos el `@RestController` con:

````java

@GetMapping("/chat")
public String test() {
    return "REST endpoint";
}
````

Y nuestro `SimpleUrlHandlerMapping` est√° configurado con `orden -1`, entonces:

- Una petici√≥n `WebSocket` a `ws://localhost:8080/chat` ir√° al `WebSocketHandler`.
- Una petici√≥n `HTTP GET` a `http://localhost:8080/chat` seguir√° funcionando, porque son distintos protocolos.
- Pero `si no usas -1`, `Spring` podr√≠a resolver primero el `RestController` y nunca entrar al `WebSocket`.

> El par√°metro `-1` establece la prioridad del mapeo `WebSocket`, indicando que este `HandlerMapping` debe evaluarse
> antes que los mapeos por defecto. De esta forma, aseguramos que las conexiones a `/chat` sean manejadas correctamente
> por el `ChatRoomService` y no interfieran con otros endpoints.

La clase `ChatRoomService` implementa la l√≥gica central del `WebSocket`.

````java

@Slf4j
@RequiredArgsConstructor
@Service
public class ChatRoomService implements WebSocketHandler {

    private final RedissonReactiveClient client;

    @Override
    public Mono<Void> handle(WebSocketSession session) {
        String room = this.getChatRoomName(session);
        RTopicReactive topic = this.client.getTopic(room, StringCodec.INSTANCE);

        //subscribe
        Mono<Void> incomingFlux = session.receive()
                .map(WebSocketMessage::getPayloadAsText)
                .flatMap(topic::publish)
                .doOnError(throwable -> log.error(throwable.getMessage()))
                .doFinally(signalType -> log.info("Subscriber finally {}", signalType))
                .then();

        //publisher
        Flux<WebSocketMessage> outgoingFlux = topic.getMessages(String.class)
                .map(session::textMessage)
                .doOnError(throwable -> log.error(throwable.getMessage()))
                .doFinally(signalType -> log.info("Publisher finally {}", signalType));

        return session.send(outgoingFlux)
                .and(incomingFlux);
    }

    private String getChatRoomName(WebSocketSession session) {
        URI uri = session.getHandshakeInfo().getUri();
        return UriComponentsBuilder.fromUri(uri)
                .build()
                .getQueryParams()
                .toSingleValueMap()
                .getOrDefault("room", "default");
    }
}
````

üîé Explicaci√≥n

- Selecci√≥n din√°mica de salas `(getChatRoomName(...))`
    - El nombre de la sala de chat se extrae del par√°metro `room` en la `URL` del `WebSocket`.
    - Ejemplo de conexi√≥n desde el cliente: `ws://localhost:8080/chat?room=sala1`.
    - Si no se env√≠a un par√°metro `room`, se asigna autom√°ticamente `default`.


- Flujo de entrada `(incomingFlux)`
    - Cada mensaje recibido desde el cliente se publica en el canal Redis asociado a la sala.
    - Usamos `.then()` para ignorar los valores (Long) que devuelve publish y quedarnos √∫nicamente con la se√±al de
      finalizaci√≥n.


- Flujo de salida `(outgoingFlux)`
    - Escucha en el canal Redis y env√≠a todos los mensajes publicados hacia el cliente actual.
    - De esta forma, todos los clientes conectados a la misma sala reciben lo que cualquiera env√≠e.


- Combinaci√≥n con `.and(...)`
    - `session.send(outgoingFlux)` gestiona los mensajes que enviamos al cliente.
    - `incomingFlux` gestiona los mensajes entrantes que publicamos en Redis.
    - Con `.and(...)` ejecutamos ambos en paralelo, esperando a que terminen antes de cerrar la sesi√≥n.

‚ö° Beneficio principal

> Con esta configuraci√≥n, cualquier n√∫mero de instancias de tu aplicaci√≥n puede manejar clientes de m√∫ltiples salas en
> paralelo. `Redis` act√∫a como el punto de sincronizaci√≥n que asegura que los mensajes lleguen a todos los clientes de
> la misma sala, sin importar a qu√© instancia est√©n conectados.

**Nota**
> En la clase `CityService` comentamos esta anotaci√≥n `@Scheduled(fixedRate = 10_000)` dado que el m√©todo anotado
> con ese `scheduled` usa un servicio que deber√≠amos levantar, pero en nuestro caso no necesitamos trabajar con
> ning√∫n servicio externo.

## WebSocket Test Client

Para validar el correcto funcionamiento de nuestro backend de chat con `WebSocket`, podemos utilizar una extensi√≥n de
navegador que act√∫e como cliente `WebSocket gen√©rico`.

### üîå Instalaci√≥n de la extensi√≥n

En este caso, utilizamos la extensi√≥n gratuita disponible en `Microsoft Edge` (tambi√©n existe en `Chrome Web Store`).

![03.png](assets/section-08/03.png)

Al abrir la extensi√≥n, se nos muestra una interfaz gr√°fica simple para conectarnos a un servidor `WebSocket`.

![04.png](assets/section-08/04.png)

### üì° Prueba de conexi√≥n

1. Abrimos dos ventanas de la extensi√≥n.
2. Nos conectamos al endpoint configurado en nuestro backend: `ws://localhost:8080/chat`
3. Desde la primera ventana, enviamos un mensaje de prueba.
4. Verificamos que el mensaje aparece en la segunda ventana de la extensi√≥n.

![05.png](assets/section-08/05.png)

### üîé Explicaci√≥n

- Cada ventana de la extensi√≥n representa un cliente WebSocket distinto.
- Al enviar un mensaje desde un cliente, este se publica en el canal Redis y se reenv√≠a autom√°ticamente a todos los
  dem√°s clientes conectados a la misma sala (room).
- Esto confirma que la siguiente l√≥gica est√° funcionando correctamente:
    - `session.receive()` ‚Üí Redis publish
    - Redis subscribe ‚Üí `session.send()`

## üíª Chat Application - HTML Template

Para probar nuestro chat con `WebSocket` directamente en el navegador, creamos una plantilla HTML en:

````bash
src/main/resources/static/index.html 
````

De esta manera, al levantar la aplicaci√≥n podremos acceder a: `http://localhost:8080/index.html`

````html
<!doctype html>
<html lang="en">
<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet"
          integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
    <!--------------------------------------------------------------------------------------------->
    <title>Redis Chat Demo</title>
</head>
<body style="background-color: #E5E7E9;">
<div class="container mt-5">

    <!-- Nombre del usuario -->
    <div class="input-group mb-3">
        <span class="input-group-text" id="basic-addon1">Name</span>
        <input type="text" class="form-control" placeholder="Name" id="name">
    </div>

    <!-- Nombre de la sala -->
    <div class="input-group mb-3">
        <span class="input-group-text" id="basic-addon1">Room</span>
        <input type="text" class="form-control" placeholder="Room" id="room">
    </div>

    <!-- Bot√≥n para iniciar la conexi√≥n -->
    <div class="mb-3" id="start-control">
        <button class="form-control btn btn-secondary" type="button" id="start">Start</button>
    </div>

    <!-- Contenedor del chat (visible solo tras iniciar) -->
    <div id="chat-div" class="invisible">
        <!-- Historial de mensajes -->
        <div class="mb-3">
            <label for="exampleFormControlTextarea1" class="form-label">Messages</label>
            <div class="form-control overflow-auto" style="height:250px;" id="history">

            </div>
        </div>
        <!-- Entrada de mensajes -->
        <div class="input-group mb-3">
            <input type="text" class="form-control" placeholder="Type your message here" id="message">
            <button class="btn btn-secondary" type="button" id="send">Send</button>
        </div>

    </div>

</div>

<!-- L√≥gica de WebSocket -->
<script>
    // will be executed after pressing start button
    const chatFunction = () => {
        // Datos del usuario y sala
        const name = document.getElementById('name').value;
        const room = document.getElementById('room').value;
        const history = document.getElementById('history');
        const message = document.getElementById('message');
        const send = document.getElementById('send');
        const chatDiv = document.getElementById('chat-div');
        const startControl = document.getElementById('start-control');

        // Mostrar chat y ocultar controles de inicio
        chatDiv.classList.remove('invisible');
        startControl.classList.add('invisible');

        // Construcci√≥n din√°mica del URI. Ejm. ws://localhost:8080/chat?room=some-name
        const uri = `ws://${window.location.hostname}:${window.location.port}/chat?room=${room}`;
        websocket = new WebSocket(uri);

        // Manejo de mensajes entrantes
        websocket.onmessage = (evt) => {
            let obj = JSON.parse(evt.data);
            let ele = document.createElement('p');
            ele.innerHTML = `<b>${obj.sender}:</b>&nbsp;${obj.message}`;
            history.appendChild(ele);
        }
        
        // Eventos de conexi√≥n y desconexi√≥n
        websocket.onopen = (evt) => {
            let ele = document.createElement('p');
            ele.innerHTML = `<b>CONNECTED</b>`;
            history.appendChild(ele);
        }

        websocket.onclose = (evt) => {
            let ele = document.createElement('p');
            ele.innerHTML = `<b>DISCONNECTED</b>`;
            history.appendChild(ele);
        }

        // Env√≠o de mensajes
        const sendMessage = () => {
            let obj = {
                sender: name,
                message: message.value
            }
            message.value = '';

            websocket.send(JSON.stringify(obj));
        }
        send.addEventListener('click', sendMessage);
    }

    document.getElementById('start').addEventListener('click', chatFunction);
</script>
<!--------------------------------------------------------------------------------------------->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM"
        crossorigin="anonymous"></script>
</body>
</html>
````

üîé Explicaci√≥n

- Formulario inicial
    - Permite ingresar el nombre de usuario y el nombre de la sala (room).
    - Tras presionar "Start", se construye la URL de conexi√≥n WebSocket:
      `ws://localhost:8080/chat?room=<nombre-de-la-sala>`
- Eventos de WebSocket
    - `onopen`: Muestra que la conexi√≥n se abri√≥.
    - `onclose`: Muestra que la conexi√≥n se cerr√≥.
    - `onmessage`: Cada vez que el servidor publica un mensaje, se renderiza en el historial.
- Env√≠o de mensajes
    - Los mensajes enviados se transforman en JSON con la estructura:
    ````json 
    {
     "sender": "Alice",
     "message": "Hola a todos!"
    }
    ````
    - El backend recibe ese JSON, lo publica en Redis y lo reenv√≠a a todos los clientes de la misma sala.

‚úÖ Resultado esperado

Al abrir varias ventanas del navegador con index.html y conectarse a la misma sala:

1. Cada usuario podr√° escribir mensajes.
2. Todos los dem√°s ver√°n los mensajes en tiempo real.

üëâ Esto convierte a tu aplicaci√≥n en un chat distribuido con Redis + WebSocket funcionando de extremo a extremo.

## Chat Application - Demo y tarea asignada

Ejecutamos nuestra aplicaci√≥n y abrimos dos pesta√±as apuntando a `http://localhost:8080`. Luego, nos conectamos a la
sala `redis-course` e ingresamos un nombre para cada usuario. Finalmente damos en `Start`.

![06.png](assets/section-08/06.png)

Veamos en funcionamiento nuestro chat, inicialmente con dos usuarios conectados a la misma sala, posteriormente
se nos une un nuevo usuario.

![07.png](assets/section-08/07.png)

### Tarea asignada

Los usuarios que se conecten tarde a la sala, deben poder ver el historial de conversaci√≥n, cosa que hasta este
momento no sucede.

## Soluci√≥n a la tarea asignada - Chat History

En la implementaci√≥n anterior, los usuarios que se conectaban tarde a una sala solo recib√≠an los mensajes nuevos a
partir de su conexi√≥n. Todo lo anterior ya se hab√≠a perdido, porque `Redis Pub/Sub` no guarda estado:
funciona en tiempo real, pero sin persistencia.

### Soluci√≥n aplicada

Para resolverlo, se incorpora `Redis List (RListReactive)` como almacenamiento del historial de conversaci√≥n.
Ahora cada mensaje cumple dos pasos:

1. Se guarda en la lista de Redis `(history:roomName)`.
2. Se publica en el canal `Pub/Sub` `(RTopicReactive)`.

Con esto:

- Los usuarios que llegan tarde reciben todo el historial almacenado en la lista.
- Los usuarios que ya estaban conectados siguen recibiendo los mensajes en tiempo real v√≠a `Pub/Sub`.

### Detalles t√©cnicos importantes

- `list.add(message).then(topic.publish(message))`. Encadena la acci√≥n de guardar el mensaje en Redis (lista
  persistente) antes de publicarlo al canal. De esta forma, nunca se pierde nada.


- `startWith(list.iterator())`. Cuando un cliente se conecta, primero se recorren todos los mensajes almacenados en
  Redis y se env√≠an al cliente. Una vez enviado el historial, se engancha al flujo normal de `Pub/Sub` para recibir
  mensajes en tiempo real.


- `Persistencia en Redis`. Redis almacena la conversaci√≥n en una lista bajo la clave `history:<room>`. Esto asegura que
  incluso si todos los usuarios se desconectan, el historial sigue ah√≠ para futuras conexiones.

````java

@Slf4j
@RequiredArgsConstructor
@Service
public class ChatRoomService implements WebSocketHandler {

    private final RedissonReactiveClient client;

    @Override
    public Mono<Void> handle(WebSocketSession session) {
        String room = this.getChatRoomName(session);
        RTopicReactive topic = this.client.getTopic(room, StringCodec.INSTANCE);

        // Agrega lista para almacenar historial de conversaci√≥n
        RListReactive<String> list = this.client.getList("history:" + room, StringCodec.INSTANCE);

        //subscribe
        Mono<Void> incomingFlux = session.receive()
                .map(WebSocketMessage::getPayloadAsText)
                .flatMap(message -> list.add(message).then(topic.publish(message))) // Agregamos la conversaci√≥n a la lista y publicamos el mensaje
                .doOnError(throwable -> log.error(throwable.getMessage()))
                .doFinally(signalType -> log.info("Subscriber finally {}", signalType))
                .then();

        //publisher
        Flux<WebSocketMessage> outgoingFlux = topic.getMessages(String.class)
                .startWith(list.iterator()) // El startWith(...) permite primero emitir el flujo definido, luego el flujo normal 
                .map(session::textMessage)
                .doOnError(throwable -> log.error(throwable.getMessage()))
                .doFinally(signalType -> log.info("Publisher finally {}", signalType));

        return session.send(outgoingFlux)
                .and(incomingFlux);
    }

    private String getChatRoomName(WebSocketSession session) {
        URI uri = session.getHandshakeInfo().getUri();
        return UriComponentsBuilder.fromUri(uri)
                .build()
                .getQueryParams()
                .toSingleValueMap()
                .getOrDefault("room", "default");
    }
}
````

### Ejemplo pr√°ctico

Supongamos que en la sala redis-course ya hubo una conversaci√≥n previa entre Sam, Mart√≠n y Jake.
Si un nuevo usuario entra m√°s tarde:

1. Primero ver√° en pantalla todo lo que se habl√≥ antes (gracias al `startWith(list.iterator())`).
2. A partir de ah√≠, seguir√° recibiendo los mensajes nuevos como cualquier otro usuario.

De esta manera, la experiencia de usuario es m√°s completa y consistente.

### Verificaci√≥n en Redis

````bash
127.0.0.1:6379> keys *
1) "history:redis-course"

127.0.0.1:6379> type history:redis-course
list

127.0.0.1:6379> lrange history:redis-course 0 -1
1) "{\"sender\":\"sam\",\"message\":\"Hola Mart\xc3\xadn\"}"
2) "{\"sender\":\"martin\",\"message\":\"Hola, Sam. A\xc3\xban no llega Jake?\"}"
3) "{\"sender\":\"sam\",\"message\":\"No, es muy tard\xc3\xb3n\"}"
4) "{\"sender\":\"martin\",\"message\":\"S\xc3\xad no?\"}"
5) "{\"sender\":\"jake\",\"message\":\"Hola chicos. S\xc3\xad soy muy tard\xc3\xb3n jajaja lo siento!\"}"
6) "{\"sender\":\"sam\",\"message\":\"Hola nuevamente!\"}" 
````

- La clave `history:redis-course` fue creada autom√°ticamente al guardar mensajes en la sala `redis-course`.
- El `type` de la clave es `list`, lo que confirma que se est√° utilizando `RListReactive` como estructura subyacente.
- Cada entrada en la lista es un `JSON serializado` con el formato `{sender, message}`, lo que mantiene la estructura de
  los datos del chat.
- Los caracteres especiales (`\xc3\xa1`, `\xc3\xb3`, etc.) corresponden a `UTF-8` codificado en bytes. `Redis` no
  transforma tu JSON, simplemente lo almacena como texto plano. Cuando la aplicaci√≥n lo lee, lo decodifica de vuelta a
  caracteres legibles (Mart√≠n, tard√≥n, etc.).

Esta consulta a `Redis` confirma que:

- Los mensajes realmente est√°n siendo persistidos.
- Est√°n almacenados de manera ordenada (la lista mantiene el orden de llegada).
- El formato es legible y compatible con cualquier cliente que consuma el historial.

A continuaci√≥n se muestra las im√°genes de la conversaci√≥n por chat.

![08.png](assets/section-08/08.png)

### üìä Resumen de beneficios

- ‚úÖ `Persistencia`: El historial se mantiene aunque nadie est√© conectado.
- ‚úÖ `Experiencia de usuario`: Los nuevos participantes no llegan a una "sala vac√≠a".
- ‚úÖ `Escalabilidad`: Redis maneja la persistencia y la distribuci√≥n en m√∫ltiples instancias del backend.

## Chateando desde 2 instancias diferentes

Hasta ahora probamos la aplicaci√≥n con una sola instancia. Sin embargo, en entornos de producci√≥n (Kubernetes,
balanceadores de carga, etc.) lo habitual es que existan m√∫ltiples instancias del backend corriendo en paralelo.

Veamos c√≥mo nuestra soluci√≥n con `Redis` permite que la comunicaci√≥n funcione incluso en este escenario.

### 1. Crear el JAR de la aplicaci√≥n

Primero empaquetamos el proyecto para generar el artefacto ejecutable. Esto genera el archivo
`redis-spring-0.0.1-SNAPSHOT.jar` en el directorio `target/`.

````bash
D:\programming\spring\01.udemy\03.vinoth_selvaraj\reactive-redis-masterclass\projects\redis-spring (feature/section-8)
$ mvn clean package -DskipTests 
````

### 2. Ejecutar la primera instancia (puerto 8080)

`Spring Boot` arranca en el puerto `8080` con Netty como servidor embebido.

````bash
D:\programming\spring\01.udemy\03.vinoth_selvaraj\reactive-redis-masterclass\projects\redis-spring (feature/section-8)
$ java -jar .\target\redis-spring-0.0.1-SNAPSHOT.jar

  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/

 :: Spring Boot ::                (v3.5.4)

2025-09-11T13:08:38.388-05:00  INFO 21188 --- [redis-spring] [           main] d.m.redis.app.RedisSpringApplication
  : Starting RedisSpringApplication v0.0.1-SNAPSHOT using Java 21.0.6 with PID 21188 (D:\programming\spring\01.udemy\03.vinoth_selvaraj\reactive-redis-masterclass\projects\redis-spring\target\redis-spring-0.0.1-SNAPSHOT.jar started by magadiflo in D:\programming\spring\01.udemy\03.vinoth_selvaraj\reactive-redis-masterclass\projects\redis-spring)
2025-09-11T13:08:38.393-05:00  INFO 21188 --- [redis-spring] [           main] d.m.redis.app.RedisSpringApplication
  : No active profile set, falling back to 1 default profile: "default"
2025-09-11T13:08:39.127-05:00  INFO 21188 --- [redis-spring] [           main] .s.d.r.c.RepositoryConfigurationDelegate : Multiple Spring Data modules found, entering strict repository configuration mode
2025-09-11T13:08:39.130-05:00  INFO 21188 --- [redis-spring] [           main] .s.d.r.c.RepositoryConfigurationDelegate : Bootstrapping Spring Data Redis repositories in DEFAULT mode.
2025-09-11T13:08:39.176-05:00  INFO 21188 --- [redis-spring] [           main] .s.d.r.c.RepositoryConfigurationDelegate : Finished Spring Data repository scanning in 14 ms. Found 0 Redis repository interfaces.
2025-09-11T13:08:39.929-05:00  INFO 21188 --- [redis-spring] [           main] org.redisson.Version
  : Redisson 3.50.0
2025-09-11T13:08:40.374-05:00  INFO 21188 --- [redis-spring] [isson-netty-3-5] o.redisson.connection.ConnectionsHolder
  : 1 connections initialized for localhost/127.0.0.1:6379
2025-09-11T13:08:40.480-05:00  INFO 21188 --- [redis-spring] [sson-netty-3-20] o.redisson.connection.ConnectionsHolder
  : 24 connections initialized for localhost/127.0.0.1:6379
2025-09-11T13:08:41.374-05:00  INFO 21188 --- [redis-spring] [           main] o.s.b.web.embedded.netty.NettyWebServer
  : Netty started on port 8080 (http)
2025-09-11T13:08:41.393-05:00  INFO 21188 --- [redis-spring] [           main] d.m.redis.app.RedisSpringApplication
  : Started RedisSpringApplication in 3.545 seconds (process running for 4.094) 
````

### 3. Ejecutar una segunda instancia (puerto 7070)

Podemos levantar otra instancia del mismo `.jar`, pero esta vez indicando un puerto distinto `(--server.port=7070)`.

````bash
D:\programming\spring\01.udemy\03.vinoth_selvaraj\reactive-redis-masterclass\projects\redis-spring (feature/section-8)
$ java -jar .\target\redis-spring-0.0.1-SNAPSHOT.jar --server.port=7070

  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/

 :: Spring Boot ::                (v3.5.4)

2025-09-11T13:10:46.517-05:00  INFO 1696 --- [redis-spring] [           main] d.m.redis.app.RedisSpringApplication
  : Starting RedisSpringApplication v0.0.1-SNAPSHOT using Java 21.0.6 with PID 1696 (D:\programming\spring\01.udemy\03.vinoth_selvaraj\reactive-redis-masterclass\projects\redis-spring\target\redis-spring-0.0.1-SNAPSHOT.jar started by magadiflo in D:\programming\spring\01.udemy\03.vinoth_selvaraj\reactive-redis-masterclass\projects\redis-spring)
2025-09-11T13:10:46.519-05:00  INFO 1696 --- [redis-spring] [           main] d.m.redis.app.RedisSpringApplication
  : No active profile set, falling back to 1 default profile: "default"
2025-09-11T13:10:47.180-05:00  INFO 1696 --- [redis-spring] [           main] .s.d.r.c.RepositoryConfigurationDelegate : Multiple Spring Data modules found, entering strict repository configuration mode
2025-09-11T13:10:47.183-05:00  INFO 1696 --- [redis-spring] [           main] .s.d.r.c.RepositoryConfigurationDelegate : Bootstrapping Spring Data Redis repositories in DEFAULT mode.
2025-09-11T13:10:47.232-05:00  INFO 1696 --- [redis-spring] [           main] .s.d.r.c.RepositoryConfigurationDelegate : Finished Spring Data repository scanning in 16 ms. Found 0 Redis repository interfaces.
2025-09-11T13:10:47.991-05:00  INFO 1696 --- [redis-spring] [           main] org.redisson.Version
  : Redisson 3.50.0
2025-09-11T13:10:48.420-05:00  INFO 1696 --- [redis-spring] [isson-netty-3-5] o.redisson.connection.ConnectionsHolder
  : 1 connections initialized for localhost/127.0.0.1:6379
2025-09-11T13:10:48.563-05:00  INFO 1696 --- [redis-spring] [sson-netty-3-20] o.redisson.connection.ConnectionsHolder
  : 24 connections initialized for localhost/127.0.0.1:6379
2025-09-11T13:10:49.436-05:00  INFO 1696 --- [redis-spring] [           main] o.s.b.web.embedded.netty.NettyWebServer
  : Netty started on port 7070 (http)
2025-09-11T13:10:49.453-05:00  INFO 1696 --- [redis-spring] [           main] d.m.redis.app.RedisSpringApplication
  : Started RedisSpringApplication in 3.446 seconds (process running for 3.972)
````

Ahora tenemos dos instancias activas y conectadas al mismo servidor Redis:

- Instancia A ‚Üí puerto 8080
- Instancia B ‚Üí puerto 7070

### 4. Probar la comunicaci√≥n

Abrimos dos pesta√±as en el navegador:

- `http://localhost:8080`
- `http://localhost:7070`

Nos conectamos a una misma sala `(room=redis-course)` desde ambas instancias. Cuando enviamos un mensaje desde la
instancia A, se publica en el canal Redis correspondiente. Redis se encarga de reenviar ese mensaje a todas las
instancias suscritas, incluyendo la instancia B, que a su vez lo env√≠a a su cliente WebSocket conectado.

![09.png](assets/section-08/09.png)

El historial de redis

````bash
127.0.0.1:6379> keys *
1) "history:redis-course"
127.0.0.1:6379> lrange history:redis-course 0 -1
1) "{\"sender\":\"sam\",\"message\":\"\xc2\xbfMartin?\"}"
2) "{\"sender\":\"martin\",\"message\":\"Hola Sam, que milagro\"}"
127.0.0.1:6379> 
````

### üîë Puntos clave

- `Escalabilidad horizontal`: podemos desplegar m√∫ltiples instancias del backend sin perder sincronizaci√≥n.
- `Redis como broker`: asegura que los mensajes lleguen a todos los clientes, independientemente de la instancia donde
  est√©n conectados.
- `Desacoplamiento`: las instancias no se comunican entre s√≠ directamente, sino a trav√©s de Redis. Esto reduce
  complejidad y aumenta confiabilidad.
- `Producci√≥n realista`: en un despliegue `cloud/Kubernetes`, esto es justo lo que sucede: un balanceador de carga
  dirige a los usuarios a instancias distintas, pero Redis garantiza la consistencia del chat.
