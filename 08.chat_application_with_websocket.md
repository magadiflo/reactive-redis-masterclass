# Secci√≥n 08: Chat Application con WebSocket

---

## Introducci√≥n al Chat Application

Antes de construir una aplicaci√≥n de chat en tiempo real, es importante entender la diferencia entre
`Server-Sent Events (SSE)` y `WebSocket`, ya que ambos permiten comunicaci√≥n en tiempo real pero con enfoques distintos.

### SSE (Server-Sent Events)

- `Unidireccional`: Solo el servidor puede enviar mensajes al cliente.
- `Formato`: Exclusivamente texto (no soporta binario).
- `Uso t√≠pico`: Casos donde el cliente solo necesita recibir actualizaciones, por ejemplo:
    - Cotizaciones de bolsa.
    - Actualizaci√≥n en tiempo real de m√©tricas o logs.
    - Actualizaci√≥n de precios.

### WebSocket

- `Bidireccional`: Tanto cliente como servidor pueden enviarse mensajes.
- `Formato`: Soporta texto y binario.
- `Uso t√≠pico`: Casos donde se requiere interacci√≥n entre ambos lados, por ejemplo:
    - Aplicaciones de chat.
    - Juegos multijugador en tiempo real.
    - Colaboraci√≥n en vivo (ej. Google Docs).

### Ejemplo con una sola instancia

Crear una aplicaci√≥n de chat con `WebSocket` es sencillo:

- Tenemos una aplicaci√≥n corriendo.
- Dos usuarios se conectan a esa aplicaci√≥n.
- Ambos intercambian mensajes a trav√©s del canal WebSocket.

![01.png](assets/section-08/01.png)

### El reto con m√∫ltiples instancias

En entornos de producci√≥n, es com√∫n que la aplicaci√≥n se despliegue en m√∫ltiples instancias (por ejemplo, en Kubernetes
o detr√°s de un balanceador de carga).

¬øQu√© sucede en ese caso?

- `Usuario A` puede estar conectado a la `instancia 1`.
- `Usuario B` puede estar conectado a la `instancia 2`.
- Si un mensaje se env√≠a desde A, este nunca llegar√° a B porque est√°n en instancias diferentes.

Para resolver este problema necesitamos un `canal de comunicaci√≥n compartido entre todas las instancias`.

Aqu√≠ es donde entra `Redis` con su funcionalidad de `Pub/Sub (Publicar/Suscribirse)`. `Redis` act√∫a como un message
broker que garantiza que todos los mensajes sean entregados a los clientes sin importar a qu√© instancia est√©n
conectados.

![02.png](assets/section-08/02.png)

## WebSocketSession

En el proyecto `redis-spring` creamos un servicio llamado `ChatRoomService` que implementa la interfaz
`WebSocketHandler`. Esta interfaz define el m√©todo `handle(...)`, el cual ser√° invocado cada vez que un cliente
establezca una conexi√≥n `WebSocket` con nuestro servidor.

### ¬øQu√© es un WebSocketSession?

`WebSocketSession` *representa la conexi√≥n persistente entre el cliente y el servidor.* El cliente puede ser una
aplicaci√≥n web (navegador) o m√≥vil, y a trav√©s de esta sesi√≥n se gestionan tanto los mensajes entrantes como los
mensajes salientes.

Recordemos que los `WebSocket` permiten comunicaci√≥n `bidireccional`
(comunicaci√≥n en ambos sentidos: cliente ‚Üí servidor y servidor ‚Üí cliente) y `full-duplex`
(ambos sentidos pueden operar simult√°neamente, sin bloquearse entre s√≠).

Esto significa que en una aplicaci√≥n de chat:

- El `cliente (frontend)` env√≠a mensajes ‚Üí funciona como `publisher`.
- El `servidor (backend)` los recibe ‚Üí act√∫a como `subscriber` mediante `session.receive()`.
- A su vez, el servidor tambi√©n puede `enviar mensajes` a los clientes ‚Üí en este caso, `session.send(...)` act√∫a como
  `publisher`, y el cliente debe estar suscrito a esos mensajes.

En otras palabras:

- `session.receive()` nos entrega un flujo reactivo `(Flux<WebSocketMessage>)` con todo lo que los clientes escriben.
- `session.send(Publisher<WebSocketMessage>)` nos permite enviar datos reactivos al cliente conectado.

A continuaci√≥n se muestra la clase `ChatRoomService` con la implementaci√≥n del `WebSocketHandler` y la definici√≥n
del m√©todo `handle(...)`.

````java

@Slf4j
@Service
public class ChatRoomService implements WebSocketHandler {
    @Override
    public Mono<Void> handle(WebSocketSession session) {
        //subscribe
        session.receive();

        //publisher
        session.send();
        return null;
    }
}
````

## Chat Messages Broadcasting

En esta etapa integramos `Redis` `Pub/Sub` mediante `Redisson` para que los mensajes puedan compartirse entre m√∫ltiples
instancias de nuestra aplicaci√≥n.

Esto resuelve el problema de que, si dos clientes est√°n conectados a instancias diferentes, ambos puedan seguir
comunic√°ndose sin importar en qu√© nodo est√©n.

El flujo de comunicaci√≥n es:

1. Un cliente env√≠a un mensaje por `WebSocket` ‚Üí el servidor lo recibe con `session.receive()`.
2. Ese mensaje se publica en un canal de `Redis` `(topic.publish(...))`.
3. `Redis` reenv√≠a autom√°ticamente ese mensaje a todas las instancias suscritas al canal.
4. Cada instancia recibe el mensaje y lo reenv√≠a a los clientes `WebSocket` `(session.send(...))`.

De esta forma, `Redis` act√∫a como un `message broker` que garantiza el `broadcast global`.

````java

@Slf4j
@RequiredArgsConstructor
@Service
public class ChatRoomService implements WebSocketHandler {

    private final RedissonReactiveClient client;

    @Override
    public Mono<Void> handle(WebSocketSession session) {
        String room = "dummy"; // Canal de Redis (puede ser din√°mico)
        RTopicReactive topic = this.client.getTopic(room, StringCodec.INSTANCE);

        //Subscribe: recibir mensajes del cliente y publicarlos en Redis
        Mono<Void> incomingFlux = session.receive()
                .map(WebSocketMessage::getPayloadAsText)
                .flatMap(topic::publish) // publica el mensaje en Redis
                .doOnError(throwable -> log.error(throwable.getMessage()))
                .doFinally(signalType -> log.info("Subscriber finally {}", signalType))
                .then(); // convierte el Flux<Long> en Mono<Void>, dejando claro que no usamos los valores

        //Publisher: escuchar mensajes desde Redis y enviarlos al cliente WebSocket
        Flux<WebSocketMessage> outgoingFlux = topic.getMessages(String.class)
                .map(session::textMessage) // convierte los mensajes en formato WebSocket
                .doOnError(throwable -> log.error(throwable.getMessage()))
                .doFinally(signalType -> log.info("Publisher finally {}", signalType));

        // Ejecutar ambos flujos en paralelo mientras dure la sesi√≥n WebSocket
        return session.send(outgoingFlux)
                .and(incomingFlux);
    }
}
````

### üîë Puntos clave

- `Canal de Redis (RTopicReactive)`. Redis maneja los mensajes de manera centralizada, permitiendo que todas las
  instancias reciban lo publicado en ese canal.

- `Flujo de entrada (session.receive())`. Los mensajes entrantes desde el cliente se convierten a texto y se publican
  en `Redis` mediante `topic.publish(...)`.

- `Flujo de salida (session.send(...))`. `topic.getMessages(...)` expone un `Flux` con todos los mensajes publicados en
  `Redis`. Cada mensaje se transforma en un `WebSocketMessage` y se env√≠a al cliente conectado.

- `Backpressure y memoria`. Redis `Pub/Sub` no tiene almacenamiento persistente (no es como un `queue`), por lo que los
  mensajes solo se entregan a los clientes conectados en ese momento. Si un cliente no est√° conectado, perder√° los
  mensajes.

- `Canales din√°micos`. En este ejemplo se usa `dummy`, pero en un chat real el nombre del canal deber√≠a asociarse a la
  sala de chat o a un identificador din√°mico.

- `Combinaci√≥n de flujos con .and(...)`. Usamos `.and(...)` para `ejecutar en paralelo` el flujo de salida
  (enviar mensajes) y el de entrada (publicar en Redis). `.and(...)` ignora los valores y espera a que ambos flujos
  terminen para cerrar la sesi√≥n `WebSocket`.

- `.and(...)` es un operador de combinaci√≥n de `Reactor`.
    - Se aplica sobre un `Mono<Void>` y recibe otro `Publisher<?>`.
    - Devuelve un `Mono<Void>` que:
        - `Ejecuta ambos flujos en paralelo`.
        - Se completa solo cuando ambos han finalizado (o uno falla).
- En este caso:
    - `session.send(outgoingFlux)` mantiene el flujo de mensajes hacia el cliente.
    - `incomingFlux` mantiene vivo el flujo de publicaci√≥n en Redis.

As√≠ logramos que enviar y recibir mensajes ocurran simult√°neamente durante toda la sesi√≥n `WebSocket`.

üìå Conclusi√≥n:
> El uso de `.and(...)` en este servicio asegura que tanto la publicaci√≥n de mensajes en Redis como la entrega de
> mensajes a los clientes `ocurran en paralelo`, y que el ciclo de vida completo quede controlado por `WebFlux`.
>
> Al usar `.then()` sobre `incomingFlux`, dejamos claro que los valores emitidos por `Redis` no se usan, haciendo
> el c√≥digo m√°s limpio y expresivo.
