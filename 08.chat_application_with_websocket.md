# Secci√≥n 08: Chat Application con WebSocket

---

## Introducci√≥n al Chat Application

Antes de construir una aplicaci√≥n de chat en tiempo real, es importante entender la diferencia entre
`Server-Sent Events (SSE)` y `WebSocket`, ya que ambos permiten comunicaci√≥n en tiempo real pero con enfoques distintos.

### SSE (Server-Sent Events)

- `Unidireccional`: Solo el servidor puede enviar mensajes al cliente.
- `Formato`: Exclusivamente texto (no soporta binario).
- `Uso t√≠pico`: Casos donde el cliente solo necesita recibir actualizaciones, por ejemplo:
    - Cotizaciones de bolsa.
    - Actualizaci√≥n en tiempo real de m√©tricas o logs.
    - Actualizaci√≥n de precios.

### WebSocket

- `Bidireccional`: Tanto cliente como servidor pueden enviarse mensajes.
- `Formato`: Soporta texto y binario.
- `Uso t√≠pico`: Casos donde se requiere interacci√≥n entre ambos lados, por ejemplo:
    - Aplicaciones de chat.
    - Juegos multijugador en tiempo real.
    - Colaboraci√≥n en vivo (ej. Google Docs).

### Ejemplo con una sola instancia

Crear una aplicaci√≥n de chat con `WebSocket` es sencillo:

- Tenemos una aplicaci√≥n corriendo.
- Dos usuarios se conectan a esa aplicaci√≥n.
- Ambos intercambian mensajes a trav√©s del canal WebSocket.

![01.png](assets/section-08/01.png)

### El reto con m√∫ltiples instancias

En entornos de producci√≥n, es com√∫n que la aplicaci√≥n se despliegue en m√∫ltiples instancias (por ejemplo, en Kubernetes
o detr√°s de un balanceador de carga).

¬øQu√© sucede en ese caso?

- `Usuario A` puede estar conectado a la `instancia 1`.
- `Usuario B` puede estar conectado a la `instancia 2`.
- Si un mensaje se env√≠a desde A, este nunca llegar√° a B porque est√°n en instancias diferentes.

Para resolver este problema necesitamos un `canal de comunicaci√≥n compartido entre todas las instancias`.

Aqu√≠ es donde entra `Redis` con su funcionalidad de `Pub/Sub (Publicar/Suscribirse)`. `Redis` act√∫a como un message
broker que garantiza que todos los mensajes sean entregados a los clientes sin importar a qu√© instancia est√©n
conectados.

![02.png](assets/section-08/02.png)

## WebSocketSession

En el proyecto `redis-spring` creamos un servicio llamado `ChatRoomService` que implementa la interfaz
`WebSocketHandler`. Esta interfaz define el m√©todo `handle(...)`, el cual ser√° invocado cada vez que un cliente
establezca una conexi√≥n `WebSocket` con nuestro servidor.

### ¬øQu√© es un WebSocketSession?

`WebSocketSession` *representa la conexi√≥n persistente entre el cliente y el servidor.* El cliente puede ser una
aplicaci√≥n web (navegador) o m√≥vil, y a trav√©s de esta sesi√≥n se gestionan tanto los mensajes entrantes como los
mensajes salientes.

Recordemos que los `WebSocket` permiten comunicaci√≥n `bidireccional`
(comunicaci√≥n en ambos sentidos: cliente ‚Üí servidor y servidor ‚Üí cliente) y `full-duplex`
(ambos sentidos pueden operar simult√°neamente, sin bloquearse entre s√≠).

Esto significa que en una aplicaci√≥n de chat:

- El `cliente (frontend)` env√≠a mensajes ‚Üí funciona como `publisher`.
- El `servidor (backend)` los recibe ‚Üí act√∫a como `subscriber` mediante `session.receive()`.
- A su vez, el servidor tambi√©n puede `enviar mensajes` a los clientes ‚Üí en este caso, `session.send(...)` act√∫a como
  `publisher`, y el cliente debe estar suscrito a esos mensajes.

En otras palabras:

- `session.receive()` nos entrega un flujo reactivo `(Flux<WebSocketMessage>)` con todo lo que los clientes escriben.
- `session.send(Publisher<WebSocketMessage>)` nos permite enviar datos reactivos al cliente conectado.

A continuaci√≥n se muestra la clase `ChatRoomService` con la implementaci√≥n del `WebSocketHandler` y la definici√≥n
del m√©todo `handle(...)`.

````java

@Slf4j
@Service
public class ChatRoomService implements WebSocketHandler {
    @Override
    public Mono<Void> handle(WebSocketSession session) {
        //subscribe
        session.receive();

        //publisher
        session.send();
        return null;
    }
}
````

## Chat Messages Broadcasting

En esta etapa integramos `Redis` `Pub/Sub` mediante `Redisson` para que los mensajes puedan compartirse entre m√∫ltiples
instancias de nuestra aplicaci√≥n.

Esto resuelve el problema de que, si dos clientes est√°n conectados a instancias diferentes, ambos puedan seguir
comunic√°ndose sin importar en qu√© nodo est√©n.

El flujo de comunicaci√≥n es:

1. Un cliente env√≠a un mensaje por `WebSocket` ‚Üí el servidor lo recibe con `session.receive()`.
2. Ese mensaje se publica en un canal de `Redis` `(topic.publish(...))`.
3. `Redis` reenv√≠a autom√°ticamente ese mensaje a todas las instancias suscritas al canal.
4. Cada instancia recibe el mensaje y lo reenv√≠a a los clientes `WebSocket` `(session.send(...))`.

De esta forma, `Redis` act√∫a como un `message broker` que garantiza el `broadcast global`.

````java

@Slf4j
@RequiredArgsConstructor
@Service
public class ChatRoomService implements WebSocketHandler {

    private final RedissonReactiveClient client;

    @Override
    public Mono<Void> handle(WebSocketSession session) {
        String room = "dummy"; // Canal de Redis (puede ser din√°mico)
        RTopicReactive topic = this.client.getTopic(room, StringCodec.INSTANCE);

        //Subscribe: recibir mensajes del cliente y publicarlos en Redis
        Mono<Void> incomingFlux = session.receive()
                .map(WebSocketMessage::getPayloadAsText)
                .flatMap(topic::publish) // publica el mensaje en Redis
                .doOnError(throwable -> log.error(throwable.getMessage()))
                .doFinally(signalType -> log.info("Subscriber finally {}", signalType))
                .then(); // convierte el Flux<Long> en Mono<Void>, dejando claro que no usamos los valores

        //Publisher: escuchar mensajes desde Redis y enviarlos al cliente WebSocket
        Flux<WebSocketMessage> outgoingFlux = topic.getMessages(String.class)
                .map(session::textMessage) // convierte los mensajes en formato WebSocket
                .doOnError(throwable -> log.error(throwable.getMessage()))
                .doFinally(signalType -> log.info("Publisher finally {}", signalType));

        // Ejecutar ambos flujos en paralelo mientras dure la sesi√≥n WebSocket
        return session.send(outgoingFlux)
                .and(incomingFlux);
    }
}
````

### üîë Puntos clave

- `Canal de Redis (RTopicReactive)`. Redis maneja los mensajes de manera centralizada, permitiendo que todas las
  instancias reciban lo publicado en ese canal.

- `Flujo de entrada (session.receive())`. Los mensajes entrantes desde el cliente se convierten a texto y se publican
  en `Redis` mediante `topic.publish(...)`.

- `Flujo de salida (session.send(...))`. `topic.getMessages(...)` expone un `Flux` con todos los mensajes publicados en
  `Redis`. Cada mensaje se transforma en un `WebSocketMessage` y se env√≠a al cliente conectado.

- `Backpressure y memoria`. Redis `Pub/Sub` no tiene almacenamiento persistente (no es como un `queue`), por lo que los
  mensajes solo se entregan a los clientes conectados en ese momento. Si un cliente no est√° conectado, perder√° los
  mensajes.

- `Canales din√°micos`. En este ejemplo se usa `dummy`, pero en un chat real el nombre del canal deber√≠a asociarse a la
  sala de chat o a un identificador din√°mico.

- `Combinaci√≥n de flujos con .and(...)`. Usamos `.and(...)` para `ejecutar en paralelo` el flujo de salida
  (enviar mensajes) y el de entrada (publicar en Redis). `.and(...)` ignora los valores y espera a que ambos flujos
  terminen para cerrar la sesi√≥n `WebSocket`.

- `.and(...)` es un operador de combinaci√≥n de `Reactor`.
    - Se aplica sobre un `Mono<Void>` y recibe otro `Publisher<?>`.
    - Devuelve un `Mono<Void>` que:
        - `Ejecuta ambos flujos en paralelo`.
        - Se completa solo cuando ambos han finalizado (o uno falla).
- En este caso:
    - `session.send(outgoingFlux)` mantiene el flujo de mensajes hacia el cliente.
    - `incomingFlux` mantiene vivo el flujo de publicaci√≥n en Redis.

As√≠ logramos que enviar y recibir mensajes ocurran simult√°neamente durante toda la sesi√≥n `WebSocket`.

üìå Conclusi√≥n:
> El uso de `.and(...)` en este servicio asegura que tanto la publicaci√≥n de mensajes en Redis como la entrega de
> mensajes a los clientes `ocurran en paralelo`, y que el ciclo de vida completo quede controlado por `WebFlux`.
>
> Al usar `.then()` sobre `incomingFlux`, dejamos claro que los valores emitidos por `Redis` no se usan, haciendo
> el c√≥digo m√°s limpio y expresivo.

## WebSocket Config

Para habilitar la comunicaci√≥n por `WebSocket` en nuestra aplicaci√≥n usamos la clase de configuraci√≥n
`ChatRoomSocketConfig`.

````java

@RequiredArgsConstructor
@Configuration
public class ChatRoomSocketConfig {

    private final ChatRoomService chatRoomService;

    @Bean
    public HandlerMapping handlerMapping() {
        Map<String, WebSocketHandler> urlMap = Map.of(
                "/chat", this.chatRoomService
        );
        return new SimpleUrlHandlerMapping(urlMap, -1);
    }
}
````

üîé Explicaci√≥n

- `HandlerMapping` personalizado
    - Se crea un `SimpleUrlHandlerMapping` que expone el endpoint `/chat`.
    - Cada vez que un cliente se conecte a esta ruta, `Spring` delegar√° la sesi√≥n al `ChatRoomService`.
    - El par√°metro `-1` define la prioridad de este mapeo. Un valor negativo asegura que esta configuraci√≥n no
      interfiera con otros mapeos m√°s espec√≠ficos (por ejemplo, de controladores `@RestController`).

### ¬øQu√© significa ese `-1`?

`Spring` utiliza un mecanismo de ordenamiento para decidir qu√© `HandlerMapping` se eval√∫a primero cuando llega una
solicitud. Este orden se define con un n√∫mero entero:

| Valor de orden                                      | Prioridad       | ¬øQu√© implica?                                      |
|-----------------------------------------------------|-----------------|----------------------------------------------------|
| `Integer.MIN_VALUE` o valores muy bajos (como` -1`) | Alta prioridad  | Se eval√∫a antes que otros mappings con orden mayor |
| `0` o valores positivos                             | Menor prioridad | Se eval√∫an despu√©s.                                |

En nuestro caso espec√≠fico:

````bash
return new SimpleUrlHandlerMapping(urlMap, -1);
````

- El `-1` indica que este `HandlerMapping` tiene alta prioridad.
- Garantiza que las peticiones a `/chat` se redirijan directamente al `WebSocket` y no a otros controladores
  `@RestController` que podr√≠an tener el mismo path.
- Esto es √∫til cuando tienes m√∫ltiples `HandlerMapping` en tu aplicaci√≥n (por ejemplo, uno para `WebSocket` y otro para
  controladores HTTP normales).
- Al darle prioridad alta, Spring intentar√° resolver primero las rutas `WebSocket` antes de pasar a otros mapeos.

#### ¬øY si no se especifica?

Si no se define el orden, Spring usa un valor por defecto `(Ordered.LOWEST_PRECEDENCE)`, lo que podr√≠a hacer que este
mapping se eval√∫e despu√©s de otros, y eso podr√≠a causar que no se resuelva correctamente la ruta `/chat`.

#### Ejemplo pr√°ctico

Supongamos que tenemos el `@RestController` con:

````java

@GetMapping("/chat")
public String test() {
    return "REST endpoint";
}
````

Y nuestro `SimpleUrlHandlerMapping` est√° configurado con `orden -1`, entonces:

- Una petici√≥n `WebSocket` a `ws://localhost:8080/chat` ir√° al `WebSocketHandler`.
- Una petici√≥n `HTTP GET` a `http://localhost:8080/chat` seguir√° funcionando, porque son distintos protocolos.
- Pero `si no usas -1`, `Spring` podr√≠a resolver primero el `RestController` y nunca entrar al `WebSocket`.

> El par√°metro `-1` establece la prioridad del mapeo `WebSocket`, indicando que este `HandlerMapping` debe evaluarse
> antes que los mapeos por defecto. De esta forma, aseguramos que las conexiones a `/chat` sean manejadas correctamente
> por el `ChatRoomService` y no interfieran con otros endpoints.

La clase `ChatRoomService` implementa la l√≥gica central del `WebSocket`.

````java

@Slf4j
@RequiredArgsConstructor
@Service
public class ChatRoomService implements WebSocketHandler {

    private final RedissonReactiveClient client;

    @Override
    public Mono<Void> handle(WebSocketSession session) {
        String room = this.getChatRoomName(session);
        RTopicReactive topic = this.client.getTopic(room, StringCodec.INSTANCE);

        //subscribe
        Mono<Void> incomingFlux = session.receive()
                .map(WebSocketMessage::getPayloadAsText)
                .flatMap(topic::publish)
                .doOnError(throwable -> log.error(throwable.getMessage()))
                .doFinally(signalType -> log.info("Subscriber finally {}", signalType))
                .then();

        //publisher
        Flux<WebSocketMessage> outgoingFlux = topic.getMessages(String.class)
                .map(session::textMessage)
                .doOnError(throwable -> log.error(throwable.getMessage()))
                .doFinally(signalType -> log.info("Publisher finally {}", signalType));

        return session.send(outgoingFlux)
                .and(incomingFlux);
    }

    private String getChatRoomName(WebSocketSession session) {
        URI uri = session.getHandshakeInfo().getUri();
        return UriComponentsBuilder.fromUri(uri)
                .build()
                .getQueryParams()
                .toSingleValueMap()
                .getOrDefault("room", "default");
    }
}
````

üîé Explicaci√≥n

- Selecci√≥n din√°mica de salas `(getChatRoomName(...))`
    - El nombre de la sala de chat se extrae del par√°metro `room` en la `URL` del `WebSocket`.
    - Ejemplo de conexi√≥n desde el cliente: `ws://localhost:8080/chat?room=sala1`.
    - Si no se env√≠a un par√°metro `room`, se asigna autom√°ticamente `default`.


- Flujo de entrada `(incomingFlux)`
    - Cada mensaje recibido desde el cliente se publica en el canal Redis asociado a la sala.
    - Usamos `.then()` para ignorar los valores (Long) que devuelve publish y quedarnos √∫nicamente con la se√±al de
      finalizaci√≥n.


- Flujo de salida `(outgoingFlux)`
    - Escucha en el canal Redis y env√≠a todos los mensajes publicados hacia el cliente actual.
    - De esta forma, todos los clientes conectados a la misma sala reciben lo que cualquiera env√≠e.


- Combinaci√≥n con `.and(...)`
    - `session.send(outgoingFlux)` gestiona los mensajes que enviamos al cliente.
    - `incomingFlux` gestiona los mensajes entrantes que publicamos en Redis.
    - Con `.and(...)` ejecutamos ambos en paralelo, esperando a que terminen antes de cerrar la sesi√≥n.

‚ö° Beneficio principal

> Con esta configuraci√≥n, cualquier n√∫mero de instancias de tu aplicaci√≥n puede manejar clientes de m√∫ltiples salas en
> paralelo. `Redis` act√∫a como el punto de sincronizaci√≥n que asegura que los mensajes lleguen a todos los clientes de
> la misma sala, sin importar a qu√© instancia est√©n conectados.

**Nota**
> En la clase `CityService` comentamos esta anotaci√≥n `@Scheduled(fixedRate = 10_000)` dado que el m√©todo anotado
> con ese `scheduled` usa un servicio que deber√≠amos levantar, pero en nuestro caso no necesitamos trabajar con
> ning√∫n servicio externo.
