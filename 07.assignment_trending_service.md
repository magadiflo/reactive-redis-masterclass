# Secci√≥n 07: Trending Service - Tarea Asignada

---

## Tarea Asignada - M√©tricas del producto

El objetivo de esta tarea es implementar un servicio que permita `identificar los 3 productos m√°s visitados` por los
clientes.

Este tipo de funcionalidad es muy com√∫n en aplicaciones de e-commerce, ya que proporciona:

- `Visibilidad de tendencias`: mostrar en tiempo real cu√°les son los productos m√°s consultados.
- `Apoyo al marketing`: destacar productos populares en la p√°gina principal o en banners.
- `Optimizaci√≥n de negocio`: ayuda a la toma de decisiones en promociones, descuentos o gesti√≥n de inventario.

#### üìå Ejemplo del requerimiento

Se espera obtener un ranking din√°mico como el siguiente:

1. Producto A ‚Üí 120 visitas
2. Producto B ‚Üí 95 visitas
3. Producto C ‚Üí 70 visitas

Esto se representar√° en la interfaz de usuario, mostrando los productos con mayor n√∫mero de accesos.

![01.png](assets/section-07/01.png)

### Soluci√≥n Propuesta: Servicio de Visitas a Productos (Parte 1)

Para resolver este problema, implementaremos un Trending Service, el cual se encargar√° de:

- `Registrar cada visita a un producto` ‚Üí cada vez que un cliente accede al detalle de un producto, se enviar√° el
  productId a un flujo reactivo encargado de procesar estas visitas.
- `Mantener la informaci√≥n en Redis` ‚Üí mediante operaciones en lote `(RBatchReactive)` y estructuras de tipo Sorted Set,
  Redis almacenar√° el conteo de visitas de forma eficiente y en tiempo real.
- `Preparar los datos para obtener el top de productos m√°s visitados` ‚Üí los contadores se ir√°n acumulando por d√≠a,
  permitiendo luego construir un ranking (ejemplo: top 3 productos m√°s consultados).

En esta primera parte, nos enfocamos en la `estructura del servicio y su integraci√≥n en el flujo de productos` para
registrar las visitas autom√°ticamente cada vez que se consulta un producto.

## Soluci√≥n de la tarea - Servicio de visitas a productos (Parte 1)

Se crea una interfaz de servicio llamado `ProductVisitService` que define el contrato para registrar visitas a un
producto. En t√©rminos de arquitectura, esta interfaz funciona como una abstracci√≥n, lo que permite:

- Tener diferentes implementaciones sin cambiar el c√≥digo cliente.
- Facilitar pruebas unitarias (ej. mockear el servicio en un test).
- Mantener el principio Programar contra interfaces, no implementaciones.

La interfaz define un m√©todo llamado `addVisit(int productId)` que recibe como par√°metro un identificador √∫nico de
producto. Su prop√≥sito es registrar una visita al producto en cuesti√≥n. La implementaci√≥n concreta ser√° la encargada de
decidir c√≥mo se registra esa visita, en este caso utilizando `Redis`.

````java
public interface ProductVisitService {
    void addVisit(int productId);
}
````

### Implementaci√≥n del Servicio `ProductVisitServiceImpl`

Este servicio es la implementaci√≥n concreta de la interfaz `ProductVisitService`. Su responsabilidad es registrar
visitas a productos y mantener la informaci√≥n en `Redis` usando `Redisson` en modo reactivo `(RedissonReactiveClient)`.

````java

@Slf4j
@Service
public class ProductVisitServiceImpl implements ProductVisitService {

    private final RedissonReactiveClient client;
    private final Sinks.Many<Integer> sink;

    public ProductVisitServiceImpl(RedissonReactiveClient client) {
        this.client = client;
        this.sink = Sinks.many().unicast().onBackpressureBuffer();
    }

    @PostConstruct
    private void init() {
        this.sink.asFlux()
                .buffer(Duration.ofSeconds(3)) // list (1,2,1,1,3,5,1...)
                .map(listProductIds -> listProductIds.stream()
                        .collect(Collectors.groupingBy( // 1:4, 5:1...
                                Function.identity(),
                                Collectors.counting())
                        )
                )
                .flatMap(this::updateBatch)
                .subscribe();
    }

    @Override
    public void addVisit(int productId) {
        this.sink.tryEmitNext(productId);
    }

    private Mono<Void> updateBatch(Map<Integer, Long> productVisitCounts) {
        RBatchReactive batch = this.client.createBatch(BatchOptions.defaults());
        String format = DateTimeFormatter.ofPattern("yyyyMMdd").format(LocalDate.now());
        RScoredSortedSetReactive<Integer> set = batch.getScoredSortedSet("product:visit:" + format, IntegerCodec.INSTANCE);

        return Flux.fromIterable(productVisitCounts.entrySet())
                .map(productVisit -> set.addScore(productVisit.getKey(), productVisit.getValue()))
                .then(batch.execute())
                .then();
    }
}
````

- `RedissonReactiveClient`, cliente reactivo de `Redisson` que permite trabajar con estructuras de datos de `Redis` de
  forma `no bloqueante`.
- `Sinks.Many<Integer>`, un `sink` de `Project Reactor` que act√∫a como un publicador manual de eventos.
    - Aqu√≠ se publicar√°n los `productId` cada vez que se registre una visita.
    - Se usa `Sinks.many().unicast().onBackpressureBuffer()` para manejar correctamente la presi√≥n del sistema y evitar
      p√©rdida de eventos.
    - Se inicializa el sink como un canal unicast (un solo consumidor) con buffer para manejar picos de eventos.
- `@PostConstruct`: indica que este m√©todo se ejecuta autom√°ticamente despu√©s de construir el bean y de inyectar sus
  dependencias.
- `sink.asFlux()`: convierte el sink en un `Flux` para poder procesar los eventos publicados (los productId).
- `buffer(Duration.ofSeconds(3))`: acumula los eventos en listas de productId cada 3 segundos. Ejemplo:
  `[1,2,1,1,3,5,1...]`.
- Agrupaci√≥n y conteo (map):
    - Se transforma la lista en un mapa de conteo: `{1:4, 2:1, 3:1, 5:1}`.
    - Esto significa que en ese intervalo de 3 segundos, el producto con ID 1 fue visitado 4 veces.
- `flatMap(this::updateBatch)`: pasa el mapa de conteo al m√©todo que actualizar√° `Redis` en lote.
- `subscribe()`: activa el flujo reactivo (sin esto, nada se ejecuta).
- El m√©todo `addVisit(int productId)`, cada vez que un cliente visita un producto, este m√©todo es invocado. El
  `productId` se env√≠a al `sink`, que luego ser√° procesado por el flujo inicializado en `init()`.

En este punto, analicemos el paso a paso del m√©todo `updateBatch(...)`:

````java
private Mono<Void> updateBatch(Map<Integer, Long> productVisitCounts) {
    RBatchReactive batch = this.client.createBatch(BatchOptions.defaults());
    String format = DateTimeFormatter.ofPattern("yyyyMMdd").format(LocalDate.now());
    RScoredSortedSetReactive<Integer> set = batch.getScoredSortedSet("product:visit:" + format, IntegerCodec.INSTANCE);

    return Flux.fromIterable(productVisitCounts.entrySet())
            .map(productVisit -> set.addScore(productVisit.getKey(), productVisit.getValue()))
            .then(batch.execute())
            .then();
}
````

- `RBatchReactive`: permite ejecutar m√∫ltiples comandos en Redis en un solo lote, optimizando rendimiento.
- `String format = ...`: se construye una clave con la fecha del d√≠a (ejemplo: `product:visit:20250908`), lo que permite
  mantener m√©tricas diarias.
- `RScoredSortedSetReactive<Integer>`:
    - Se obtiene un `Sorted Set` de `Redis` (estructura ideal para rankings).
    - Cada producto se guarda con un score que representa su cantidad de visitas.
    - Se usa `IntegerCodec.INSTANCE` para serializar correctamente los IDs.
- `Flux.fromIterable(productVisitCounts.entrySet())`: itera sobre el mapa `{productId -> visitas}`.
- `map(productVisit -> set.addScore(...))`:
    - `set.addScore(...)` incrementa el score del producto en `Redis`.
    - Devuelve un `Mono<Double>` (el nuevo puntaje).

#### ü§î ¬øPor qu√© `map(..)` en lugar de `flatMap(..)`?

- `Lo esperado`: normalmente, como `set.addScore(...)` devuelve un `Mono<Double>`, deber√≠amos usar `flatMap` para
  `‚Äúdesenvolver‚Äù` ese Mono.
- `Lo que pasa en Redisson`: en este caso, `RScoredSortedSetReactive` no es un flujo reactivo real, sino un proxy
  dentro de un `RBatchReactive`.
    - Los m√©todos como `addScore` no se ejecutan inmediatamente, sino que registran la operaci√≥n en el batch.
    - Por eso, aunque devuelven un `Mono`, ese `Mono` es un dummy (no representa una ejecuci√≥n real).
- La ejecuci√≥n real ocurre reci√©n en `batch.execute()`.

#### Conclusi√≥n:

Usar flatMap aqu√≠ no aporta nada, y map es suficiente para ir construyendo el batch de operaciones.
Aunque en este caso, el uso de `map(..)` o `flatMap(..)` es indistinto, porque los valores intermedios no se consumen.
La cadena reactiva termina con `.then(batch.execute())`, que √∫nicamente se interesa en la finalizaci√≥n del flujo previo
y no en los resultados producidos.

> üìå Nota: en un escenario 100% reactivo `(sin RBatchReactive)`, s√≠ ser√≠a recomendable usar `flatMap` para evitar
> anidar `Monos` y trabajar directamente con los valores emitidos `(Flux<T>)`.

### Uso de `ProductVisitService` en `ProductServiceImplV2`

````java

@Slf4j
@RequiredArgsConstructor
@Service("v2")
public class ProductServiceImplV2 implements ProductService {

    private final CacheTemplate<Integer, Product> productCacheTemplate;
    private final ProductVisitService productVisitService;

    @Override
    public Mono<Product> getProduct(Integer productId) {
        return this.productCacheTemplate.get(productId)
                .doFirst(() -> this.productVisitService.addVisit(productId));
    }

    @Override
    public Mono<Product> updateProduct(Integer productId, Product product) {
        return this.productCacheTemplate.update(productId, product);
    }

    @Override
    public Mono<Void> deleteProduct(Integer productId) {
        return this.productCacheTemplate.delete(productId);
    }
}
````

1. M√©todo `getProduct(...)`
    - Se encarga de obtener un producto por su productId desde el `CacheTemplate` (que gestiona el cache en `Redis`).
    - Devuelve un `Mono<Product>` de manera reactiva.

2. `doFirst(..)`
    - Es un operador de `Reactor` que ejecuta la acci√≥n especificada antes de suscribirse al `Mono`.
    - En este caso, se asegura de que antes de iniciar la recuperaci√≥n del producto desde cache, se registre la visita.

3. `this.productVisitService.addVisit(productId)`
    - Llama al servicio de visitas para emitir un nuevo evento de visita en el sink.
    - Esto dispara el flujo definido en `ProductVisitServiceImpl` (acumular, agrupar y actualizar en batch a `Redis`).

#### ¬øPor qu√© `doFirst` y no `doOnNext` o `doOnSuccess`?

- `doFirst(..)` se ejecuta antes de cualquier otra operaci√≥n reactiva, garantizando que el registro de la visita se
  haga aunque luego falle la recuperaci√≥n del producto.
- Si se hubiera usado `doOnNext(..)` o `doOnSuccess(..)`, el registro solo ocurrir√≠a si efectivamente se recupera un
  producto (lo cual podr√≠a no pasar si no existe en cache).
- Con `doFirst(..)`, siempre se contabiliza la visita, lo que es m√°s realista: el cliente intent√≥ ver el producto,
  aunque no se haya encontrado.

## Soluci√≥n de la tarea - Business Metrics Service (Parte 2)

En esta segunda parte, implementaremos el servicio de m√©tricas de negocio, cuya finalidad es exponer un endpoint
reactivo que devuelva peri√≥dicamente los 3 productos m√°s visitados.

En un escenario real, este tipo de m√©tricas probablemente se gestionar√≠a en un microservicio independiente
(para separar responsabilidades), pero aqu√≠ lo mantendremos dentro del mismo proyecto por motivos de aprendizaje.

### 1. Servicio de M√©tricas (BusinessMetricsService)

````java

@Slf4j
@RequiredArgsConstructor
@Service
public class BusinessMetricsService {

    private final RedissonReactiveClient client;

    public Mono<Map<Integer, Double>> top3Products() {
        String format = DateTimeFormatter.ofPattern("yyyyMMdd").format(LocalDate.now());
        RScoredSortedSetReactive<Integer> set = this.client.getScoredSortedSet("product:visit:" + format, IntegerCodec.INSTANCE);
        return set.entryRangeReversed(0, 2)
                .map(scoredEntries -> scoredEntries.stream()
                        .collect(Collectors.toMap(
                                ScoredEntry::getValue,
                                ScoredEntry::getScore,
                                (existingValue, newValue) -> existingValue, // en caso de colisi√≥n, conserva el valor existente
                                LinkedHashMap::new
                        )));
    }
}
````

Explicaci√≥n paso a paso

1. Clave de Redis basada en fecha
    - Se construye la clave `product:visit:yyyyMMdd`, lo que permite llevar m√©tricas de visitas por d√≠a.
    - Ejemplo: `product:visit:20250908`.
2. Uso de `Sorted Set`
    - `Redis` guarda los productos en un `Sorted Set` donde:
        - `value` = productId.
        - `score` = n√∫mero de visitas.
3. `entryRangeReversed(0, 2)`
    - Obtiene los 3 elementos con mayor score (orden descendente).
    - Equivalente a un ‚ÄúTop 3 productos m√°s visitados‚Äù.
4. Transformaci√≥n a `Map<Integer, Double>`
    - Convierte la lista de `ScoredEntry<Integer>` en un `Map<productId, score>`.
    - Se usa `LinkedHashMap` para preservar el orden del ranking.

Analicemos el siguiente bloque de c√≥digo:

````java
public Mono<Map<Integer, Double>> top3Products() {
    /* code */
    return set.entryRangeReversed(0, 2)
            .map(scoredEntries -> scoredEntries.stream()
                    .collect(Collectors.toMap(
                            ScoredEntry::getValue,  // key = productId
                            ScoredEntry::getScore,  // value = n√∫mero de visitas
                            (existingValue, newValue) -> existingValue, // en caso de colisi√≥n, conserva el valor existente
                            LinkedHashMap::new // implementaci√≥n del Map
                    )));
}
````

El m√©todo `.collect(Collectors.toMap(...))` es el punto clave. Como necesitamos crear una implementaci√≥n espec√≠fica del
`Map` `(LinkedHashMap)`, usamos la versi√≥n de `toMap` que acepta 4 par√°metros. Si la implementaci√≥n de `Map` no fuese
relevante, podr√≠amos haber utilizado la versi√≥n m√°s simple con solo 2 par√°metros.

````
Collectors.toMap(
    keyMapper,        // c√≥mo obtener la clave
    valueMapper,      // c√≥mo obtener el valor
    mergeFunction,    // qu√© hacer si hay claves duplicadas
    mapSupplier       // qu√© implementaci√≥n de Map usar
)
````

- `(existingValue, newValue) -> existingValue`
    - `existingValue` ‚Üí el valor que ya estaba en el `Map`.
    - `newValue` ‚Üí el valor que intenta entrar para la misma clave.
    - Esta expresi√≥n significa:
  > "Si hay claves duplicadas, me quedo con el valor que ya estaba guardado y descarto el nuevo".

Resumen clarito

- `Colisi√≥n = claves iguales`.
- `existingValue` = valor ya en el Map.
- `newValue` = nuevo valor que intenta entrar.
- `(existingValue, newValue) -> existingValue` ‚Üí conserva el primero.
- `(existingValue, newValue) -> newValue` ‚Üí conserva el m√°s reciente.

### 2. Controlador (BusinessMetricsController)

````java

@RequiredArgsConstructor
@RestController
@RequestMapping(path = "/api/v1/products/metrics")
public class BusinessMetricsController {

    private final BusinessMetricsService businessMetricsService;

    @GetMapping(produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Mono<ResponseEntity<Flux<Map<Integer, Double>>>> getMetrics() {
        return Mono.fromSupplier(() -> ResponseEntity.ok(this.businessMetricsService.top3Products()
                .repeatWhen(longFlux -> Flux.interval(Duration.ofSeconds(3)))));
    }
}
````

Explicaci√≥n paso a paso

1. Endpoint
    - Ruta: `/api/v1/products/metrics`.
    - Producci√≥n de datos: `TEXT_EVENT_STREAM` ‚Üí esto activa `Server-Sent Events (SSE)`, permitiendo enviar datos de
      manera continua al cliente.
2. Flujo reactivo de m√©tricas
    - `businessMetricsService.top3Products()` devuelve el top 3 en el momento de la consulta.
    - `.repeatWhen(longFlux -> Flux.interval(Duration.ofSeconds(3)))`: vuelve a ejecutar la consulta cada 3 segundos,
      enviando un nuevo evento `SSE` al cliente.
3. Respuesta final
    - El m√©todo devuelve un `Flux<Map<Integer, Double>>` envuelto en un `ResponseEntity`.
    - Cada 3 segundos, el cliente recibir√° un nuevo ranking actualizado de productos visitados.

### Conclusi√≥n

En esta segunda parte:

- Creamos un servicio para consultar en Redis el Top 3 de productos m√°s visitados, usando Sorted Sets y claves diarias.
- Implementamos un endpoint reactivo SSE que transmite esta informaci√≥n de forma peri√≥dica (cada 3 segundos).

Esto sienta las bases para un dashboard en tiempo real que muestre la popularidad de los productos, una funcionalidad
muy com√∫n en sistemas de comercio electr√≥nico y anal√≠tica de datos.

## Probando la Soluci√≥n ‚Äì Business Metrics Service

En esta etapa validaremos el correcto funcionamiento del servicio de m√©tricas de negocio que hemos implementado.
La idea es generar carga hacia el servicio de productos, registrar visitas en `Redis` y verificar que nuestro endpoint
de m√©tricas `(/api/v1/products/metrics)` refleje en tiempo real cu√°les son los productos m√°s visitados.

### 1. Ejecuci√≥n de pruebas con JMeter

Para las pruebas utilizamos `Apache JMeter`, aprovechando el archivo de configuraci√≥n ya existente en el proyecto:

````
üìÑ external/jmeter/product-service.jmx 
````

Este archivo define un plan de pruebas que apunta al endpoint de productos en su versi√≥n v2:

````bash
@RequestMapping(path = "/api/v2/products") 
````

De esta forma, cada ejecuci√≥n de JMeter simula m√∫ltiples clientes accediendo a productos, lo que dispara el registro de
visitas en Redis a trav√©s del `ProductVisitService`.

El resultado en consola luego de ejecutar el siguiente comando muestra la tasa de peticiones procesadas por segundo y
confirma que no hubo errores (Err: 0 (0.00%)):

````bash
C:\jmeter\apache-jmeter-5.6.3\bin
$ jmeter -n -t D:\programming\spring\01.udemy\03.vinoth_selvaraj\reactive-redis-masterclass\external\jmeter\product-service.jmx
WARN StatusConsoleListener The use of package scanning to locate plugins is deprecated and will be removed in a future release
WARN StatusConsoleListener The use of package scanning to locate plugins is deprecated and will be removed in a future release
WARN StatusConsoleListener The use of package scanning to locate plugins is deprecated and will be removed in a future release
WARN StatusConsoleListener The use of package scanning to locate plugins is deprecated and will be removed in a future release
Creating summariser <summary>
Created the tree successfully using D:\programming\spring\01.udemy\03.vinoth_selvaraj\reactive-redis-masterclass\external\jmeter\product-service.jmx
Starting standalone test @ 2025 Sep 9 12:19:19 PET (1757438359384)
Waiting for possible Shutdown/StopTestNow/HeapDump/ThreadDump message on port 4445
summary +  10667 in 00:00:10 = 1033.0/s Avg:    30 Min:     0 Max:  1161 Err:     0 (0.00%) Active: 65 Started: 65 Finished: 0
summary + 145126 in 00:00:30 = 4837.5/s Avg:    31 Min:     0 Max:   529 Err:     0 (0.00%) Active: 200 Started: 200 Finished: 0
summary = 155793 in 00:00:40 = 3863.3/s Avg:    31 Min:     0 Max:  1161 Err:     0 (0.00%)
summary + 209720 in 00:00:30 = 6990.7/s Avg:    27 Min:     0 Max:   554 Err:     0 (0.00%) Active: 200 Started: 200 Finished: 0
summary = 365513 in 00:01:10 = 5197.4/s Avg:    29 Min:     0 Max:  1161 Err:     0 (0.00%)
summary + 190591 in 00:00:30 = 6353.0/s Avg:    30 Min:     0 Max:   241 Err:     0 (0.00%) Active: 200 Started: 200 Finished: 0
summary = 556104 in 00:01:40 = 5543.0/s Avg:    29 Min:     0 Max:  1161 Err:     0 (0.00%)
summary + 160650 in 00:00:30 = 5355.0/s Avg:    36 Min:     0 Max:   455 Err:     0 (0.00%) Active: 200 Started: 200 Finished: 0
summary = 716754 in 00:02:10 = 5499.7/s Avg:    31 Min:     0 Max:  1161 Err:     0 (0.00%)
summary + 242959 in 00:00:30 = 8098.9/s Avg:    24 Min:     0 Max:   353 Err:     0 (0.00%) Active: 200 Started: 200 Finished: 0
summary = 959713 in 00:02:40 = 5986.0/s Avg:    29 Min:     0 Max:  1161 Err:     0 (0.00%)
summary + 219066 in 00:00:30 = 7302.2/s Avg:    27 Min:     0 Max:   878 Err:     0 (0.00%) Active: 200 Started: 200 Finished: 0
summary = 1178779 in 00:03:10 = 6193.4/s Avg:    29 Min:     0 Max:  1161 Err:     0 (0.00%)
summary + 249961 in 00:00:30 = 8332.3/s Avg:    23 Min:     0 Max:   689 Err:     0 (0.00%) Active: 200 Started: 200 Finished: 0
summary = 1428740 in 00:03:40 = 6484.7/s Avg:    28 Min:     0 Max:  1161 Err:     0 (0.00%)
summary + 150236 in 00:00:30 = 5007.9/s Avg:    39 Min:     0 Max:   330 Err:     0 (0.00%) Active: 200 Started: 200 Finished: 0
summary = 1578976 in 00:04:10 = 6307.7/s Avg:    29 Min:     0 Max:  1161 Err:     0 (0.00%)
summary + 169501 in 00:00:30 = 5648.7/s Avg:    35 Min:     0 Max:   819 Err:     0 (0.00%) Active: 200 Started: 200 Finished: 0
summary = 1748477 in 00:04:40 = 6237.1/s Avg:    29 Min:     0 Max:  1161 Err:     0 (0.00%)
summary + 176332 in 00:00:20 = 8737.1/s Avg:    22 Min:     0 Max:   912 Err:     0 (0.00%) Active: 0 Started: 200 Finished: 200
summary = 1924809 in 00:05:01 = 6405.0/s Avg:    29 Min:     0 Max:  1161 Err:     0 (0.00%)
Tidying up ...    @ 2025 Sep 9 12:24:20 PET (1757438660194)
... end of run 
````

‚úÖ Esto confirma que el sistema soporta una alta carga de solicitudes concurrentes mientras registra visitas en Redis.

### 2. Validaci√≥n de las m√©tricas en tiempo real

Al mismo tiempo que `JMeter` ejecuta el archivo de pruebas (generando miles de solicitudes hacia `/api/v2/products`),
debemos realizar una petici√≥n manual al endpoint de m√©tricas para visualizar en tiempo real el resultado de esas
visitas:

````bash
$ curl -v http://localhost:8080/api/v1/products/metrics
>
< HTTP/1.1 200 OK
< transfer-encoding: chunked
< Content-Type: text/event-stream;charset=UTF-8
<
data:{"136":1410.0,"744":1409.0,"536":1409.0}

data:{"136":1426.0,"744":1425.0,"599":1421.0}

data:{"599":1436.0,"136":1436.0,"744":1435.0}

data:{"599":1449.0,"536":1444.0,"136":1444.0} 

...
````

El endpoint responde con datos en formato `Server-Sent Events (SSE)`, es decir, un flujo continuo de informaci√≥n que se
actualiza autom√°ticamente cada 3 segundos.

Aqu√≠ observamos que:

- Cada bloque `data:{...}` corresponde al Top 3 de productos m√°s visitados en ese instante.
- La clave representa el `productId`.
- El valor representa el n√∫mero de visitas `(score)` acumuladas.
- La actualizaci√≥n ocurre cada 3 segundos, como definimos en el `BusinessMetricsController`.
