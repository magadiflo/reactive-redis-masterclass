# Secci√≥n 07: Trending Service - Tarea Asignada

---

## Tarea Asignada - M√©tricas del producto

El objetivo de esta tarea es implementar un servicio que permita `identificar los 3 productos m√°s visitados` por los
clientes.

Este tipo de funcionalidad es muy com√∫n en aplicaciones de e-commerce, ya que proporciona:

- `Visibilidad de tendencias`: mostrar en tiempo real cu√°les son los productos m√°s consultados.
- `Apoyo al marketing`: destacar productos populares en la p√°gina principal o en banners.
- `Optimizaci√≥n de negocio`: ayuda a la toma de decisiones en promociones, descuentos o gesti√≥n de inventario.

#### üìå Ejemplo del requerimiento

Se espera obtener un ranking din√°mico como el siguiente:

1. Producto A ‚Üí 120 visitas
2. Producto B ‚Üí 95 visitas
3. Producto C ‚Üí 70 visitas

Esto se representar√° en la interfaz de usuario, mostrando los productos con mayor n√∫mero de accesos.

![01.png](assets/section-07/01.png)

### Soluci√≥n Propuesta: Servicio de Visitas a Productos (Parte 1)

Para resolver este problema, implementaremos un Trending Service, el cual se encargar√° de:

- `Registrar cada visita a un producto` ‚Üí cada vez que un cliente accede al detalle de un producto, se enviar√° el
  productId a un flujo reactivo encargado de procesar estas visitas.
- `Mantener la informaci√≥n en Redis` ‚Üí mediante operaciones en lote `(RBatchReactive)` y estructuras de tipo Sorted Set,
  Redis almacenar√° el conteo de visitas de forma eficiente y en tiempo real.
- `Preparar los datos para obtener el top de productos m√°s visitados` ‚Üí los contadores se ir√°n acumulando por d√≠a,
  permitiendo luego construir un ranking (ejemplo: top 3 productos m√°s consultados).

En esta primera parte, nos enfocamos en la `estructura del servicio y su integraci√≥n en el flujo de productos` para
registrar las visitas autom√°ticamente cada vez que se consulta un producto.

## Soluci√≥n de la tarea - Servicio de visitas a productos (Parte 1)

Se crea una interfaz de servicio llamado `ProductVisitService` que define el contrato para registrar visitas a un
producto. En t√©rminos de arquitectura, esta interfaz funciona como una abstracci√≥n, lo que permite:

- Tener diferentes implementaciones sin cambiar el c√≥digo cliente.
- Facilitar pruebas unitarias (ej. mockear el servicio en un test).
- Mantener el principio Programar contra interfaces, no implementaciones.

La interfaz define un m√©todo llamado `addVisit(int productId)` que recibe como par√°metro un identificador √∫nico de
producto. Su prop√≥sito es registrar una visita al producto en cuesti√≥n. La implementaci√≥n concreta ser√° la encargada de
decidir c√≥mo se registra esa visita, en este caso utilizando `Redis`.

````java
public interface ProductVisitService {
    void addVisit(int productId);
}
````

### Implementaci√≥n del Servicio `ProductVisitServiceImpl`

Este servicio es la implementaci√≥n concreta de la interfaz `ProductVisitService`. Su responsabilidad es registrar
visitas a productos y mantener la informaci√≥n en `Redis` usando `Redisson` en modo reactivo `(RedissonReactiveClient)`.

````java

@Slf4j
@Service
public class ProductVisitServiceImpl implements ProductVisitService {

    private final RedissonReactiveClient client;
    private final Sinks.Many<Integer> sink;

    public ProductVisitServiceImpl(RedissonReactiveClient client) {
        this.client = client;
        this.sink = Sinks.many().unicast().onBackpressureBuffer();
    }

    @PostConstruct
    private void init() {
        this.sink.asFlux()
                .buffer(Duration.ofSeconds(3)) // list (1,2,1,1,3,5,1...)
                .map(listProductIds -> listProductIds.stream()
                        .collect(Collectors.groupingBy( // 1:4, 5:1...
                                Function.identity(),
                                Collectors.counting())
                        )
                )
                .flatMap(this::updateBatch)
                .subscribe();
    }

    @Override
    public void addVisit(int productId) {
        this.sink.tryEmitNext(productId);
    }

    private Mono<Void> updateBatch(Map<Integer, Long> productVisitCounts) {
        RBatchReactive batch = this.client.createBatch(BatchOptions.defaults());
        String format = DateTimeFormatter.ofPattern("yyyyMMdd").format(LocalDate.now());
        RScoredSortedSetReactive<Integer> set = batch.getScoredSortedSet("product:visit:" + format, IntegerCodec.INSTANCE);

        return Flux.fromIterable(productVisitCounts.entrySet())
                .map(productVisit -> set.addScore(productVisit.getKey(), productVisit.getValue()))
                .then(batch.execute())
                .then();
    }
}
````

- `RedissonReactiveClient`, cliente reactivo de `Redisson` que permite trabajar con estructuras de datos de `Redis` de
  forma `no bloqueante`.
- `Sinks.Many<Integer>`, un `sink` de `Project Reactor` que act√∫a como un publicador manual de eventos.
    - Aqu√≠ se publicar√°n los `productId` cada vez que se registre una visita.
    - Se usa `Sinks.many().unicast().onBackpressureBuffer()` para manejar correctamente la presi√≥n del sistema y evitar
      p√©rdida de eventos.
    - Se inicializa el sink como un canal unicast (un solo consumidor) con buffer para manejar picos de eventos.
- `@PostConstruct`: indica que este m√©todo se ejecuta autom√°ticamente despu√©s de construir el bean y de inyectar sus
  dependencias.
- `sink.asFlux()`: convierte el sink en un `Flux` para poder procesar los eventos publicados (los productId).
- `buffer(Duration.ofSeconds(3))`: acumula los eventos en listas de productId cada 3 segundos. Ejemplo:
  `[1,2,1,1,3,5,1...]`.
- Agrupaci√≥n y conteo (map):
    - Se transforma la lista en un mapa de conteo: `{1:4, 2:1, 3:1, 5:1}`.
    - Esto significa que en ese intervalo de 3 segundos, el producto con ID 1 fue visitado 4 veces.
- `flatMap(this::updateBatch)`: pasa el mapa de conteo al m√©todo que actualizar√° `Redis` en lote.
- `subscribe()`: activa el flujo reactivo (sin esto, nada se ejecuta).
- El m√©todo `addVisit(int productId)`, cada vez que un cliente visita un producto, este m√©todo es invocado. El
  `productId` se env√≠a al `sink`, que luego ser√° procesado por el flujo inicializado en `init()`.

En este punto, analicemos el paso a paso del m√©todo `updateBatch(...)`:

````java
private Mono<Void> updateBatch(Map<Integer, Long> productVisitCounts) {
    RBatchReactive batch = this.client.createBatch(BatchOptions.defaults());
    String format = DateTimeFormatter.ofPattern("yyyyMMdd").format(LocalDate.now());
    RScoredSortedSetReactive<Integer> set = batch.getScoredSortedSet("product:visit:" + format, IntegerCodec.INSTANCE);

    return Flux.fromIterable(productVisitCounts.entrySet())
            .map(productVisit -> set.addScore(productVisit.getKey(), productVisit.getValue()))
            .then(batch.execute())
            .then();
}
````

- `RBatchReactive`: permite ejecutar m√∫ltiples comandos en Redis en un solo lote, optimizando rendimiento.
- `String format = ...`: se construye una clave con la fecha del d√≠a (ejemplo: `product:visit:20250908`), lo que permite
  mantener m√©tricas diarias.
- `RScoredSortedSetReactive<Integer>`:
    - Se obtiene un `Sorted Set` de `Redis` (estructura ideal para rankings).
    - Cada producto se guarda con un score que representa su cantidad de visitas.
    - Se usa `IntegerCodec.INSTANCE` para serializar correctamente los IDs.
- `Flux.fromIterable(productVisitCounts.entrySet())`: itera sobre el mapa `{productId -> visitas}`.
- `map(productVisit -> set.addScore(...))`:
    - `set.addScore(...)` incrementa el score del producto en `Redis`.
    - Devuelve un `Mono<Double>` (el nuevo puntaje).

#### ü§î ¬øPor qu√© `map(..)` en lugar de `flatMap(..)`?

- `Lo esperado`: normalmente, como `set.addScore(...)` devuelve un `Mono<Double>`, deber√≠amos usar `flatMap` para
  `‚Äúdesenvolver‚Äù` ese Mono.
- `Lo que pasa en Redisson`: en este caso, `RScoredSortedSetReactive` no es un flujo reactivo real, sino un proxy
  dentro de un `RBatchReactive`.
    - Los m√©todos como `addScore` no se ejecutan inmediatamente, sino que registran la operaci√≥n en el batch.
    - Por eso, aunque devuelven un `Mono`, ese `Mono` es un dummy (no representa una ejecuci√≥n real).
- La ejecuci√≥n real ocurre reci√©n en `batch.execute()`.

#### Conclusi√≥n:

Usar flatMap aqu√≠ no aporta nada, y map es suficiente para ir construyendo el batch de operaciones.
Aunque en este caso, el uso de `map(..)` o `flatMap(..)` es indistinto, porque los valores intermedios no se consumen.
La cadena reactiva termina con `.then(batch.execute())`, que √∫nicamente se interesa en la finalizaci√≥n del flujo previo
y no en los resultados producidos.

> üìå Nota: en un escenario 100% reactivo `(sin RBatchReactive)`, s√≠ ser√≠a recomendable usar `flatMap` para evitar
> anidar `Monos` y trabajar directamente con los valores emitidos `(Flux<T>)`.

### Uso de `ProductVisitService` en `ProductServiceImplV2`

````java

@Slf4j
@RequiredArgsConstructor
@Service("v2")
public class ProductServiceImplV2 implements ProductService {

    private final CacheTemplate<Integer, Product> productCacheTemplate;
    private final ProductVisitService productVisitService;

    @Override
    public Mono<Product> getProduct(Integer productId) {
        return this.productCacheTemplate.get(productId)
                .doFirst(() -> this.productVisitService.addVisit(productId));
    }

    @Override
    public Mono<Product> updateProduct(Integer productId, Product product) {
        return this.productCacheTemplate.update(productId, product);
    }

    @Override
    public Mono<Void> deleteProduct(Integer productId) {
        return this.productCacheTemplate.delete(productId);
    }
}
````

1. M√©todo `getProduct(...)`
    - Se encarga de obtener un producto por su productId desde el `CacheTemplate` (que gestiona el cache en `Redis`).
    - Devuelve un `Mono<Product>` de manera reactiva.

2. `doFirst(..)`
    - Es un operador de `Reactor` que ejecuta la acci√≥n especificada antes de suscribirse al `Mono`.
    - En este caso, se asegura de que antes de iniciar la recuperaci√≥n del producto desde cache, se registre la visita.

3. `this.productVisitService.addVisit(productId)`
    - Llama al servicio de visitas para emitir un nuevo evento de visita en el sink.
    - Esto dispara el flujo definido en `ProductVisitServiceImpl` (acumular, agrupar y actualizar en batch a `Redis`).

#### ¬øPor qu√© `doFirst` y no `doOnNext` o `doOnSuccess`?

- `doFirst(..)` se ejecuta antes de cualquier otra operaci√≥n reactiva, garantizando que el registro de la visita se
  haga aunque luego falle la recuperaci√≥n del producto.
- Si se hubiera usado `doOnNext(..)` o `doOnSuccess(..)`, el registro solo ocurrir√≠a si efectivamente se recupera un
  producto (lo cual podr√≠a no pasar si no existe en cache).
- Con `doFirst(..)`, siempre se contabiliza la visita, lo que es m√°s realista: el cliente intent√≥ ver el producto,
  aunque no se haya encontrado.
