# Secci√≥n 04: Redisson - Curso Intensivo

---

## Introducci√≥n: Librer√≠as de Redis para Java

Cuando trabajamos con `Redis` desde aplicaciones `Java`, existen varias bibliotecas cliente disponibles. Las m√°s
destacadas son: `Jedis`, `Lettuce` y `Redisson`. A continuaci√≥n, se presenta un resumen comparativo de sus principales
caracter√≠sticas.

### 1. Jedis

- ‚úÖ R√°pido en operaciones b√°sicas.
- ‚ùå No es seguro para m√∫ltiples hilos (thread-unsafe). Cada hilo necesita su propia conexi√≥n.
- ‚ùå No es escalable para entornos modernos concurrentes.
- ‚ùå No soporta programaci√≥n reactiva (reactive-streams).
- ‚ö†Ô∏è Obsoleto para aplicaciones modernas. Aunque sigue siendo funcional, su mantenimiento ha deca√≠do y su enfoque est√°
  desactualizado frente a soluciones m√°s modernas.
- üî• Conclusi√≥n: No se recomienda para nuevos proyectos.

### 2. Lettuce

- ‚úÖ Escalable y seguro para m√∫ltiples hilos (basado en Netty).
- ‚úÖ Compatible con programaci√≥n reactiva (soporta reactive-streams).
- ‚úÖ Compatible con Spring Data Redis.
  > Nota: No existe un ReactiveCrudRepository oficial para Redis, por lo tanto, se suelen usar operaciones reactivas
  personalizadas.
- ‚ö†Ô∏è API de bajo nivel, requiere escribir m√°s c√≥digo para tareas comunes.
- ‚ûï Puede coexistir con Redisson en un mismo proyecto, aunque:
    - En la mayor√≠a de casos, usar ambos no es necesario.
    - Si tu proyecto requiere estructuras avanzadas y abstracciones de alto nivel, Redisson suele ser la mejor opci√≥n.

### 3. Redisson

- ‚úÖ Escalable y compatible con programaci√≥n reactiva (reactive-streams).
- ‚úÖ Excelente nivel de abstracci√≥n. Simplifica el uso de estructuras de datos y patrones distribuidos.
- ‚úÖ Compatible con Spring Data Redis.
- ‚úÖ Gran compatibilidad con estructuras de datos de Redis, mejor que Lettuce en muchos casos.
- ‚úÖ Excelente documentaci√≥n y comunidad activa (m√°s de 16k estrellas en GitHub).
- üß† Funcionalidades destacadas:
    - Mapas, colas, listas, locks distribuidos, sem√°foros, contadores at√≥micos, entre otros.
    - Soporte para objetos distribuidos con facilidad.
    - Manejo de cache local + cache Redis (modo h√≠brido).
- üî• Conclusi√≥n: Ideal para quienes desean aprovechar Redis al m√°ximo sin lidiar con los detalles de bajo nivel.

## Recomendaci√≥n general

- Si tu proyecto requiere control detallado, bajo consumo de recursos y ya est√°s usando Spring Data Redis, puedes optar
  por Lettuce.
- Si necesitas una API de alto nivel con m√∫ltiples abstracciones listas para usar, lo m√°s conveniente es usar Redisson.
- Evita Jedis en nuevos desarrollos, a menos que tengas una raz√≥n muy espec√≠fica para ello.

## Configuraci√≥n del proyecto Java Maven

En este apartado crearemos un proyecto solo con `Java Maven` con nuestro `IntelliJ IDEA`. Luego, en el `pom.xml`
generalo le agregaremos
[las dependencias que nos proporcion√≥ el tutor](https://github.com/vinsguru/redis-webflux/blob/master/redisson-playground/pom.xml).

Este proyecto llamado `redisson-playground` nos servir√° para ir jugando con `Redission`, es decir ver c√≥mo es que
funciona e ir introduci√©ndonos en el uso de esa librer√≠a.

````xml
<!--maven.compiler.source 21-->
<!--maven.compiler.target 21-->
<!--project.build.sourceEncoding-->
<!--redisson.version 3.47.0-->
<!--lombok.version 1.18.36-->
<!--junit.version 5.11.3-->
<dependencies>
    <dependency>
        <groupId>org.redisson</groupId>
        <artifactId>redisson</artifactId>
        <version>${redisson.version}</version>
    </dependency>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <version>${lombok.version}</version>
        <scope>provided</scope>
    </dependency>
    <dependency>
        <groupId>io.projectreactor</groupId>
        <artifactId>reactor-test</artifactId>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>org.junit.jupiter</groupId>
        <artifactId>junit-jupiter-engine</artifactId>
        <version>${junit.version}</version>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>ch.qos.logback</groupId>
        <artifactId>logback-classic</artifactId>
        <version>1.5.18</version>
    </dependency>
</dependencies>
````

## Redisson Client

Creamos la clase `RedissonConfig` con la configuraci√≥n manual del `cliente Redisson`, utilizada para conectarse a una
instancia local de `Redis`. Dado que a√∫n no estamos usando `Spring Boot`, aqu√≠ se hace la configuraci√≥n `"a mano"`,
lo cual es √∫til para entender c√≥mo funciona internamente `Redisson`.

````java
public class RedissonConfig {

    private RedissonClient redissonClient;

    public RedissonClient getClient() {
        if (Objects.isNull(this.redissonClient)) {
            Config config = new Config();
            config.useSingleServer()
                    .setAddress("redis://127.0.0.1:6379");
            this.redissonClient = Redisson.create(config);
        }
        return this.redissonClient;
    }

    public RedissonReactiveClient getReactiveClient() {
        return this.getClient().reactive();
    }
}
````

- Campo `private RedissonClient redissonClient`
    - Se declara una instancia privada de tipo `RedissonClient`, la cual es el cliente principal que usaremos para
      interactuar con `Redis`.
    - Esta instancia se inicializa perezosamente (`lazy initialization`), es decir, solo se crea cuando realmente se
      necesita.


- M√©todo `getClient()`. Este m√©todo devuelve una instancia de `RedissonClient`. Su l√≥gica es:
    - Si `redissonClient` a√∫n no ha sido creado, lo inicializa:
        - Se crea una instancia de `Config`, que contiene la configuraci√≥n de `Redisson`.
        - Se utiliza el modo de `servidor √∫nico` (`useSingleServer()`) porque estamos conect√°ndonos a un `Redis local`.
        - La direcci√≥n se define como `redis://127.0.0.1:6379`, que es el puerto por defecto de `Redis` en `localhost`.
    - Se crea el cliente con `Redisson.create(config)`.
    - Finalmente, se retorna el cliente (`redissonClient`). Este patr√≥n de inicializaci√≥n evita que se creen m√∫ltiples
      instancias del cliente, lo cual es importante para conservar conexiones y evitar errores.


- M√©todo `getReactiveClient()`. Este m√©todo devuelve una instancia de `RedissonReactiveClient`, que permite trabajar de
  `forma reactiva con Redis`:
    - Internamente, `Redisson` tiene soporte tanto para un `cliente imperativo (RedissonClient)` como para uno
      `reactivo (RedissonReactiveClient)`.
    - Este m√©todo simplemente obtiene el cliente imperativo y devuelve su versi√≥n reactiva.
    - Este `cliente reactivo` es compatible con `Project Reactor` (`Mono`, `Flux`), por lo que ser√° √∫til cuando
      trabajemos con `Spring WebFlux`.

### ‚úÖ Ventajas de esta clase

- Separa claramente la configuraci√≥n de Redisson.
- Permite reutilizar el cliente sin crear nuevas conexiones innecesarias.
- Facilita el acceso tanto al cliente imperativo como al reactivo.
- Es un buen ejercicio para comprender la configuraci√≥n sin depender de Spring Boot.

### ‚ö†Ô∏è Observaciones importantes

- Esta clase `no es thread-safe` si la vas a usar en entornos concurrentes. Aunque funciona bien en pruebas simples, en
  producci√≥n deber√≠as garantizar que el cliente se cree una sola vez de manera segura (por ejemplo, usando un
  `singleton` adecuado o `synchronized` si no usas Spring).
- En entornos reales con m√∫ltiples nodos Redis o cl√∫steres, se usar√≠a otra variante de configuraci√≥n como
  `useClusterServers()`, `useSentinelServers()`, etc.
- Cuando se pase a Spring Boot, esta configuraci√≥n se podr√° reemplazar por Beans gestionados por el contenedor,
  aprovechando inyecci√≥n de dependencias y configuraci√≥n centralizada.

### üìù Resumen

| M√©todo                | Descripci√≥n                                                                                                         |
|-----------------------|---------------------------------------------------------------------------------------------------------------------|
| `getClient()`         | Retorna una instancia √∫nica de `RedissonClient`, conectada a Redis local (`localhost:6379`). Si no existe, la crea. |
| `getReactiveClient()` | Retorna una instancia de `RedissonReactiveClient`, √∫til para programaci√≥n reactiva con `Mono` y `Flux`.             |

## Base Test

Creamos una clase llamada `BaseTest` que ser√° una clase abstracta de configuraci√≥n com√∫n para todas las pruebas que
usen `Redisson`. Su objetivo es centralizar la l√≥gica de creaci√≥n y liberaci√≥n del `cliente Redisson reactivo`
(`RedissonReactiveClient`), evitando repetir este c√≥digo en cada clase de prueba.

````java

@TestInstance(TestInstance.Lifecycle.PER_CLASS)
public abstract class BaseTest {

    private final RedissonConfig redissonConfig = new RedissonConfig();
    protected RedissonReactiveClient client;

    @BeforeAll
    void beforeAll() {
        this.client = this.redissonConfig.getReactiveClient();
    }

    @AfterAll
    void afterAll() {
        this.redissonConfig.getClient().shutdown();
    }

    protected void sleep(long millis) {
        try {
            Thread.sleep(millis);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
````

- `@TestInstance(TestInstance.Lifecycle.PER_CLASS)`
    - Por defecto, `JUnit 5` crea una nueva instancia de la clase de prueba por cada m√©todo de prueba. Eso implica que
      los m√©todos `@BeforeAll` y `@AfterAll` deben ser est√°ticos (`static`), ya que se ejecutan
      `antes y despu√©s de todos los tests`.
    - Al declarar esta anotaci√≥n con `PER_CLASS`, `JUnit` usa una √∫nica instancia de la clase de prueba para todos los
      m√©todos, lo que permite que `@BeforeAll` y `@AfterAll` sean m√©todos de instancia (`no est√°ticos`).
  > ‚úÖ Esto es √∫til cuando necesitas acceder a campos no est√°ticos o cuando prefieres una estructura m√°s orientada a
  objetos.

- Campo `private final RedissonConfig redissonConfig`
    - Se crea una instancia de `RedissonConfig`, que es la clase previamente definida donde configuramos el cliente
      `Redisson` (`imperativo` y `reactivo`).
    - Esta instancia se usa para obtener el cliente reactivo.


- Campo `protected RedissonReactiveClient client`
    - Se define como protected para que est√© accesible directamente desde cualquier clase que extienda de `BaseTest`.
    - Aqu√≠ se almacena el `cliente reactivo de Redisson`, que ser√° usado en los tests para interactuar con Redis.


- M√©todo anotado con `@BeforeAll`
    - Se ejecuta una sola vez antes de todos los tests de la clase hija.
    - Inicializa el cliente Redisson reactivo.


- M√©todo anotado con `@AfterAll`
    - Se ejecuta una sola vez despu√©s de que todos los tests han finalizado.
    - Cierra correctamente el cliente Redisson.
  > ‚ö†Ô∏è Es importante liberar los recursos, ya que el cliente mantiene conexiones abiertas al servidor Redis. No
  cerrarlas puede provocar bloqueos o errores en pruebas posteriores.

### ‚úÖ Ventajas de esta clase

- Evita duplicaci√≥n de c√≥digo en las clases de prueba.
- Permite inicializar y limpiar el cliente Redisson de manera centralizada.
- Facilita que las clases hijas solo se concentren en escribir las pruebas.
- Mejora la mantenibilidad del proyecto de pruebas.

### üìù Resumen

| Elemento                        | Prop√≥sito                                                         |
|---------------------------------|-------------------------------------------------------------------|
| `@TestInstance(PER_CLASS)`      | Permite que `@BeforeAll` y `@AfterAll` sean m√©todos de instancia. |
| `BaseTest`                      | Clase abstracta base para compartir configuraci√≥n entre tests.    |
| `RedissonReactiveClient client` | Cliente reactivo compartido en todas las pruebas.                 |
| `beforeAll()`                   | Inicializa el cliente una vez al iniciar la suite de tests.       |
| `afterAll()`                    | Cierra el cliente despu√©s de ejecutar todos los tests.            |

## üß™ Key Value

Este apartado demuestra c√≥mo usar `Redisson` de forma reactiva para trabajar con claves y valores simples, utilizando
la estructura de datos Redis llamada String.

`Redisson` proporciona la interfaz `RBucketReactive<T>` para manejar este tipo de operaciones.

````java

@Slf4j
class Lec01KeyValueTest extends BaseTest {

    @Test
    void keyValueAccessTest() {
        RBucketReactive<String> bucket = this.client.getBucket("user:1:name");
        Mono<Void> set = bucket.set("sam");
        Mono<Void> get = bucket.get()
                .doOnNext(s -> log.info("{}", s))
                .then();

        StepVerifier.create(set.concatWith(get))
                .verifyComplete();
    }
}
````

- `RBucketReactive<String> bucket = this.client.getBucket("user:1:name")`;
    - Se obtiene una instancia de `RBucketReactive`, que representa una clave tipo string en Redis (estructura String).
    - El nombre de la clave es `user:1:name`.
    - Se especifica que el valor ser√° de tipo String.

      > üí° Redis no tiene tipos fuertes, pero `Redisson` s√≠ permite trabajar con tipos gen√©ricos en Java para mayor
      seguridad.


- `Mono<Void> set = bucket.set("sam")`
    - Se prepara una operaci√≥n reactiva para asignar el valor `"sam"` a la clave `user:1:name`.
    - No se ejecuta a√∫n: recuerda que en programaci√≥n reactiva, nada se ejecuta hasta que alguien lo suscribe (en este
      caso, `StepVerifier` lo hace).


- `Mono<Void> get = bucket.get()...`
    - Se prepara una operaci√≥n reactiva para obtener el valor de la clave `user:1:name`.
    - Se usa `doOnNext(...)` para loggear el valor recuperado (`sam`).
    - Luego se encadena con `.then()` para convertir el flujo en `Mono<Void>`, indicando que no nos interesa devolver
      el valor, solo esperar que termine.


- `StepVerifier.create(set.concatWith(get)).verifyComplete()`
    - Se combinan ambas operaciones (`set` seguido de `get`) usando `concatWith(...)`.
    - `StepVerifier` ejecuta el flujo reactivo y verifica que ambas operaciones se completen sin error.
    - Si algo falla (por ejemplo, Redis no est√° corriendo), el test falla.

Antes de ejecutar el test verificamos que no hay claves a√∫n en el servidor Redis.

````bash
127.0.0.1:6379> keys *
(empty array) 
````

Procedemos a ejecutar el test. Se imprime el valor `"sam"` desde el log gracias a `doOnNext(...)`.

````bash
12:22:39.961 [redisson-netty-1-6] INFO dev.magadiflo.test.Lec01KeyValueTest -- sam
````

Si volvemos al servidor de redis verificamos que:

- Redis muestra que la clave se ha guardado correctamente.
- El valor aparece codificado `("\x03sa\xed")` porque `Redisson` serializa los valores por defecto usando su propio
  mecanismo binario `(Codec)`, lo cual es totalmente normal.

````bash
127.0.0.1:6379> keys *
1) "user:1:name"
127.0.0.1:6379> get user:1:name
"\x03sa\xed" 
````

### ‚ö†Ô∏è Nota sobre el valor serializado

Por defecto, `Redisson` serializa los objetos usando un `codec` basado en `Kryo` o `Jackson`, lo cual hace que el valor
no se vea como texto plano en `Redis CLI`.

> üí° Si deseas que los valores se guarden como texto plano, puedes cambiar el codec por uno como `StringCodec`, lo
> veremos m√°s adelante.

### üìù Resumen

| Elemento           | Descripci√≥n                                                         |
|--------------------|---------------------------------------------------------------------|
| `RBucketReactive`  | Representa una clave tipo String en Redis.                          |
| `.set("sam")`      | Guarda un valor asociado a la clave.                                |
| `.get()`           | Recupera el valor asociado a la clave.                              |
| `StepVerifier`     | Ejecuta y verifica que el flujo reactivo se complete correctamente. |
| Valor en Redis CLI | Puede aparecer codificado por el codec predeterminado.              |

