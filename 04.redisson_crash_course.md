# Secci√≥n 04: Redisson - Curso Intensivo

---

## Introducci√≥n: Librer√≠as de Redis para Java

Cuando trabajamos con `Redis` desde aplicaciones `Java`, existen varias bibliotecas cliente disponibles. Las m√°s
destacadas son: `Jedis`, `Lettuce` y `Redisson`. A continuaci√≥n, se presenta un resumen comparativo de sus principales
caracter√≠sticas.

### 1. Jedis

- ‚úÖ R√°pido en operaciones b√°sicas.
- ‚ùå No es seguro para m√∫ltiples hilos (thread-unsafe). Cada hilo necesita su propia conexi√≥n.
- ‚ùå No es escalable para entornos modernos concurrentes.
- ‚ùå No soporta programaci√≥n reactiva (reactive-streams).
- ‚ö†Ô∏è Obsoleto para aplicaciones modernas. Aunque sigue siendo funcional, su mantenimiento ha deca√≠do y su enfoque est√°
  desactualizado frente a soluciones m√°s modernas.
- üî• Conclusi√≥n: No se recomienda para nuevos proyectos.

### 2. Lettuce

- ‚úÖ Escalable y seguro para m√∫ltiples hilos (basado en Netty).
- ‚úÖ Compatible con programaci√≥n reactiva (soporta reactive-streams).
- ‚úÖ Compatible con Spring Data Redis.
  > Nota: No existe un ReactiveCrudRepository oficial para Redis, por lo tanto, se suelen usar operaciones reactivas
  personalizadas.
- ‚ö†Ô∏è API de bajo nivel, requiere escribir m√°s c√≥digo para tareas comunes.
- ‚ûï Puede coexistir con Redisson en un mismo proyecto, aunque:
    - En la mayor√≠a de casos, usar ambos no es necesario.
    - Si tu proyecto requiere estructuras avanzadas y abstracciones de alto nivel, Redisson suele ser la mejor opci√≥n.

### 3. Redisson

- ‚úÖ Escalable y compatible con programaci√≥n reactiva (reactive-streams).
- ‚úÖ Excelente nivel de abstracci√≥n. Simplifica el uso de estructuras de datos y patrones distribuidos.
- ‚úÖ Compatible con Spring Data Redis.
- ‚úÖ Gran compatibilidad con estructuras de datos de Redis, mejor que Lettuce en muchos casos.
- ‚úÖ Excelente documentaci√≥n y comunidad activa (m√°s de 16k estrellas en GitHub).
- üß† Funcionalidades destacadas:
    - Mapas, colas, listas, locks distribuidos, sem√°foros, contadores at√≥micos, entre otros.
    - Soporte para objetos distribuidos con facilidad.
    - Manejo de cache local + cache Redis (modo h√≠brido).
- üî• Conclusi√≥n: Ideal para quienes desean aprovechar Redis al m√°ximo sin lidiar con los detalles de bajo nivel.

## Recomendaci√≥n general

- Si tu proyecto requiere control detallado, bajo consumo de recursos y ya est√°s usando Spring Data Redis, puedes optar
  por Lettuce.
- Si necesitas una API de alto nivel con m√∫ltiples abstracciones listas para usar, lo m√°s conveniente es usar Redisson.
- Evita Jedis en nuevos desarrollos, a menos que tengas una raz√≥n muy espec√≠fica para ello.

## Configuraci√≥n del proyecto Java Maven

En este apartado crearemos un proyecto solo con `Java Maven` con nuestro `IntelliJ IDEA`. Luego, en el `pom.xml`
generalo le agregaremos
[las dependencias que nos proporcion√≥ el tutor](https://github.com/vinsguru/redis-webflux/blob/master/redisson-playground/pom.xml).

Este proyecto llamado `redisson-playground` nos servir√° para ir jugando con `Redission`, es decir ver c√≥mo es que
funciona e ir introduci√©ndonos en el uso de esa librer√≠a.

````xml
<!--maven.compiler.source 21-->
<!--maven.compiler.target 21-->
<!--project.build.sourceEncoding-->
<!--redisson.version 3.47.0-->
<!--lombok.version 1.18.36-->
<!--junit.version 5.11.3-->
<dependencies>
    <dependency>
        <groupId>org.redisson</groupId>
        <artifactId>redisson</artifactId>
        <version>${redisson.version}</version>
    </dependency>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <version>${lombok.version}</version>
        <scope>provided</scope>
    </dependency>
    <dependency>
        <groupId>io.projectreactor</groupId>
        <artifactId>reactor-test</artifactId>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>org.junit.jupiter</groupId>
        <artifactId>junit-jupiter-engine</artifactId>
        <version>${junit.version}</version>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>ch.qos.logback</groupId>
        <artifactId>logback-classic</artifactId>
        <version>1.5.18</version>
    </dependency>
</dependencies>
````

## Redisson Client

Creamos la clase `RedissonConfig` con la configuraci√≥n manual del `cliente Redisson`, utilizada para conectarse a una
instancia local de `Redis`. Dado que a√∫n no estamos usando `Spring Boot`, aqu√≠ se hace la configuraci√≥n `"a mano"`,
lo cual es √∫til para entender c√≥mo funciona internamente `Redisson`.

````java
public class RedissonConfig {

    private RedissonClient redissonClient;

    public RedissonClient getClient() {
        if (Objects.isNull(this.redissonClient)) {
            Config config = new Config();
            config.useSingleServer()
                    .setAddress("redis://127.0.0.1:6379");
            this.redissonClient = Redisson.create(config);
        }
        return this.redissonClient;
    }

    public RedissonReactiveClient getReactiveClient() {
        return this.getClient().reactive();
    }
}
````

- Campo `private RedissonClient redissonClient`
    - Se declara una instancia privada de tipo `RedissonClient`, la cual es el cliente principal que usaremos para
      interactuar con `Redis`.
    - Esta instancia se inicializa perezosamente (`lazy initialization`), es decir, solo se crea cuando realmente se
      necesita.


- M√©todo `getClient()`. Este m√©todo devuelve una instancia de `RedissonClient`. Su l√≥gica es:
    - Si `redissonClient` a√∫n no ha sido creado, lo inicializa:
        - Se crea una instancia de `Config`, que contiene la configuraci√≥n de `Redisson`.
        - Se utiliza el modo de `servidor √∫nico` (`useSingleServer()`) porque estamos conect√°ndonos a un `Redis local`.
        - La direcci√≥n se define como `redis://127.0.0.1:6379`, que es el puerto por defecto de `Redis` en `localhost`.
    - Se crea el cliente con `Redisson.create(config)`.
    - Finalmente, se retorna el cliente (`redissonClient`). Este patr√≥n de inicializaci√≥n evita que se creen m√∫ltiples
      instancias del cliente, lo cual es importante para conservar conexiones y evitar errores.


- M√©todo `getReactiveClient()`. Este m√©todo devuelve una instancia de `RedissonReactiveClient`, que permite trabajar de
  `forma reactiva con Redis`:
    - Internamente, `Redisson` tiene soporte tanto para un `cliente imperativo (RedissonClient)` como para uno
      `reactivo (RedissonReactiveClient)`.
    - Este m√©todo simplemente obtiene el cliente imperativo y devuelve su versi√≥n reactiva.
    - Este `cliente reactivo` es compatible con `Project Reactor` (`Mono`, `Flux`), por lo que ser√° √∫til cuando
      trabajemos con `Spring WebFlux`.

### ‚úÖ Ventajas de esta clase

- Separa claramente la configuraci√≥n de Redisson.
- Permite reutilizar el cliente sin crear nuevas conexiones innecesarias.
- Facilita el acceso tanto al cliente imperativo como al reactivo.
- Es un buen ejercicio para comprender la configuraci√≥n sin depender de Spring Boot.

### ‚ö†Ô∏è Observaciones importantes

- Esta clase `no es thread-safe` si la vas a usar en entornos concurrentes. Aunque funciona bien en pruebas simples, en
  producci√≥n deber√≠as garantizar que el cliente se cree una sola vez de manera segura (por ejemplo, usando un
  `singleton` adecuado o `synchronized` si no usas Spring).
- En entornos reales con m√∫ltiples nodos Redis o cl√∫steres, se usar√≠a otra variante de configuraci√≥n como
  `useClusterServers()`, `useSentinelServers()`, etc.
- Cuando se pase a Spring Boot, esta configuraci√≥n se podr√° reemplazar por Beans gestionados por el contenedor,
  aprovechando inyecci√≥n de dependencias y configuraci√≥n centralizada.

### üìù Resumen

| M√©todo                | Descripci√≥n                                                                                                         |
|-----------------------|---------------------------------------------------------------------------------------------------------------------|
| `getClient()`         | Retorna una instancia √∫nica de `RedissonClient`, conectada a Redis local (`localhost:6379`). Si no existe, la crea. |
| `getReactiveClient()` | Retorna una instancia de `RedissonReactiveClient`, √∫til para programaci√≥n reactiva con `Mono` y `Flux`.             |

## Base Test

Creamos una clase llamada `BaseTest` que ser√° una clase abstracta de configuraci√≥n com√∫n para todas las pruebas que
usen `Redisson`. Su objetivo es centralizar la l√≥gica de creaci√≥n y liberaci√≥n del `cliente Redisson reactivo`
(`RedissonReactiveClient`), evitando repetir este c√≥digo en cada clase de prueba.

````java

@TestInstance(TestInstance.Lifecycle.PER_CLASS)
public abstract class BaseTest {

    private final RedissonConfig redissonConfig = new RedissonConfig();
    protected RedissonReactiveClient client;

    @BeforeAll
    void beforeAll() {
        this.client = this.redissonConfig.getReactiveClient();
    }

    @AfterAll
    void afterAll() {
        this.redissonConfig.getClient().shutdown();
    }

    protected void sleep(long millis) {
        try {
            Thread.sleep(millis);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
````

- `@TestInstance(TestInstance.Lifecycle.PER_CLASS)`
    - Por defecto, `JUnit 5` crea una nueva instancia de la clase de prueba por cada m√©todo de prueba. Eso implica que
      los m√©todos `@BeforeAll` y `@AfterAll` deben ser est√°ticos (`static`), ya que se ejecutan
      `antes y despu√©s de todos los tests`.
    - Al declarar esta anotaci√≥n con `PER_CLASS`, `JUnit` usa una √∫nica instancia de la clase de prueba para todos los
      m√©todos, lo que permite que `@BeforeAll` y `@AfterAll` sean m√©todos de instancia (`no est√°ticos`).
  > ‚úÖ Esto es √∫til cuando necesitas acceder a campos no est√°ticos o cuando prefieres una estructura m√°s orientada a
  objetos.

- Campo `private final RedissonConfig redissonConfig`
    - Se crea una instancia de `RedissonConfig`, que es la clase previamente definida donde configuramos el cliente
      `Redisson` (`imperativo` y `reactivo`).
    - Esta instancia se usa para obtener el cliente reactivo.


- Campo `protected RedissonReactiveClient client`
    - Se define como protected para que est√© accesible directamente desde cualquier clase que extienda de `BaseTest`.
    - Aqu√≠ se almacena el `cliente reactivo de Redisson`, que ser√° usado en los tests para interactuar con Redis.


- M√©todo anotado con `@BeforeAll`
    - Se ejecuta una sola vez antes de todos los tests de la clase hija.
    - Inicializa el cliente Redisson reactivo.


- M√©todo anotado con `@AfterAll`
    - Se ejecuta una sola vez despu√©s de que todos los tests han finalizado.
    - Cierra correctamente el cliente Redisson.
  > ‚ö†Ô∏è Es importante liberar los recursos, ya que el cliente mantiene conexiones abiertas al servidor Redis. No
  cerrarlas puede provocar bloqueos o errores en pruebas posteriores.

### ‚úÖ Ventajas de esta clase

- Evita duplicaci√≥n de c√≥digo en las clases de prueba.
- Permite inicializar y limpiar el cliente Redisson de manera centralizada.
- Facilita que las clases hijas solo se concentren en escribir las pruebas.
- Mejora la mantenibilidad del proyecto de pruebas.

### üìù Resumen

| Elemento                        | Prop√≥sito                                                         |
|---------------------------------|-------------------------------------------------------------------|
| `@TestInstance(PER_CLASS)`      | Permite que `@BeforeAll` y `@AfterAll` sean m√©todos de instancia. |
| `BaseTest`                      | Clase abstracta base para compartir configuraci√≥n entre tests.    |
| `RedissonReactiveClient client` | Cliente reactivo compartido en todas las pruebas.                 |
| `beforeAll()`                   | Inicializa el cliente una vez al iniciar la suite de tests.       |
| `afterAll()`                    | Cierra el cliente despu√©s de ejecutar todos los tests.            |

## üß™ Key Value

Este apartado demuestra c√≥mo usar `Redisson` de forma reactiva para trabajar con claves y valores simples, utilizando
la estructura de datos Redis llamada String.

`Redisson` proporciona la interfaz `RBucketReactive<T>` para manejar este tipo de operaciones.

````java

@Slf4j
class Lec01KeyValueTest extends BaseTest {

    @Test
    void keyValueAccessTest() {
        RBucketReactive<String> bucket = this.client.getBucket("user:1:name");
        Mono<Void> set = bucket.set("sam");
        Mono<Void> get = bucket.get()
                .doOnNext(s -> log.info("{}", s))
                .then();

        StepVerifier.create(set.concatWith(get))
                .verifyComplete();
    }
}
````

- `RBucketReactive<String> bucket = this.client.getBucket("user:1:name")`;
    - Se obtiene una instancia de `RBucketReactive`, que representa una clave tipo string en Redis (estructura String).
    - El nombre de la clave es `user:1:name`.
    - Se especifica que el valor ser√° de tipo String.

      > üí° Redis no tiene tipos fuertes, pero `Redisson` s√≠ permite trabajar con tipos gen√©ricos en Java para mayor
      seguridad.


- `Mono<Void> set = bucket.set("sam")`
    - Se prepara una operaci√≥n reactiva para asignar el valor `"sam"` a la clave `user:1:name`.
    - No se ejecuta a√∫n: recuerda que en programaci√≥n reactiva, nada se ejecuta hasta que alguien lo suscribe (en este
      caso, `StepVerifier` lo hace).


- `Mono<Void> get = bucket.get()...`
    - Se prepara una operaci√≥n reactiva para obtener el valor de la clave `user:1:name`.
    - Se usa `doOnNext(...)` para loggear el valor recuperado (`sam`).
    - Luego se encadena con `.then()` para convertir el flujo en `Mono<Void>`, indicando que no nos interesa devolver
      el valor, solo esperar que termine.


- `StepVerifier.create(set.concatWith(get)).verifyComplete()`
    - Se combinan ambas operaciones (`set` seguido de `get`) usando `concatWith(...)`.
    - `StepVerifier` ejecuta el flujo reactivo y verifica que ambas operaciones se completen sin error.
    - Si algo falla (por ejemplo, Redis no est√° corriendo), el test falla.

Antes de ejecutar el test verificamos que no hay claves a√∫n en el servidor Redis.

````bash
127.0.0.1:6379> keys *
(empty array) 
````

Procedemos a ejecutar el test. Se imprime el valor `"sam"` desde el log gracias a `doOnNext(...)`.

````bash
12:22:39.961 [redisson-netty-1-6] INFO dev.magadiflo.test.Lec01KeyValueTest -- sam
````

Si volvemos al servidor de redis verificamos que:

- Redis muestra que la clave se ha guardado correctamente.
- El valor aparece codificado `("\x03sa\xed")` porque `Redisson` serializa los valores por defecto usando su propio
  mecanismo binario `(Codec)`, lo cual es totalmente normal.

````bash
127.0.0.1:6379> keys *
1) "user:1:name"
127.0.0.1:6379> get user:1:name
"\x03sa\xed" 
````

### ‚ö†Ô∏è Nota sobre el valor serializado

Por defecto, `Redisson` serializa los objetos usando un `codec` basado en `Kryo` o `Jackson`, lo cual hace que el valor
no se vea como texto plano en `Redis CLI`.

> üí° Si deseas que los valores se guarden como texto plano, puedes cambiar el codec por uno como `StringCodec`, lo
> veremos m√°s adelante.

### üìù Resumen

| Elemento           | Descripci√≥n                                                         |
|--------------------|---------------------------------------------------------------------|
| `RBucketReactive`  | Representa una clave tipo String en Redis.                          |
| `.set("sam")`      | Guarda un valor asociado a la clave.                                |
| `.get()`           | Recupera el valor asociado a la clave.                              |
| `StepVerifier`     | Ejecuta y verifica que el flujo reactivo se complete correctamente. |
| Valor en Redis CLI | Puede aparecer codificado por el codec predeterminado.              |

## [Redisson Codec](https://redisson.pro/docs/data-and-services/data-serialization/)

Un `Codec` es el mecanismo que `Redisson` utiliza para serializar y deserializar los datos que se almacenan en `Redis`.
Por defecto, `Redisson` serializa los objetos en formato binario (por ejemplo, usando `Kryo`), lo cual no es legible
directamente desde la `CLI de Redis`.

Sin embargo, `Redisson` permite usar codecs alternativos, como `StringCodec`, para guardar datos como texto plano.

> üìò Documentaci√≥n
> oficial: [Redisson ‚Äì Data Serialization](https://redisson.pro/docs/data-and-services/data-serialization/)

````java

@Slf4j
class Lec01KeyValueTest extends BaseTest {
    @Test
    void keyValueAccessTestStringCodec() {
        RBucketReactive<String> bucket = this.client.getBucket("user:1:name", StringCodec.INSTANCE);
        Mono<Void> set = bucket.set("sam");
        Mono<Void> get = bucket.get()
                .doOnNext(s -> log.info("{}", s))
                .then();

        StepVerifier.create(set.concatWith(get))
                .verifyComplete();
    }
}
````

`this.client.getBucket("user:1:name", StringCodec.INSTANCE)`

- Se obtiene una instancia de `RBucketReactive`, pero esta vez se especifica el uso de `StringCodec`.
- Esto indica que el valor ser√° serializado y deserializado como texto plano.

> ‚úÖ Esto no solo afecta c√≥mo se lee en Java, sino c√≥mo se guarda en Redis.

### üñ•Ô∏è Resultado del log

Si ejecutamos la prueba anterior, el valor "sam" se imprime correctamente desde Java. Aqu√≠ no hay diferencia con la
prueba anterior, ya que `Redisson` lo deserializa sin problemas en ambos casos.

````bash
12:51:57.328 [redisson-netty-1-6] INFO dev.magadiflo.test.Lec01KeyValueTest -- sam
````

### üì¶ Revisi√≥n en Redis CLI

El cambio lo veremos cuando consultemos directamente en el servidor de redis.

- A diferencia del test anterior, ahora el valor es completamente legible en texto plano.
- Ya no aparece con caracteres binarios extra√±os como `\x03sa\xed`, porque no hay serializaci√≥n binaria: `Redisson`
  simplemente guarda `"sam"` como una cadena.

````bash
127.0.0.1:6379> get user:1:name
"sam"
````

### ‚úÖ ¬øCu√°ndo usar StringCodec?

- Cuando quieres ver los valores de Redis directamente desde CLI o herramientas como RedisInsight.
- Cuando est√°s trabajando con datos simples (String, Integer, etc.) y no necesitas serializar objetos complejos.
- Cuando necesitas que Redis pueda interoperar f√°cilmente con otros lenguajes o herramientas que esperan valores en
  texto plano.

### ‚ö†Ô∏è Consideraciones

- El uso de StringCodec no es adecuado si necesitas guardar objetos Java complejos. Para eso, es mejor usar codecs como
  JsonJacksonCodec, KryoCodec, etc.
- Se puede establecer un codec por objeto individual (como hiciste aqu√≠), o bien definir uno global al crear el cliente
  Redisson.

### üìù Resumen

| Elemento                | Descripci√≥n                                                                   |
|-------------------------|-------------------------------------------------------------------------------|
| `Codec`                 | Define c√≥mo se serializan/deserializan los datos en Redis.                    |
| `StringCodec`           | Guarda y lee los datos como texto plano, √∫til para claves simples y legibles. |
| Diferencia en Redis CLI | Con `StringCodec` ves valores legibles; sin √©l, ver√°s datos binarios.         |
| Aplicaci√≥n pr√°ctica     | Ideal para pruebas, depuraci√≥n y claves simples (`String`).                   |

## Bucket Expiry

`Redis` permite definir un `tiempo de vida (TTL)` para una clave, de modo que expire autom√°ticamente despu√©s de cierto
periodo. Esto es √∫til para escenarios como sesiones temporales, cach√©s, tokens de autenticaci√≥n, etc. En este ejemplo,
vemos c√≥mo aplicar expiraci√≥n a una clave utilizando `Redisson` de forma reactiva con `RBucketReactive`.

### üìå Ejemplo de expiraci√≥n con RBucketReactive

````java

@Test
void keyValueExpiryTest() {
    RBucketReactive<String> bucket = this.client.getBucket("user:1:name", StringCodec.INSTANCE);

    // Establecemos el valor con una expiraci√≥n de 10 segundos
    Mono<Void> set = bucket.set("sam", Duration.ofSeconds(10));

    Mono<Void> get = bucket.get()
            .doOnNext(s -> log.info("{}", s))
            .then();
    StepVerifier.create(set.concatWith(get))
            .verifyComplete();
}
````

### üß™ Resultado en consola Redis CLI

````bash
127.0.0.1:6379> keys *
(empty array)
127.0.0.1:6379> keys *
1) "user:1:name"
127.0.0.1:6379> get user:1:name
"sam"
127.0.0.1:6379> get user:1:name
"sam"
127.0.0.1:6379> get user:1:name
"sam"

# Despu√©s de 10 segundos...
127.0.0.1:6379> get user:1:name
(nil)
127.0.0.1:6379> keys *
(empty array)
````

- El m√©todo `bucket.set(value, Duration)` permite guardar un valor y asignarle una duraci√≥n tras la cual se eliminar√°
  autom√°ticamente.
- En este caso, guardamos `"sam"` bajo la clave `"user:1:name"` con una expiraci√≥n de `10 segundos`.
- La operaci√≥n `bucket.get()` nos permite recuperar el valor antes de que expire. En este ejemplo, se accede a la clave
  varias veces antes de su expiraci√≥n para comprobar que el valor persiste mientras est√© dentro del TTL.
- Una vez transcurridos los 10 segundos, `Redis` elimina autom√°ticamente la clave, lo que se comprueba al recibir
  `(nil)` en el get y ver que la lista de claves queda vac√≠a.

### üìå Ejemplo de extender la expiraci√≥n de una clave

En Redis, adem√°s de definir una expiraci√≥n al momento de crear la clave, tambi√©n es posible modificar o extender su
tiempo de vida posteriormente. Esto es √∫til en escenarios donde una operaci√≥n o interacci√≥n del usuario requiere
"renovar" el TTL de una clave ya existente, como por ejemplo: extender la duraci√≥n de una sesi√≥n activa.

````java

@Test
void keyValueExtendExpiryTest() {
    RBucketReactive<String> bucket = this.client.getBucket("user:1:name", StringCodec.INSTANCE);

    // Guardamos la clave con una expiraci√≥n inicial de 10 segundos
    Mono<Void> set = bucket.set("sam", Duration.ofSeconds(10));
    Mono<Void> get = bucket.get()
            .doOnNext(s -> log.info("{}", s))
            .then();
    StepVerifier.create(set.concatWith(get))
            .verifyComplete();

    // Esperamos 5 segundos antes de extender la expiraci√≥n
    this.sleep(5000);

    // Extendemos el TTL a 60 segundos desde el momento actual
    Mono<Boolean> mono = bucket.expire(Duration.ofSeconds(60));
    StepVerifier.create(mono)
            .expectNext(true)
            .verifyComplete();
}
````

### üß™ Resultado en consola Redis CLI

````bash
127.0.0.1:6379> keys *
(empty array)
127.0.0.1:6379> keys *
1) "user:1:name"
127.0.0.1:6379> ttl user:1:name
(integer) 6
127.0.0.1:6379> ttl user:1:name
(integer) 56
127.0.0.1:6379> ttl user:1:name
(integer) 52
127.0.0.1:6379> 
````

- Se define una clave `user:1:name` con un `TTL inicial` de `10 segundos`.
- Luego de 5 segundos (`sleep(5000)`), el tiempo restante es de aproximadamente 5 segundos.
- Al ejecutar `bucket.expire(Duration.ofSeconds(60))`, el `TTL se reinicia` y pasa a ser de `60 segundos` desde ese
  momento.
- El m√©todo `expire(...)` devuelve un `Mono<Boolean>`:
    - `true` si la operaci√≥n fue exitosa y la expiraci√≥n fue aplicada.
    - `false` si la clave no existe o no se pudo modificar el TTL.
- Se puede verificar la expiraci√≥n de una clave desde `Redis CLI` con el comando `TTL <key>`, que devuelve el tiempo
  restante en segundos.

### üìå Ejemplo al tiempo de expiraci√≥n

Una vez que una clave tiene un TTL asignado, Redis (y por extensi√≥n, Redisson) permite consultar cu√°nto tiempo le queda
antes de expirar. Esto puede ser √∫til para prop√≥sitos de observabilidad, control de sesiones, m√©tricas o l√≥gica
condicional basada en la proximidad de expiraci√≥n.

````java

@Test
void keyValueExtendExpiryTest() {
    RBucketReactive<String> bucket = this.client.getBucket("user:1:name", StringCodec.INSTANCE);
    Mono<Void> set = bucket.set("sam", Duration.ofSeconds(10));
    Mono<Void> get = bucket.get()
            .doOnNext(s -> log.info("{}", s))
            .then();
    StepVerifier.create(set.concatWith(get))
            .verifyComplete();

    // extendiendo el tiempo de vida
    this.sleep(5000);
    Mono<Boolean> mono = bucket.expire(Duration.ofSeconds(60));
    StepVerifier.create(mono)
            .expectNext(true)
            .verifyComplete();

    // Consultamos el tiempo restante antes de que expire
    Mono<Void> ttl = bucket.remainTimeToLive()
            .doOnNext(time -> log.info("{}", time))
            .then();
    StepVerifier.create(ttl)
            .verifyComplete();
}
````

### üß™ Resultado en logs

````bash
10:51:01.147 [redisson-netty-1-10] INFO dev.magadiflo.test.Lec01KeyValueTest -- 59997
````

- El m√©todo `bucket.remainTimeToLive()` devuelve un `Mono<Long>` que representa el `tiempo restante en milisegundos`
  antes de que la clave expire.
- En este caso, como el TTL fue extendido a 60 segundos y se consulta inmediatamente despu√©s, el valor mostrado es
  cercano a 60,000 ms.
- Este valor puede ser √∫til para:
    - Mostrarle al usuario cu√°nto tiempo le queda en su sesi√≥n.
    - Decidir si renovar o invalidar una clave.
    - Registrar m√©tricas para alertas o dashboards.

## Object Store

Hasta este punto, hemos trabajado con `valores simples` tipo cadena (`String`) en `Redis`. Sin embargo, `Redis` tambi√©n
permite almacenar objetos Java reales, lo cual es muy √∫til para manejar datos estructurados como perfiles de usuario,
configuraciones, entidades, etc.

`Redisson` facilita este proceso mediante `serializaci√≥n autom√°tica`, lo que nos permite guardar y recuperar objetos de
forma muy sencilla.

En este ejemplo, definimos un `record` llamado `Student` que representa un objeto de dominio:

````java
public record Student(String name, int age, String city) {
}
````

‚úÖ Nota: Usar record en lugar de clases tradicionales es una pr√°ctica recomendada para modelos inmutables y simples
(DTOs).

### üìå Ejemplo 1: guardar y leer un objeto desde Redis

````java

@Slf4j
class Lec02KeyValueObjectTest extends BaseTest {

    @Test
    void keyValueObjectTest() {
        Student studentToSave = new Student("martin", 36, "Lima");
        RBucketReactive<Student> bucket = this.client.getBucket("student:1");
        Mono<Void> set = bucket.set(studentToSave);
        Mono<Void> get = bucket.get()
                .doOnNext(student -> log.info("{}", student))
                .then();
        StepVerifier.create(set.concatWith(get))
                .verifyComplete();
    }
}
````

### üß™ Resultado en logs

````bash
12:01:55.373 [redisson-netty-1-6] INFO dev.magadiflo.test.Lec02KeyValueObjectTest -- Student[name=martin, age=36, city=Lima]
````

### üß™ Resultado en consola Redis CLI

Como se puede ver, el contenido de la clave `student:1` no es legible directamente. Esto es porque `Redisson` utiliza
un c√≥dec de serializaci√≥n binaria por defecto para almacenar objetos complejos.

````bash
127.0.0.1:6379> keys *
(empty array)
127.0.0.1:6379> keys *
1) "student:1"
127.0.0.1:6379> get student:1
"\x01\x00dev.magadiflo.test.dto.Studen\xf4HLim\xe1marti\xee"
127.0.0.1:6379>
````

### üìò Sobre los c√≥decs de serializaci√≥n

`Redisson` utiliza diferentes `Codecs (serializadores)` para transformar objetos Java en una representaci√≥n que pueda
ser almacenada en Redis.

Por defecto, `Redisson` usa `org.redisson.codec.FstCodec`, pero tambi√©n soporta otros c√≥decs como:

- JsonJacksonCodec
- TypedJsonJacksonCodec
- Kryo5Codec
- SerializationCodec
- AvroJacksonCodec
- SmileJacksonCodec
- entre otros...

Puedes elegir uno personalizado seg√∫n tus necesidades de legibilidad, rendimiento o compatibilidad con otros sistemas.

> üìö Documentaci√≥n oficial sobre Codecs:
> [Redisson ‚Äì Data Serialization](https://redisson.pro/docs/data-and-services/data-serialization/)

### ‚úÖ Consideraciones

- Redis no tiene estructura de objetos nativa. Toda la magia ocurre en el lado del cliente gracias a la serializaci√≥n y
  deserializaci√≥n autom√°tica que maneja Redisson.
- Si necesitas ver los datos de forma legible desde Redis CLI, puedes considerar usar un c√≥dec basado en JSON como
  `JsonJacksonCodec`.
- La clave `student:1` representa a un objeto completo, lo que significa que cualquier modificaci√≥n al objeto requiere
  sobrescribirlo completamente.

### üìå Ejemplo 2: almacenando objetos como JSON con JsonJacksonCodec

En el ejemplo anterior, vimos c√≥mo guardar objetos Java en Redis, pero el contenido almacenado no era legible desde la
CLI debido a la serializaci√≥n binaria por defecto.

En este nuevo ejemplo, usamos `JsonJacksonCodec`, un codec de `Redisson` que permite almacenar objetos como JSON plano,
lo cual facilita la lectura, depuraci√≥n y compatibilidad con otros sistemas.

Creamos una clase `Teacher` con anotaciones de `Lombok` para reducir la verbosidad del c√≥digo:

````java

@AllArgsConstructor
@NoArgsConstructor
@Builder
@Data
public class Teacher {
    private String name;
    private int age;
}
````

‚úÖ Nota: Al usar `@Data`, se generan autom√°ticamente `getters`, `setters`, `toString()`, `equals()` y `hashCode()`.

````java

@Test
void keyValueObjectTestJsonJacksonCodec() {
    Teacher teacherToSave = new Teacher("Gabriel", 52);
    RBucketReactive<Teacher> bucket = this.client.getBucket("teacher:1", JsonJacksonCodec.INSTANCE);
    Mono<Void> set = bucket.set(teacherToSave);
    Mono<Void> get = bucket.get()
            .doOnNext(teacher -> log.info("{}", teacher))
            .then();
    StepVerifier.create(set.concatWith(get))
            .verifyComplete();
}
````

### üß™ Resultado en consola Redis CLI

Ahora el valor almacenado en Redis es texto JSON legible, lo que facilita su inspecci√≥n o manipulaci√≥n desde otras
herramientas o lenguajes.

````bash
127.0.0.1:6379> keys *
(empty array)
127.0.0.1:6379> keys *
1) "teacher:1"
127.0.0.1:6379> get teacher:1
"{\"@class\":\"dev.magadiflo.test.dto.Teacher\",\"age\":52,\"name\":\"Gabriel\"}"
````

### üß™ Resultado en logs

````bash
12:25:00.393 [redisson-netty-1-6] INFO dev.magadiflo.test.Lec02KeyValueObjectTest -- Teacher(name=Gabriel, age=52) 
````

- `JsonJacksonCodec.INSTANCE` le indica a `Redisson` que debe serializar el objeto como JSON usando la biblioteca
  Jackson.
- Al recuperar el objeto, `Redisson` utiliza la propiedad `@class` incluida en el JSON para reconstruir correctamente
  la instancia original (`Teacher`).
- Este enfoque es excelente cuando queremos:
    - Inspeccionar los datos f√°cilmente.
    - Integrarnos con otros sistemas (por ejemplo, APIs REST, dashboards, etc.).
    - Mantener interoperabilidad entre microservicios escritos en diferentes lenguajes.

### üìå Ejemplo 3: almacenando objetos como JSON limpio con TypedJsonJacksonCodec

A diferencia de `JsonJacksonCodec`, que incluye metadatos como `@class` en la serializaci√≥n, el `TypedJsonJacksonCodec`
permite almacenar objetos en formato JSON m√°s limpio, sin esa informaci√≥n adicional. Esto es especialmente √∫til cuando
se desea que el contenido sea f√°cilmente interpretable o compatible con otros sistemas que no manejan clases Java.

````java

@Test
void keyValueObjectTestJsonJacksonCodec2() {
    Teacher teacherToSave = new Teacher("Gabriel", 52);
    RBucketReactive<Teacher> bucket = this.client.getBucket("teacher:1", new TypedJsonJacksonCodec(Teacher.class));
    Mono<Void> set = bucket.set(teacherToSave);
    Mono<Void> get = bucket.get()
            .doOnNext(teacher -> log.info("{}", teacher))
            .then();
    StepVerifier.create(set.concatWith(get))
            .verifyComplete();
}
````

### üß™ Resultado en consola Redis CLI

El contenido almacenado es ahora un JSON sin la propiedad `@class`, m√°s limpio y f√°cilmente consumible por otros
lenguajes o sistemas externos.

````bash
127.0.0.1:6379> keys *
(empty array)
127.0.0.1:6379> keys *
1) "teacher:1"
127.0.0.1:6379> get teacher:1
"{\"age\":52,\"name\":\"Gabriel\"}"
````

### üß™ Resultado en logs

````bash
12:36:26.203 [redisson-netty-1-6] INFO dev.magadiflo.test.Lec02KeyValueObjectTest -- Teacher(name=Gabriel, age=52)
````

- `TypedJsonJacksonCodec` es una variante de `JsonJacksonCodec` que omite la inclusi√≥n de metadatos de clase (`@class`)
  en el JSON.
- Al crear el codec con `new TypedJsonJacksonCodec(Teacher.class)`, `Redisson` ya sabe de antemano qu√© tipo de objeto
  deserializar, por lo tanto, no necesita anotar el tipo en el contenido.
- Esto produce un JSON m√°s est√°ndar, ideal si:
    - Redis es accedido por m√∫ltiples aplicaciones.
    - Se necesita interoperabilidad con APIs REST, microservicios o scripts externos.

### üìå Ejemplo 4: usando record con TypedJsonJacksonCodec

En este ejemplo se combina la simplicidad de los record de Java con la serializaci√≥n limpia y legible del
`TypedJsonJacksonCodec`, logrando un almacenamiento eficiente, legible y moderno en Redis.

Recordemos que anteriormente creamos el record Student

````java
public record Student(String name, int age, String city) {
}
````

‚úÖ Los record son ideales para definir objetos inmutables y estructuras de datos simples, especialmente en escenarios
como el almacenamiento en cach√© o el uso de DTOs.

````java

@Test
void keyValueObjectTestTypedJsonJacksonCodec() {
    Student studentToSave = new Student("martin", 36, "Lima");

    // Creamos un bucket con TypedJsonJacksonCodec para serializaci√≥n limpia sin @class
    RBucketReactive<Student> bucket = this.client.getBucket("student:1", new TypedJsonJacksonCodec(Student.class));
    Mono<Void> set = bucket.set(studentToSave);
    Mono<Void> get = bucket.get()
            .doOnNext(student -> log.info("{}", student))
            .then();
    StepVerifier.create(set.concatWith(get))
            .verifyComplete();
}
````

### üß™ Resultado en consola Redis CLI

El objeto se serializa como JSON legible y sin el campo `@class`, gracias a `TypedJsonJacksonCodec`.

````bash
 127.0.0.1:6379> keys *
(empty array)
127.0.0.1:6379> keys *
1) "student:1"
127.0.0.1:6379> get student:1
"{\"age\":36,\"city\":\"Lima\",\"name\":\"martin\"}"
````

### üß™ Resultado en logs

````bash
12:26:51.222 [redisson-netty-1-6] INFO dev.magadiflo.test.Lec02KeyValueObjectTest -- Student[name=martin, age=36, city=Lima]
````

- Se utiliza `TypedJsonJacksonCodec(Student.class)` para que Redisson sepa de antemano el tipo que debe deserializar.
- Esto elimina la necesidad de incluir metadatos adicionales en el JSON (como `@class`).
- El uso de record facilita a√∫n m√°s el modelo de datos, haciendo el c√≥digo m√°s limpio y conciso.

## üî¢ Number Store en Redis con Redisson

En la secci√≥n anterior del curso vimos c√≥mo Redis permite realizar operaciones de incremento (`INCR`) y decremento
(`DECR`) directamente sobre claves cuyo valor sea num√©rico (aunque est√© almacenado como una cadena de texto).

Por ejemplo, pod√≠amos ejecutar en Redis CLI:

````bash
incr some_key      # Incrementa el valor actual en 1
decr some_key      # Decrementa el valor actual en 1 
````

Este tipo de operaci√≥n es `at√≥mica` y muy √∫til para contar accesos, visitas, votos, intentos fallidos, etc.

> Cuando decimos que una operaci√≥n es `at√≥mica`, significa que:
> - *üîê Se ejecuta completamente o no se ejecuta, sin interferencia de otros hilos o procesos.*
> - *at√≥mico = seguro en entornos concurrentes*

`Redisson` tambi√©n nos permite realizar estas operaciones de forma reactiva a trav√©s de la clase `RAtomicLongReactive`.

````java

@Slf4j
class Lec03NumberTest extends BaseTest {
    @Test
    void keyValueIncreaseTest() {
        // Creamos una clave num√©rica reactiva
        RAtomicLongReactive atomicLong = this.client.getAtomicLong("user:1:visit");

        // Incrementamos la clave 30 veces, una vez por segundo
        Mono<Void> mono = Flux.range(1, 30)
                .delayElements(Duration.ofSeconds(1))
                .flatMap(i -> atomicLong.incrementAndGet()) // incremento at√≥mico
                .doOnNext(i -> log.info("{}", i))
                .then();

        StepVerifier.create(mono)
                .verifyComplete();
    }
}
````

Si ejecutamos el test y nos vamos a la consola de redis-cli veremos que efectivamente se est√° incrementando la clave
`user:1:visit` de uno en uno.

### üß™ Resultado en Redis CLI

Como se puede ver, la clave `user:1:visit` se incrementa correctamente con cada llamada, hasta llegar al valor esperado
de `30`.

````bash
127.0.0.1:6379> keys *
(empty array)
127.0.0.1:6379> keys *
1) "user:1:visit"
127.0.0.1:6379> get user:1:visit
"8"
127.0.0.1:6379> get user:1:visit
"9"
127.0.0.1:6379> get user:1:visit
"16"
127.0.0.1:6379> get user:1:visit
"17"
127.0.0.1:6379> get user:1:visit
"18"
127.0.0.1:6379> get user:1:visit
"30" 
````

### üß† Explicaci√≥n

- `RAtomicLongReactive` es el equivalente en `Redisson` de un contador num√©rico reactivo.
- El m√©todo `incrementAndGet()` incrementa el valor actual en 1 y devuelve el nuevo valor.
- Las operaciones sobre este tipo de clave son at√≥micas y seguras para entornos concurrentes.
- El flujo `Flux.range(...)` simula m√∫ltiples operaciones de incremento, con un retraso de 1 segundo entre cada una.

