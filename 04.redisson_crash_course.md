# Secci√≥n 04: Redisson - Curso Intensivo

---

## Introducci√≥n: Librer√≠as de Redis para Java

Cuando trabajamos con `Redis` desde aplicaciones `Java`, existen varias bibliotecas cliente disponibles. Las m√°s
destacadas son: `Jedis`, `Lettuce` y `Redisson`. A continuaci√≥n, se presenta un resumen comparativo de sus principales
caracter√≠sticas.

### 1. Jedis

- ‚úÖ R√°pido en operaciones b√°sicas.
- ‚ùå No es seguro para m√∫ltiples hilos (thread-unsafe). Cada hilo necesita su propia conexi√≥n.
- ‚ùå No es escalable para entornos modernos concurrentes.
- ‚ùå No soporta programaci√≥n reactiva (reactive-streams).
- ‚ö†Ô∏è Obsoleto para aplicaciones modernas. Aunque sigue siendo funcional, su mantenimiento ha deca√≠do y su enfoque est√°
  desactualizado frente a soluciones m√°s modernas.
- üî• Conclusi√≥n: No se recomienda para nuevos proyectos.

### 2. Lettuce

- ‚úÖ Escalable y seguro para m√∫ltiples hilos (basado en Netty).
- ‚úÖ Compatible con programaci√≥n reactiva (soporta reactive-streams).
- ‚úÖ Compatible con Spring Data Redis.
  > Nota: No existe un ReactiveCrudRepository oficial para Redis, por lo tanto, se suelen usar operaciones reactivas
  personalizadas.
- ‚ö†Ô∏è API de bajo nivel, requiere escribir m√°s c√≥digo para tareas comunes.
- ‚ûï Puede coexistir con Redisson en un mismo proyecto, aunque:
    - En la mayor√≠a de casos, usar ambos no es necesario.
    - Si tu proyecto requiere estructuras avanzadas y abstracciones de alto nivel, Redisson suele ser la mejor opci√≥n.

### 3. Redisson

- ‚úÖ Escalable y compatible con programaci√≥n reactiva (reactive-streams).
- ‚úÖ Excelente nivel de abstracci√≥n. Simplifica el uso de estructuras de datos y patrones distribuidos.
- ‚úÖ Compatible con Spring Data Redis.
- ‚úÖ Gran compatibilidad con estructuras de datos de Redis, mejor que Lettuce en muchos casos.
- ‚úÖ Excelente documentaci√≥n y comunidad activa (m√°s de 16k estrellas en GitHub).
- üß† Funcionalidades destacadas:
    - Mapas, colas, listas, locks distribuidos, sem√°foros, contadores at√≥micos, entre otros.
    - Soporte para objetos distribuidos con facilidad.
    - Manejo de cache local + cache Redis (modo h√≠brido).
- üî• Conclusi√≥n: Ideal para quienes desean aprovechar Redis al m√°ximo sin lidiar con los detalles de bajo nivel.

## Recomendaci√≥n general

- Si tu proyecto requiere control detallado, bajo consumo de recursos y ya est√°s usando Spring Data Redis, puedes optar
  por Lettuce.
- Si necesitas una API de alto nivel con m√∫ltiples abstracciones listas para usar, lo m√°s conveniente es usar Redisson.
- Evita Jedis en nuevos desarrollos, a menos que tengas una raz√≥n muy espec√≠fica para ello.

## Configuraci√≥n del proyecto Java Maven

En este apartado crearemos un proyecto solo con `Java Maven` con nuestro `IntelliJ IDEA`. Luego, en el `pom.xml`
generalo le agregaremos
[las dependencias que nos proporcion√≥ el tutor](https://github.com/vinsguru/redis-webflux/blob/master/redisson-playground/pom.xml).

Este proyecto llamado `redisson-playground` nos servir√° para ir jugando con `Redission`, es decir ver c√≥mo es que
funciona e ir introduci√©ndonos en el uso de esa librer√≠a.

````xml
<!--maven.compiler.source 21-->
<!--maven.compiler.target 21-->
<!--project.build.sourceEncoding-->
<!--redisson.version 3.47.0-->
<!--lombok.version 1.18.36-->
<!--junit.version 5.11.3-->
<dependencies>
    <dependency>
        <groupId>org.redisson</groupId>
        <artifactId>redisson</artifactId>
        <version>${redisson.version}</version>
    </dependency>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <version>${lombok.version}</version>
        <scope>provided</scope>
    </dependency>
    <dependency>
        <groupId>io.projectreactor</groupId>
        <artifactId>reactor-test</artifactId>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>org.junit.jupiter</groupId>
        <artifactId>junit-jupiter-engine</artifactId>
        <version>${junit.version}</version>
        <scope>test</scope>
    </dependency>
</dependencies>
````

## Redisson Client

Creamos la clase `RedissonConfig` con la configuraci√≥n manual del `cliente Redisson`, utilizada para conectarse a una
instancia local de `Redis`. Dado que a√∫n no estamos usando `Spring Boot`, aqu√≠ se hace la configuraci√≥n `"a mano"`,
lo cual es √∫til para entender c√≥mo funciona internamente `Redisson`.

````java
public class RedissonConfig {

    private RedissonClient redissonClient;

    public RedissonClient getClient() {
        if (Objects.isNull(this.redissonClient)) {
            Config config = new Config();
            config.useSingleServer()
                    .setAddress("redis://127.0.0.1:6379");
            this.redissonClient = Redisson.create(config);
        }
        return this.redissonClient;
    }

    public RedissonReactiveClient getReactiveClient() {
        return this.getClient().reactive();
    }
}
````

- Campo `private RedissonClient redissonClient`
    - Se declara una instancia privada de tipo `RedissonClient`, la cual es el cliente principal que usaremos para
      interactuar con `Redis`.
    - Esta instancia se inicializa perezosamente (`lazy initialization`), es decir, solo se crea cuando realmente se
      necesita.


- M√©todo `getClient()`. Este m√©todo devuelve una instancia de `RedissonClient`. Su l√≥gica es:
    - Si `redissonClient` a√∫n no ha sido creado, lo inicializa:
        - Se crea una instancia de `Config`, que contiene la configuraci√≥n de `Redisson`.
        - Se utiliza el modo de `servidor √∫nico` (`useSingleServer()`) porque estamos conect√°ndonos a un `Redis local`.
        - La direcci√≥n se define como `redis://127.0.0.1:6379`, que es el puerto por defecto de `Redis` en `localhost`.
    - Se crea el cliente con `Redisson.create(config)`.
    - Finalmente, se retorna el cliente (`redissonClient`). Este patr√≥n de inicializaci√≥n evita que se creen m√∫ltiples
      instancias del cliente, lo cual es importante para conservar conexiones y evitar errores.


- M√©todo `getReactiveClient()`. Este m√©todo devuelve una instancia de `RedissonReactiveClient`, que permite trabajar de
  `forma reactiva con Redis`:
    - Internamente, `Redisson` tiene soporte tanto para un `cliente imperativo (RedissonClient)` como para uno
      `reactivo (RedissonReactiveClient)`.
    - Este m√©todo simplemente obtiene el cliente imperativo y devuelve su versi√≥n reactiva.
    - Este `cliente reactivo` es compatible con `Project Reactor` (`Mono`, `Flux`), por lo que ser√° √∫til cuando
      trabajemos con `Spring WebFlux`.

### ‚úÖ Ventajas de esta clase

- Separa claramente la configuraci√≥n de Redisson.
- Permite reutilizar el cliente sin crear nuevas conexiones innecesarias.
- Facilita el acceso tanto al cliente imperativo como al reactivo.
- Es un buen ejercicio para comprender la configuraci√≥n sin depender de Spring Boot.

### ‚ö†Ô∏è Observaciones importantes

- Esta clase `no es thread-safe` si la vas a usar en entornos concurrentes. Aunque funciona bien en pruebas simples, en
  producci√≥n deber√≠as garantizar que el cliente se cree una sola vez de manera segura (por ejemplo, usando un
  `singleton` adecuado o `synchronized` si no usas Spring).
- En entornos reales con m√∫ltiples nodos Redis o cl√∫steres, se usar√≠a otra variante de configuraci√≥n como
  `useClusterServers()`, `useSentinelServers()`, etc.
- Cuando se pase a Spring Boot, esta configuraci√≥n se podr√° reemplazar por Beans gestionados por el contenedor,
  aprovechando inyecci√≥n de dependencias y configuraci√≥n centralizada.

### üìù Resumen

| M√©todo                | Descripci√≥n                                                                                                         |
|-----------------------|---------------------------------------------------------------------------------------------------------------------|
| `getClient()`         | Retorna una instancia √∫nica de `RedissonClient`, conectada a Redis local (`localhost:6379`). Si no existe, la crea. |
| `getReactiveClient()` | Retorna una instancia de `RedissonReactiveClient`, √∫til para programaci√≥n reactiva con `Mono` y `Flux`.             |

