# Secci√≥n 04: Redisson - Curso Intensivo

---

## Introducci√≥n: Librer√≠as de Redis para Java

Cuando trabajamos con `Redis` desde aplicaciones `Java`, existen varias bibliotecas cliente disponibles. Las m√°s
destacadas son: `Jedis`, `Lettuce` y `Redisson`. A continuaci√≥n, se presenta un resumen comparativo de sus principales
caracter√≠sticas.

### 1. Jedis

- ‚úÖ R√°pido en operaciones b√°sicas.
- ‚ùå No es seguro para m√∫ltiples hilos (thread-unsafe). Cada hilo necesita su propia conexi√≥n.
- ‚ùå No es escalable para entornos modernos concurrentes.
- ‚ùå No soporta programaci√≥n reactiva (reactive-streams).
- ‚ö†Ô∏è Obsoleto para aplicaciones modernas. Aunque sigue siendo funcional, su mantenimiento ha deca√≠do y su enfoque est√°
  desactualizado frente a soluciones m√°s modernas.
- üî• Conclusi√≥n: No se recomienda para nuevos proyectos.

### 2. Lettuce

- ‚úÖ Escalable y seguro para m√∫ltiples hilos (basado en Netty).
- ‚úÖ Compatible con programaci√≥n reactiva (soporta reactive-streams).
- ‚úÖ Compatible con Spring Data Redis.
  > Nota: No existe un ReactiveCrudRepository oficial para Redis, por lo tanto, se suelen usar operaciones reactivas
  personalizadas.
- ‚ö†Ô∏è API de bajo nivel, requiere escribir m√°s c√≥digo para tareas comunes.
- ‚ûï Puede coexistir con Redisson en un mismo proyecto, aunque:
    - En la mayor√≠a de casos, usar ambos no es necesario.
    - Si tu proyecto requiere estructuras avanzadas y abstracciones de alto nivel, Redisson suele ser la mejor opci√≥n.

### 3. Redisson

- ‚úÖ Escalable y compatible con programaci√≥n reactiva (reactive-streams).
- ‚úÖ Excelente nivel de abstracci√≥n. Simplifica el uso de estructuras de datos y patrones distribuidos.
- ‚úÖ Compatible con Spring Data Redis.
- ‚úÖ Gran compatibilidad con estructuras de datos de Redis, mejor que Lettuce en muchos casos.
- ‚úÖ Excelente documentaci√≥n y comunidad activa (m√°s de 16k estrellas en GitHub).
- üß† Funcionalidades destacadas:
    - Mapas, colas, listas, locks distribuidos, sem√°foros, contadores at√≥micos, entre otros.
    - Soporte para objetos distribuidos con facilidad.
    - Manejo de cache local + cache Redis (modo h√≠brido).
- üî• Conclusi√≥n: Ideal para quienes desean aprovechar Redis al m√°ximo sin lidiar con los detalles de bajo nivel.

## Recomendaci√≥n general

- Si tu proyecto requiere control detallado, bajo consumo de recursos y ya est√°s usando Spring Data Redis, puedes optar
  por Lettuce.
- Si necesitas una API de alto nivel con m√∫ltiples abstracciones listas para usar, lo m√°s conveniente es usar Redisson.
- Evita Jedis en nuevos desarrollos, a menos que tengas una raz√≥n muy espec√≠fica para ello.

## Configuraci√≥n del proyecto Java Maven

En este apartado crearemos un proyecto solo con `Java Maven` con nuestro `IntelliJ IDEA`. Luego, en el `pom.xml`
generalo le agregaremos
[las dependencias que nos proporcion√≥ el tutor](https://github.com/vinsguru/redis-webflux/blob/master/redisson-playground/pom.xml).

Este proyecto llamado `redisson-playground` nos servir√° para ir jugando con `Redission`, es decir ver c√≥mo es que
funciona e ir introduci√©ndonos en el uso de esa librer√≠a.

````xml
<!--maven.compiler.source 21-->
<!--maven.compiler.target 21-->
<!--project.build.sourceEncoding-->
<!--redisson.version 3.47.0-->
<!--lombok.version 1.18.36-->
<!--junit.version 5.11.3-->
<dependencies>
    <dependency>
        <groupId>org.redisson</groupId>
        <artifactId>redisson</artifactId>
        <version>${redisson.version}</version>
    </dependency>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <version>${lombok.version}</version>
        <scope>provided</scope>
    </dependency>
    <dependency>
        <groupId>io.projectreactor</groupId>
        <artifactId>reactor-test</artifactId>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>org.junit.jupiter</groupId>
        <artifactId>junit-jupiter-engine</artifactId>
        <version>${junit.version}</version>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>ch.qos.logback</groupId>
        <artifactId>logback-classic</artifactId>
        <version>1.5.18</version>
    </dependency>
</dependencies>
````

## Redisson Client

Creamos la clase `RedissonConfig` con la configuraci√≥n manual del `cliente Redisson`, utilizada para conectarse a una
instancia local de `Redis`. Dado que a√∫n no estamos usando `Spring Boot`, aqu√≠ se hace la configuraci√≥n `"a mano"`,
lo cual es √∫til para entender c√≥mo funciona internamente `Redisson`.

````java
public class RedissonConfig {

    private RedissonClient redissonClient;

    public RedissonClient getClient() {
        if (Objects.isNull(this.redissonClient)) {
            Config config = new Config();
            config.useSingleServer()
                    .setAddress("redis://127.0.0.1:6379");
            this.redissonClient = Redisson.create(config);
        }
        return this.redissonClient;
    }

    public RedissonReactiveClient getReactiveClient() {
        return this.getClient().reactive();
    }
}
````

- Campo `private RedissonClient redissonClient`
    - Se declara una instancia privada de tipo `RedissonClient`, la cual es el cliente principal que usaremos para
      interactuar con `Redis`.
    - Esta instancia se inicializa perezosamente (`lazy initialization`), es decir, solo se crea cuando realmente se
      necesita.


- M√©todo `getClient()`. Este m√©todo devuelve una instancia de `RedissonClient`. Su l√≥gica es:
    - Si `redissonClient` a√∫n no ha sido creado, lo inicializa:
        - Se crea una instancia de `Config`, que contiene la configuraci√≥n de `Redisson`.
        - Se utiliza el modo de `servidor √∫nico` (`useSingleServer()`) porque estamos conect√°ndonos a un `Redis local`.
        - La direcci√≥n se define como `redis://127.0.0.1:6379`, que es el puerto por defecto de `Redis` en `localhost`.
    - Se crea el cliente con `Redisson.create(config)`.
    - Finalmente, se retorna el cliente (`redissonClient`). Este patr√≥n de inicializaci√≥n evita que se creen m√∫ltiples
      instancias del cliente, lo cual es importante para conservar conexiones y evitar errores.


- M√©todo `getReactiveClient()`. Este m√©todo devuelve una instancia de `RedissonReactiveClient`, que permite trabajar de
  `forma reactiva con Redis`:
    - Internamente, `Redisson` tiene soporte tanto para un `cliente imperativo (RedissonClient)` como para uno
      `reactivo (RedissonReactiveClient)`.
    - Este m√©todo simplemente obtiene el cliente imperativo y devuelve su versi√≥n reactiva.
    - Este `cliente reactivo` es compatible con `Project Reactor` (`Mono`, `Flux`), por lo que ser√° √∫til cuando
      trabajemos con `Spring WebFlux`.

### ‚úÖ Ventajas de esta clase

- Separa claramente la configuraci√≥n de Redisson.
- Permite reutilizar el cliente sin crear nuevas conexiones innecesarias.
- Facilita el acceso tanto al cliente imperativo como al reactivo.
- Es un buen ejercicio para comprender la configuraci√≥n sin depender de Spring Boot.

### ‚ö†Ô∏è Observaciones importantes

- Esta clase `no es thread-safe` si la vas a usar en entornos concurrentes. Aunque funciona bien en pruebas simples, en
  producci√≥n deber√≠as garantizar que el cliente se cree una sola vez de manera segura (por ejemplo, usando un
  `singleton` adecuado o `synchronized` si no usas Spring).
- En entornos reales con m√∫ltiples nodos Redis o cl√∫steres, se usar√≠a otra variante de configuraci√≥n como
  `useClusterServers()`, `useSentinelServers()`, etc.
- Cuando se pase a Spring Boot, esta configuraci√≥n se podr√° reemplazar por Beans gestionados por el contenedor,
  aprovechando inyecci√≥n de dependencias y configuraci√≥n centralizada.

### üìù Resumen

| M√©todo                | Descripci√≥n                                                                                                         |
|-----------------------|---------------------------------------------------------------------------------------------------------------------|
| `getClient()`         | Retorna una instancia √∫nica de `RedissonClient`, conectada a Redis local (`localhost:6379`). Si no existe, la crea. |
| `getReactiveClient()` | Retorna una instancia de `RedissonReactiveClient`, √∫til para programaci√≥n reactiva con `Mono` y `Flux`.             |

## Base Test

Creamos una clase llamada `BaseTest` que ser√° una clase abstracta de configuraci√≥n com√∫n para todas las pruebas que
usen `Redisson`. Su objetivo es centralizar la l√≥gica de creaci√≥n y liberaci√≥n del `cliente Redisson reactivo`
(`RedissonReactiveClient`), evitando repetir este c√≥digo en cada clase de prueba.

````java

@TestInstance(TestInstance.Lifecycle.PER_CLASS)
public abstract class BaseTest {

    private final RedissonConfig redissonConfig = new RedissonConfig();
    protected RedissonReactiveClient client;

    @BeforeAll
    void beforeAll() {
        this.client = this.redissonConfig.getReactiveClient();
    }

    @AfterAll
    void afterAll() {
        this.redissonConfig.getClient().shutdown();
    }

    protected void sleep(long millis) {
        try {
            Thread.sleep(millis);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
````

- `@TestInstance(TestInstance.Lifecycle.PER_CLASS)`
    - Por defecto, `JUnit 5` crea una nueva instancia de la clase de prueba por cada m√©todo de prueba. Eso implica que
      los m√©todos `@BeforeAll` y `@AfterAll` deben ser est√°ticos (`static`), ya que se ejecutan
      `antes y despu√©s de todos los tests`.
    - Al declarar esta anotaci√≥n con `PER_CLASS`, `JUnit` usa una √∫nica instancia de la clase de prueba para todos los
      m√©todos, lo que permite que `@BeforeAll` y `@AfterAll` sean m√©todos de instancia (`no est√°ticos`).
  > ‚úÖ Esto es √∫til cuando necesitas acceder a campos no est√°ticos o cuando prefieres una estructura m√°s orientada a
  objetos.

- Campo `private final RedissonConfig redissonConfig`
    - Se crea una instancia de `RedissonConfig`, que es la clase previamente definida donde configuramos el cliente
      `Redisson` (`imperativo` y `reactivo`).
    - Esta instancia se usa para obtener el cliente reactivo.


- Campo `protected RedissonReactiveClient client`
    - Se define como protected para que est√© accesible directamente desde cualquier clase que extienda de `BaseTest`.
    - Aqu√≠ se almacena el `cliente reactivo de Redisson`, que ser√° usado en los tests para interactuar con Redis.


- M√©todo anotado con `@BeforeAll`
    - Se ejecuta una sola vez antes de todos los tests de la clase hija.
    - Inicializa el cliente Redisson reactivo.


- M√©todo anotado con `@AfterAll`
    - Se ejecuta una sola vez despu√©s de que todos los tests han finalizado.
    - Cierra correctamente el cliente Redisson.
  > ‚ö†Ô∏è Es importante liberar los recursos, ya que el cliente mantiene conexiones abiertas al servidor Redis. No
  cerrarlas puede provocar bloqueos o errores en pruebas posteriores.

### ‚úÖ Ventajas de esta clase

- Evita duplicaci√≥n de c√≥digo en las clases de prueba.
- Permite inicializar y limpiar el cliente Redisson de manera centralizada.
- Facilita que las clases hijas solo se concentren en escribir las pruebas.
- Mejora la mantenibilidad del proyecto de pruebas.

### üìù Resumen

| Elemento                        | Prop√≥sito                                                         |
|---------------------------------|-------------------------------------------------------------------|
| `@TestInstance(PER_CLASS)`      | Permite que `@BeforeAll` y `@AfterAll` sean m√©todos de instancia. |
| `BaseTest`                      | Clase abstracta base para compartir configuraci√≥n entre tests.    |
| `RedissonReactiveClient client` | Cliente reactivo compartido en todas las pruebas.                 |
| `beforeAll()`                   | Inicializa el cliente una vez al iniciar la suite de tests.       |
| `afterAll()`                    | Cierra el cliente despu√©s de ejecutar todos los tests.            |

## üß™ Key Value

Este apartado demuestra c√≥mo usar `Redisson` de forma reactiva para trabajar con claves y valores simples, utilizando
la estructura de datos Redis llamada String.

`Redisson` proporciona la interfaz `RBucketReactive<T>` para manejar este tipo de operaciones.

````java

@Slf4j
class Lec01KeyValueTest extends BaseTest {

    @Test
    void keyValueAccessTest() {
        RBucketReactive<String> bucket = this.client.getBucket("user:1:name");
        Mono<Void> set = bucket.set("sam");
        Mono<Void> get = bucket.get()
                .doOnNext(s -> log.info("{}", s))
                .then();

        StepVerifier.create(set.concatWith(get))
                .verifyComplete();
    }
}
````

- `RBucketReactive<String> bucket = this.client.getBucket("user:1:name")`;
    - Se obtiene una instancia de `RBucketReactive`, que representa una clave tipo string en Redis (estructura String).
    - El nombre de la clave es `user:1:name`.
    - Se especifica que el valor ser√° de tipo String.

      > üí° Redis no tiene tipos fuertes, pero `Redisson` s√≠ permite trabajar con tipos gen√©ricos en Java para mayor
      seguridad.


- `Mono<Void> set = bucket.set("sam")`
    - Se prepara una operaci√≥n reactiva para asignar el valor `"sam"` a la clave `user:1:name`.
    - No se ejecuta a√∫n: recuerda que en programaci√≥n reactiva, nada se ejecuta hasta que alguien lo suscribe (en este
      caso, `StepVerifier` lo hace).


- `Mono<Void> get = bucket.get()...`
    - Se prepara una operaci√≥n reactiva para obtener el valor de la clave `user:1:name`.
    - Se usa `doOnNext(...)` para loggear el valor recuperado (`sam`).
    - Luego se encadena con `.then()` para convertir el flujo en `Mono<Void>`, indicando que no nos interesa devolver
      el valor, solo esperar que termine.


- `StepVerifier.create(set.concatWith(get)).verifyComplete()`
    - Se combinan ambas operaciones (`set` seguido de `get`) usando `concatWith(...)`.
    - `StepVerifier` ejecuta el flujo reactivo y verifica que ambas operaciones se completen sin error.
    - Si algo falla (por ejemplo, Redis no est√° corriendo), el test falla.

Antes de ejecutar el test verificamos que no hay claves a√∫n en el servidor Redis.

````bash
127.0.0.1:6379> keys *
(empty array) 
````

Procedemos a ejecutar el test. Se imprime el valor `"sam"` desde el log gracias a `doOnNext(...)`.

````bash
12:22:39.961 [redisson-netty-1-6] INFO dev.magadiflo.test.Lec01KeyValueTest -- sam
````

Si volvemos al servidor de redis verificamos que:

- Redis muestra que la clave se ha guardado correctamente.
- El valor aparece codificado `("\x03sa\xed")` porque `Redisson` serializa los valores por defecto usando su propio
  mecanismo binario `(Codec)`, lo cual es totalmente normal.

````bash
127.0.0.1:6379> keys *
1) "user:1:name"
127.0.0.1:6379> get user:1:name
"\x03sa\xed" 
````

### ‚ö†Ô∏è Nota sobre el valor serializado

Por defecto, `Redisson` serializa los objetos usando un `codec` basado en `Kryo` o `Jackson`, lo cual hace que el valor
no se vea como texto plano en `Redis CLI`.

> üí° Si deseas que los valores se guarden como texto plano, puedes cambiar el codec por uno como `StringCodec`, lo
> veremos m√°s adelante.

### üìù Resumen

| Elemento           | Descripci√≥n                                                         |
|--------------------|---------------------------------------------------------------------|
| `RBucketReactive`  | Representa una clave tipo String en Redis.                          |
| `.set("sam")`      | Guarda un valor asociado a la clave.                                |
| `.get()`           | Recupera el valor asociado a la clave.                              |
| `StepVerifier`     | Ejecuta y verifica que el flujo reactivo se complete correctamente. |
| Valor en Redis CLI | Puede aparecer codificado por el codec predeterminado.              |

## [Redisson Codec](https://redisson.pro/docs/data-and-services/data-serialization/)

Un `Codec` es el mecanismo que `Redisson` utiliza para serializar y deserializar los datos que se almacenan en `Redis`.
Por defecto, `Redisson` serializa los objetos en formato binario (por ejemplo, usando `Kryo`), lo cual no es legible
directamente desde la `CLI de Redis`.

Sin embargo, `Redisson` permite usar codecs alternativos, como `StringCodec`, para guardar datos como texto plano.

> üìò Documentaci√≥n
> oficial: [Redisson ‚Äì Data Serialization](https://redisson.pro/docs/data-and-services/data-serialization/)

````java

@Slf4j
class Lec01KeyValueTest extends BaseTest {
    @Test
    void keyValueAccessTestStringCodec() {
        RBucketReactive<String> bucket = this.client.getBucket("user:1:name", StringCodec.INSTANCE);
        Mono<Void> set = bucket.set("sam");
        Mono<Void> get = bucket.get()
                .doOnNext(s -> log.info("{}", s))
                .then();

        StepVerifier.create(set.concatWith(get))
                .verifyComplete();
    }
}
````

`this.client.getBucket("user:1:name", StringCodec.INSTANCE)`

- Se obtiene una instancia de `RBucketReactive`, pero esta vez se especifica el uso de `StringCodec`.
- Esto indica que el valor ser√° serializado y deserializado como texto plano.

> ‚úÖ Esto no solo afecta c√≥mo se lee en Java, sino c√≥mo se guarda en Redis.

### üñ•Ô∏è Resultado del log

Si ejecutamos la prueba anterior, el valor "sam" se imprime correctamente desde Java. Aqu√≠ no hay diferencia con la
prueba anterior, ya que `Redisson` lo deserializa sin problemas en ambos casos.

````bash
12:51:57.328 [redisson-netty-1-6] INFO dev.magadiflo.test.Lec01KeyValueTest -- sam
````

### üì¶ Revisi√≥n en Redis CLI

El cambio lo veremos cuando consultemos directamente en el servidor de redis.

- A diferencia del test anterior, ahora el valor es completamente legible en texto plano.
- Ya no aparece con caracteres binarios extra√±os como `\x03sa\xed`, porque no hay serializaci√≥n binaria: `Redisson`
  simplemente guarda `"sam"` como una cadena.

````bash
127.0.0.1:6379> get user:1:name
"sam"
````

### ‚úÖ ¬øCu√°ndo usar StringCodec?

- Cuando quieres ver los valores de Redis directamente desde CLI o herramientas como RedisInsight.
- Cuando est√°s trabajando con datos simples (String, Integer, etc.) y no necesitas serializar objetos complejos.
- Cuando necesitas que Redis pueda interoperar f√°cilmente con otros lenguajes o herramientas que esperan valores en
  texto plano.

### ‚ö†Ô∏è Consideraciones

- El uso de StringCodec no es adecuado si necesitas guardar objetos Java complejos. Para eso, es mejor usar codecs como
  JsonJacksonCodec, KryoCodec, etc.
- Se puede establecer un codec por objeto individual (como hiciste aqu√≠), o bien definir uno global al crear el cliente
  Redisson.

### üìù Resumen

| Elemento                | Descripci√≥n                                                                   |
|-------------------------|-------------------------------------------------------------------------------|
| `Codec`                 | Define c√≥mo se serializan/deserializan los datos en Redis.                    |
| `StringCodec`           | Guarda y lee los datos como texto plano, √∫til para claves simples y legibles. |
| Diferencia en Redis CLI | Con `StringCodec` ves valores legibles; sin √©l, ver√°s datos binarios.         |
| Aplicaci√≥n pr√°ctica     | Ideal para pruebas, depuraci√≥n y claves simples (`String`).                   |

## Bucket Expiry

`Redis` permite definir un `tiempo de vida (TTL)` para una clave, de modo que expire autom√°ticamente despu√©s de cierto
periodo. Esto es √∫til para escenarios como sesiones temporales, cach√©s, tokens de autenticaci√≥n, etc. En este ejemplo,
vemos c√≥mo aplicar expiraci√≥n a una clave utilizando `Redisson` de forma reactiva con `RBucketReactive`.

### üìå Ejemplo de expiraci√≥n con RBucketReactive

````java

@Test
void keyValueExpiryTest() {
    RBucketReactive<String> bucket = this.client.getBucket("user:1:name", StringCodec.INSTANCE);

    // Establecemos el valor con una expiraci√≥n de 10 segundos
    Mono<Void> set = bucket.set("sam", Duration.ofSeconds(10));

    Mono<Void> get = bucket.get()
            .doOnNext(s -> log.info("{}", s))
            .then();
    StepVerifier.create(set.concatWith(get))
            .verifyComplete();
}
````

### üß™ Resultado en consola Redis CLI

````bash
127.0.0.1:6379> keys *
(empty array)
127.0.0.1:6379> keys *
1) "user:1:name"
127.0.0.1:6379> get user:1:name
"sam"
127.0.0.1:6379> get user:1:name
"sam"
127.0.0.1:6379> get user:1:name
"sam"

# Despu√©s de 10 segundos...
127.0.0.1:6379> get user:1:name
(nil)
127.0.0.1:6379> keys *
(empty array)
````

- El m√©todo `bucket.set(value, Duration)` permite guardar un valor y asignarle una duraci√≥n tras la cual se eliminar√°
  autom√°ticamente.
- En este caso, guardamos `"sam"` bajo la clave `"user:1:name"` con una expiraci√≥n de `10 segundos`.
- La operaci√≥n `bucket.get()` nos permite recuperar el valor antes de que expire. En este ejemplo, se accede a la clave
  varias veces antes de su expiraci√≥n para comprobar que el valor persiste mientras est√© dentro del TTL.
- Una vez transcurridos los 10 segundos, `Redis` elimina autom√°ticamente la clave, lo que se comprueba al recibir
  `(nil)` en el get y ver que la lista de claves queda vac√≠a.

### üìå Ejemplo de extender la expiraci√≥n de una clave

En Redis, adem√°s de definir una expiraci√≥n al momento de crear la clave, tambi√©n es posible modificar o extender su
tiempo de vida posteriormente. Esto es √∫til en escenarios donde una operaci√≥n o interacci√≥n del usuario requiere
"renovar" el TTL de una clave ya existente, como por ejemplo: extender la duraci√≥n de una sesi√≥n activa.

````java

@Test
void keyValueExtendExpiryTest() {
    RBucketReactive<String> bucket = this.client.getBucket("user:1:name", StringCodec.INSTANCE);

    // Guardamos la clave con una expiraci√≥n inicial de 10 segundos
    Mono<Void> set = bucket.set("sam", Duration.ofSeconds(10));
    Mono<Void> get = bucket.get()
            .doOnNext(s -> log.info("{}", s))
            .then();
    StepVerifier.create(set.concatWith(get))
            .verifyComplete();

    // Esperamos 5 segundos antes de extender la expiraci√≥n
    this.sleep(5000);

    // Extendemos el TTL a 60 segundos desde el momento actual
    Mono<Boolean> mono = bucket.expire(Duration.ofSeconds(60));
    StepVerifier.create(mono)
            .expectNext(true)
            .verifyComplete();
}
````

### üß™ Resultado en consola Redis CLI

````bash
127.0.0.1:6379> keys *
(empty array)
127.0.0.1:6379> keys *
1) "user:1:name"
127.0.0.1:6379> ttl user:1:name
(integer) 6
127.0.0.1:6379> ttl user:1:name
(integer) 56
127.0.0.1:6379> ttl user:1:name
(integer) 52
127.0.0.1:6379> 
````

- Se define una clave `user:1:name` con un `TTL inicial` de `10 segundos`.
- Luego de 5 segundos (`sleep(5000)`), el tiempo restante es de aproximadamente 5 segundos.
- Al ejecutar `bucket.expire(Duration.ofSeconds(60))`, el `TTL se reinicia` y pasa a ser de `60 segundos` desde ese
  momento.
- El m√©todo `expire(...)` devuelve un `Mono<Boolean>`:
    - `true` si la operaci√≥n fue exitosa y la expiraci√≥n fue aplicada.
    - `false` si la clave no existe o no se pudo modificar el TTL.
- Se puede verificar la expiraci√≥n de una clave desde `Redis CLI` con el comando `TTL <key>`, que devuelve el tiempo
  restante en segundos.

### üìå Ejemplo al tiempo de expiraci√≥n

Una vez que una clave tiene un TTL asignado, Redis (y por extensi√≥n, Redisson) permite consultar cu√°nto tiempo le queda
antes de expirar. Esto puede ser √∫til para prop√≥sitos de observabilidad, control de sesiones, m√©tricas o l√≥gica
condicional basada en la proximidad de expiraci√≥n.

````java

@Test
void keyValueExtendExpiryTest() {
    RBucketReactive<String> bucket = this.client.getBucket("user:1:name", StringCodec.INSTANCE);
    Mono<Void> set = bucket.set("sam", Duration.ofSeconds(10));
    Mono<Void> get = bucket.get()
            .doOnNext(s -> log.info("{}", s))
            .then();
    StepVerifier.create(set.concatWith(get))
            .verifyComplete();

    // extendiendo el tiempo de vida
    this.sleep(5000);
    Mono<Boolean> mono = bucket.expire(Duration.ofSeconds(60));
    StepVerifier.create(mono)
            .expectNext(true)
            .verifyComplete();

    // Consultamos el tiempo restante antes de que expire
    Mono<Void> ttl = bucket.remainTimeToLive()
            .doOnNext(time -> log.info("{}", time))
            .then();
    StepVerifier.create(ttl)
            .verifyComplete();
}
````

### üß™ Resultado en logs

````bash
10:51:01.147 [redisson-netty-1-10] INFO dev.magadiflo.test.Lec01KeyValueTest -- 59997
````

- El m√©todo `bucket.remainTimeToLive()` devuelve un `Mono<Long>` que representa el `tiempo restante en milisegundos`
  antes de que la clave expire.
- En este caso, como el TTL fue extendido a 60 segundos y se consulta inmediatamente despu√©s, el valor mostrado es
  cercano a 60,000 ms.
- Este valor puede ser √∫til para:
    - Mostrarle al usuario cu√°nto tiempo le queda en su sesi√≥n.
    - Decidir si renovar o invalidar una clave.
    - Registrar m√©tricas para alertas o dashboards.
