# Secci√≥n 05: Spring WebFlux Caching

---

## Introducci√≥n

En esta secci√≥n aprenderemos a integrar `Spring WebFlux` con `Redis` para implementar mecanismos de `cach√©` de manera
reactiva. Antes de entrar al c√≥digo, analizaremos el `caso de uso principal` que resolveremos mediante caching.

## Caso de uso 1: Caching

El uso de cach√© con Redis puede aportar beneficios significativos al rendimiento de una aplicaci√≥n reactiva. Entre los
motivos m√°s comunes para aplicar caching, destacan los siguientes:

- `Reducir la carga en la base de datos`. Evita ejecutar m√∫ltiples veces la misma consulta, al almacenar temporalmente
  los resultados.


- `Disminuir el n√∫mero de llamadas de red`. Las respuestas de servicios externos (como APIs REST) pueden almacenarse
  para reducir latencia y dependencia.


- `Evitar la repetici√≥n de tareas costosas`. Resultados de operaciones complejas (como c√°lculos o agregaciones
  intensivas) pueden ser almacenados para su reutilizaci√≥n.


- `Mejorar el rendimiento general`. Al servir respuestas desde memoria en lugar de fuentes lentas como una base de
  datos, se incrementa la velocidad de respuesta.


- `Optimizar la experiencia del usuario`. Menor tiempo de espera y mayor fluidez en la interacci√≥n con la aplicaci√≥n.

## Proyecto: `redis-spring` - Dependencias iniciales

````xml
<!--Spring Boot 3.5.4-->
<!--Java 21-->
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-redis-reactive</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-webflux</artifactId>
    </dependency>

    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>io.projectreactor</groupId>
        <artifactId>reactor-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
````

## ¬øQu√© son Spring Data Redis y Redisson?

### Spring Data Redis

`Spring Data Redis` es un m√≥dulo del ecosistema `Spring Data` que permite interactuar f√°cilmente con `Redis` desde
aplicaciones Spring Boot, tanto en modo `imperativo` como `reactivo`.

Este m√≥dulo no es un cliente en s√≠ mismo, sino una abstracci√≥n que se apoya en clientes Redis de bajo nivel como:

- `Lettuce` (por defecto desde `Spring Boot 2.x`): Cliente no bloqueante y compatible con programaci√≥n reactiva
  (basado en Netty).
- `Jedis`: Cliente m√°s antiguo, basado en IO bloqueante.

Caracter√≠sticas principales:

- Integraci√≥n nativa con Spring Boot (auto-configuraci√≥n, plantillas, soporte de repositorios, etc.)
- Soporte para operaciones simples de clave-valor, estructuras de datos (hashes, sets, listas, etc.)
- Soporte reactivo mediante clases como `ReactiveRedisTemplate`
- Utiliza las mismas convenciones del ecosistema `Spring` (inyecci√≥n de dependencias, `@EnableRedisRepositories`, etc.)

üî∏ Ideal para tareas sencillas de cacheo, contadores, sesiones, y almacenamiento b√°sico.

### Redisson

`Redisson` es un cliente Java para `Redis` completamente independiente, que implementa muchas estructuras y mecanismos
distribuidos avanzados sobre `Redis`.

A diferencia de `Spring Data Redis`, `Redisson` no necesita `Spring` para funcionar, aunque se integra bien con √©l.

Caracter√≠sticas destacadas:

- Compatible con modo s√≠ncrono, as√≠ncrono, reactivo y corutinas (Kotlin)
- Amplio soporte para estructuras de datos distribuidas:
    - `RMap`, `RList`, `RSet`, `RQueue`, `RLock`, `RSemaphore`, `RTopic`, `RRateLimiter`, etc.
- Implementaci√≥n propia sobre Redis, muy optimizada para concurrencia
- Soporte para operaciones at√≥micas, transaccionales y locks distribuidos

üî∏ Ideal para aplicaciones distribuidas o de alta concurrencia, donde se requiere m√°s que simples operaciones
CRUD sobre Redis.

## Prueba con Spring Data Redis (Reactivo)

````java

@Slf4j
@SpringBootTest
class RedisSpringApplicationTests {

    @Autowired
    private ReactiveStringRedisTemplate template;

    @RepeatedTest(3)
    void springDataRedisTest(RepetitionInfo info) {
        ReactiveValueOperations<String, String> valueOperations = this.template.opsForValue();

        //¬øCu√°nto tiempo se tarja en ejecutar este bloque?
        long before = System.currentTimeMillis();

        Mono<Void> mono = Flux.range(1, 500_000)
                .flatMap(i -> valueOperations.increment("user:1:visit"))
                .then();
        StepVerifier.create(mono)
                .verifyComplete();

        long after = System.currentTimeMillis();
        log.info("Repetition: {}/{} - Total time: {}ms", info.getCurrentRepetition(), info.getTotalRepetitions(), (after - before));
    }
}
````

**D√≥nde**

- Inyectamos un bean de tipo `ReactiveStringRedisTemplate`, una clase proporcionada por `Spring Data Redis` que nos
  permite realizar operaciones reactivas sobre Redis con claves y valores tipo String.
- Esta plantilla se basa en `Lettuce` como cliente por debajo y en el modelo `Reactor` para programaci√≥n no bloqueante.
- `RepetitionInfo` es un `par√°metro que se inyecta autom√°ticamente` por `JUnit 5` cuando se usa la anotaci√≥n
  `@RepeatedTest`. Este objeto proporciona informaci√≥n sobre la iteraci√≥n actual de la prueba que se est√° repitiendo.
- A trav√©s del m√©todo `opsForValue()` obtenemos un componente que permite realizar operaciones espec√≠ficas sobre
  `valores simples (tipo String)` en Redis.
- Este componente reactivo (`ReactiveValueOperations`) expone m√©todos como `get()`, `set()`, `increment()`, etc.
- Generamos un `Flux` de 500,000 elementos (del 1 al 500,000).
- Por cada elemento, se ejecuta una operaci√≥n `increment()` sobre la clave `user:1:visit`.
    - Redis incrementar√° el valor almacenado (inicialmente nulo o 0).
- El m√©todo `.then()` transforma el `Flux` en un `Mono<Void>`, indicando que solo nos interesa saber cu√°ndo la ejecuci√≥n
  haya finalizado.

> üîç `Nota`: Utilizamos `@RepeatedTest(3)` para ejecutar la prueba tres veces consecutivas. En general,
> la `primera ejecuci√≥n suele ser m√°s lenta` debido a la inicializaci√≥n del contexto o calentamiento de JIT. Las
> siguientes repeticiones nos dan una medici√≥n m√°s representativa del rendimiento sostenido.

Observemos la consola del ide el siguiente resultado.

````bash
2025-07-28T12:52:22.207-05:00  INFO 18504 --- [redis-spring] [           main] d.m.r.RedisSpringApplicationTests        : Repetition: 1/3 - Total time: 24748ms
2025-07-28T12:52:44.938-05:00  INFO 18504 --- [redis-spring] [           main] d.m.r.RedisSpringApplicationTests        : Repetition: 2/3 - Total time: 22709ms
2025-07-28T12:53:07.188-05:00  INFO 18504 --- [redis-spring] [           main] d.m.r.RedisSpringApplicationTests        : Repetition: 3/3 - Total time: 22244ms
````

> üìù `Nota`: Esta prueba se ejecut√≥ con la dependencia `spring-boot-starter-data-redis-reactive`, por lo tanto
> `ReactiveStringRedisTemplate` us√≥ internamente el cliente `Lettuce`. M√°s adelante, al cambiar la configuraci√≥n
> para usar `Redisson`, este comportamiento se modificar√° autom√°ticamente.

## Modifica dependencias para trabajar con Redisson

Para evaluar el rendimiento de `Redisson` en lugar de `Spring Data Redis`, realizamos algunos cambios en las
dependencias y ejecutamos pruebas equivalentes.

Primero, reemplazamos la dependencia de `spring-boot-starter-data-redis-reactive` por `redisson-spring-boot-starter`.

````xml

<dependencies>
    <!--
      No es necesario incluir 'spring-boot-starter-data-redis-reactive',
      ya que 'redisson-spring-boot-starter' provee 'spring-boot-starter-data-redis' (modo bloqueante)
      y 'spring-boot-starter-webflux' habilita el entorno reactivo.
  
      Spring Boot detectar√° autom√°ticamente 'RedissonConnectionFactory' como la implementaci√≥n
      de 'ReactiveRedisConnectionFactory', permitiendo el uso de ReactiveStringRedisTemplate
      sin necesidad del cliente Lettuce.
  -->
    <!--
      <dependency>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-starter-data-redis-reactive</artifactId>
      </dependency>
    -->

    <!-- Dependencia activa: Redisson Starter -->
    <dependency>
        <groupId>org.redisson</groupId>
        <artifactId>redisson-spring-boot-starter</artifactId>
        <version>3.50.0</version>
        <exclusions>
            <!-- Excluimos dependencias innecesarias para evitar conflictos -->
            <exclusion>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-web</artifactId>
            </exclusion>
            <exclusion>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-aop</artifactId>
            </exclusion>
        </exclusions>
    </dependency>
</dependencies>
````

En este proyecto, no es necesario incluir la dependencia `spring-boot-starter-data-redis-reactive`, ya que:

- `redisson-spring-boot-starter` incluye `spring-boot-starter-data-redis` (modo bloqueante).
- `spring-boot-starter-webflux` habilita el entorno reactivo.
- `Spring Boot` detecta autom√°ticamente la clase `RedissonConnectionFactory` (proporcionada por `Redisson`) y la
  utiliza como implementaci√≥n de `ReactiveRedisConnectionFactory`.

Esto permite que `ReactiveStringRedisTemplate` funcione correctamente sin necesidad de `Lettuce` ni de la dependencia
`spring-boot-starter-data-redis-reactive`.

‚úÖ Esto ha sido verificado personalmente en un test que imprime el tipo de conexi√≥n, arrojando:

````bash
Connection Factory class: org.redisson.spring.data.connection.RedissonConnectionFactory 
````

Por lo tanto, si volvemos a ejecutar el c√≥digo anterior, lo cual recordamos a continuaci√≥n:

````java

@Slf4j
@SpringBootTest
class RedisSpringApplicationTests {

    @Autowired
    private ReactiveStringRedisTemplate template;

    @RepeatedTest(3)
    void springDataRedisTest(RepetitionInfo info) {
        ReactiveValueOperations<String, String> valueOperations = this.template.opsForValue();

        //¬øCu√°nto tiempo se tarja en ejecutar este bloque?
        long before = System.currentTimeMillis();

        Mono<Void> mono = Flux.range(1, 500_000)
                .flatMap(i -> valueOperations.increment("user:1:visit"))
                .then();
        StepVerifier.create(mono)
                .verifyComplete();

        long after = System.currentTimeMillis();
        log.info("Repetition: {}/{} - Total time: {}ms", info.getCurrentRepetition(), info.getTotalRepetitions(), (after - before));
    }
}
````

Obtendremos el siguiente resultado en consola. Sin embargo, debemos notar que ya no estamos trabajando con
`Lettuce` (el cliente por defecto en `spring-boot-starter-data-redis-reactive`), sino con la implementaci√≥n
proporcionada por `Redisson`:

````bash
2025-07-28T13:14:33.851-05:00  INFO 7848 --- [redis-spring] [           main] d.m.r.RedisSpringApplicationTests        : Repetition: 1/3 - Total time: 25380ms
2025-07-28T13:14:56.774-05:00  INFO 7848 --- [redis-spring] [           main] d.m.r.RedisSpringApplicationTests        : Repetition: 2/3 - Total time: 22897ms
2025-07-28T13:15:18.841-05:00  INFO 7848 --- [redis-spring] [           main] d.m.r.RedisSpringApplicationTests        : Repetition: 3/3 - Total time: 22060ms 
````

> üìù `Nota importante`: Aunque el c√≥digo de prueba no ha cambiado, el cliente subyacente s√≠ lo ha hecho. Al eliminar
> la dependencia `spring-boot-starter-data-redis-reactive` y utilizar en su lugar `redisson-spring-boot-starter`,
> el bean `ReactiveStringRedisTemplate` ya no utiliza `Lettuce` (como era por defecto), sino que es respaldado por
> `RedissonConnectionFactory`.
>
> Este cambio ocurre autom√°ticamente gracias a la autoconfiguraci√≥n de `Spring Boot`, que detecta la nueva
> `ConnectionFactory` proporcionada por `Redisson` y la aplica a todos los componentes dependientes, incluyendo
> `ReactiveStringRedisTemplate`.

‚úÖ Este resultado servir√° como punto de comparaci√≥n frente al uso de la API `RedissonReactiveClient`, que veremos a
continuaci√≥n. Aunque ambos enfoques utilizan internamente `Redisson` como cliente, aqu√≠ estamos contrastando el
rendimiento entre dos formas distintas de interactuar con `Redis` de forma reactiva.

## Prueba con Redisson (Reactivo)

Creamos un nuevo test utilizando el cliente reactivo de Redisson `RedissonReactiveClient`.

````java

@Slf4j
@SpringBootTest
class RedisSpringApplicationTests {

    @Autowired
    private RedissonReactiveClient client;

    @RepeatedTest(3)
    void redissonTest(RepetitionInfo info) {
        RAtomicLongReactive atomicLong = this.client.getAtomicLong("user:2:visit");

        //¬øCu√°nto tiempo se tarja en ejecutar este bloque?
        long before = System.currentTimeMillis();
        Mono<Void> mono = Flux.range(1, 500_000)
                .flatMap(i -> atomicLong.incrementAndGet())
                .then();
        StepVerifier.create(mono)
                .verifyComplete();
        long after = System.currentTimeMillis();
        log.info("Repetition= {}/{} - Total time= {}ms", info.getCurrentRepetition(), info.getTotalRepetitions(), (after - before));
    }
}
````

**D√≥nde**

- `RedissonReactiveClient`: Es el cliente reactivo proporcionado por `Redisson`, capaz de acceder a m√∫ltiples
  estructuras distribuidas.
- `client.getAtomicLong("user:2:visit")`: Devuelve un objeto `RAtomicLongReactive`, que representa un contador de tipo
  long almacenado en Redis.
- `.incrementAndGet()`: Incrementa el valor actual y devuelve el nuevo valor, de forma reactiva.
- Igual que antes, generamos `500,000` operaciones de incremento con `Flux.range(...).flatMap(...)`.

> ‚òëÔ∏è El uso de `StepVerifier` garantiza que el flujo se complete correctamente, y medimos el tiempo total de ejecuci√≥n
> usando `System.currentTimeMillis()`.

Ejecutamos 3 veces el test y vemos en consola el siguiente resultado

````bash
2025-07-28T13:21:38.355-05:00  INFO 12164 --- [redis-spring] [           main] d.m.r.RedisSpringApplicationTests        : Repetition= 1/3 - Total time= 23836ms
2025-07-28T13:21:58.538-05:00  INFO 12164 --- [redis-spring] [           main] d.m.r.RedisSpringApplicationTests        : Repetition= 2/3 - Total time= 20162ms
2025-07-28T13:22:18.903-05:00  INFO 12164 --- [redis-spring] [           main] d.m.r.RedisSpringApplicationTests        : Repetition= 3/3 - Total time= 20359ms
````

> üìä Aunque no es una diferencia abismal, la API `RedissonReactiveClient` mostr√≥ mejores tiempos promedio en las
> repeticiones 2 y 3, que son las m√°s representativas.
>
> Esto sugiere que, para operaciones masivas como incrementos secuenciales, la API nativa de Redisson puede ofrecer un
> rendimiento ligeramente superior respecto a `ReactiveStringRedisTemplate`, aun cuando ambas comparten el mismo cliente
> subyacente (`Redisson`)

## Conclusi√≥n

Con base en las pruebas realizadas:

- La API `ReactiveStringRedisTemplate` (parte de `Spring Data Redis`) present√≥ tiempos de ejecuci√≥n ligeramente
  superiores (es decir, m√°s lentos).
    - Esto se mantuvo tanto cuando utiliz√≥ `Lettuce` como cliente (al inicio), como cuando pas√≥ a usar `Redisson` como
      backend (tras modificar las dependencias). Es decir, el menor rendimiento est√° asociado al enfoque de la API, no
      solo al cliente.
- No ofrece integraci√≥n directa con `ReactiveCrudRepository`, lo que limita su uso como repositorio reactivo
  completo en aplicaciones Spring.
- La API `RedissonReactiveClient` mostr√≥ un leve mejor rendimiento en operaciones intensivas como incrementos, y
  adem√°s proporciona un conjunto m√°s amplio de estructuras distribuidas y primitivas reactivas (colas, locks, maps,
  etc.).

> üí° Para aplicaciones reactivas que requieren mayor rendimiento, concurrencia distribuida o estructuras de datos
> avanzadas, `Redisson` representa una alternativa m√°s robusta, flexible y lista para escenarios exigentes.

### ‚úÖ Spring Boot 3.5.4 + Java 21

Con las √∫ltimas versiones de Spring y Java:

- `Spring Data Redis` (basado en `Lettuce`) ha mejorado en compatibilidad con `Reactor 3.6+`, y tambi√©n tiene mejor
  gesti√≥n de conexiones.
- Sin embargo, `Redisson` a√∫n es preferido cuando se requieren:
    - Operaciones distribuidas (locks, sem√°foros, etc.)
    - Estructuras de datos complejas (listas, colas, mapas multivalorados, etc.)
    - Un rendimiento m√°s predecible bajo carga intensiva

Por tanto, si bien `Spring Data Redis` es suficiente para tareas simples (como caching, sesiones, contadores),
`Redisson` sigue siendo una opci√≥n m√°s potente y escalable para escenarios m√°s exigentes.
