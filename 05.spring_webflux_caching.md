# Secci√≥n 05: Spring WebFlux Caching

---

## Introducci√≥n

En esta secci√≥n aprenderemos a integrar `Spring WebFlux` con `Redis` para implementar mecanismos de `cach√©` de manera
reactiva. Antes de entrar al c√≥digo, analizaremos el `caso de uso principal` que resolveremos mediante caching.

## Caso de uso 1: Caching

El uso de cach√© con Redis puede aportar beneficios significativos al rendimiento de una aplicaci√≥n reactiva. Entre los
motivos m√°s comunes para aplicar caching, destacan los siguientes:

- `Reducir la carga en la base de datos`. Evita ejecutar m√∫ltiples veces la misma consulta, al almacenar temporalmente
  los resultados.


- `Disminuir el n√∫mero de llamadas de red`. Las respuestas de servicios externos (como APIs REST) pueden almacenarse
  para reducir latencia y dependencia.


- `Evitar la repetici√≥n de tareas costosas`. Resultados de operaciones complejas (como c√°lculos o agregaciones
  intensivas) pueden ser almacenados para su reutilizaci√≥n.


- `Mejorar el rendimiento general`. Al servir respuestas desde memoria en lugar de fuentes lentas como una base de
  datos, se incrementa la velocidad de respuesta.


- `Optimizar la experiencia del usuario`. Menor tiempo de espera y mayor fluidez en la interacci√≥n con la aplicaci√≥n.

## Proyecto: `redis-spring` - Dependencias iniciales

````xml
<!--Spring Boot 3.5.4-->
<!--Java 21-->
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-redis-reactive</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-webflux</artifactId>
    </dependency>

    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>io.projectreactor</groupId>
        <artifactId>reactor-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
````

## ¬øQu√© son Spring Data Redis y Redisson?

### Spring Data Redis

`Spring Data Redis` es un m√≥dulo del ecosistema `Spring Data` que permite interactuar f√°cilmente con `Redis` desde
aplicaciones Spring Boot, tanto en modo `imperativo` como `reactivo`.

Este m√≥dulo no es un cliente en s√≠ mismo, sino una abstracci√≥n que se apoya en clientes Redis de bajo nivel como:

- `Lettuce` (por defecto desde `Spring Boot 2.x`): Cliente no bloqueante y compatible con programaci√≥n reactiva
  (basado en Netty).
- `Jedis`: Cliente m√°s antiguo, basado en IO bloqueante.

Caracter√≠sticas principales:

- Integraci√≥n nativa con Spring Boot (auto-configuraci√≥n, plantillas, soporte de repositorios, etc.)
- Soporte para operaciones simples de clave-valor, estructuras de datos (hashes, sets, listas, etc.)
- Soporte reactivo mediante clases como `ReactiveRedisTemplate`
- Utiliza las mismas convenciones del ecosistema `Spring` (inyecci√≥n de dependencias, `@EnableRedisRepositories`, etc.)

üî∏ Ideal para tareas sencillas de cacheo, contadores, sesiones, y almacenamiento b√°sico.

### Redisson

`Redisson` es un cliente Java para `Redis` completamente independiente, que implementa muchas estructuras y mecanismos
distribuidos avanzados sobre `Redis`.

A diferencia de `Spring Data Redis`, `Redisson` no necesita `Spring` para funcionar, aunque se integra bien con √©l.

Caracter√≠sticas destacadas:

- Compatible con modo s√≠ncrono, as√≠ncrono, reactivo y corutinas (Kotlin)
- Amplio soporte para estructuras de datos distribuidas:
    - `RMap`, `RList`, `RSet`, `RQueue`, `RLock`, `RSemaphore`, `RTopic`, `RRateLimiter`, etc.
- Implementaci√≥n propia sobre Redis, muy optimizada para concurrencia
- Soporte para operaciones at√≥micas, transaccionales y locks distribuidos

üî∏ Ideal para aplicaciones distribuidas o de alta concurrencia, donde se requiere m√°s que simples operaciones
CRUD sobre Redis.

## Prueba con Spring Data Redis (Reactivo)

````java

@Slf4j
@SpringBootTest
class RedisSpringApplicationTests {

    @Autowired
    private ReactiveStringRedisTemplate template;

    @RepeatedTest(3)
    void springDataRedisTest(RepetitionInfo info) {
        ReactiveValueOperations<String, String> valueOperations = this.template.opsForValue();

        //¬øCu√°nto tiempo se tarja en ejecutar este bloque?
        long before = System.currentTimeMillis();

        Mono<Void> mono = Flux.range(1, 500_000)
                .flatMap(i -> valueOperations.increment("user:1:visit"))
                .then();
        StepVerifier.create(mono)
                .verifyComplete();

        long after = System.currentTimeMillis();
        log.info("Repetition: {}/{} - Total time: {}ms", info.getCurrentRepetition(), info.getTotalRepetitions(), (after - before));
    }
}
````

**D√≥nde**

- Inyectamos un bean de tipo `ReactiveStringRedisTemplate`, una clase proporcionada por `Spring Data Redis` que nos
  permite realizar operaciones reactivas sobre Redis con claves y valores tipo String.
- Esta plantilla se basa en `Lettuce` como cliente por debajo y en el modelo `Reactor` para programaci√≥n no bloqueante.
- `RepetitionInfo` es un `par√°metro que se inyecta autom√°ticamente` por `JUnit 5` cuando se usa la anotaci√≥n
  `@RepeatedTest`. Este objeto proporciona informaci√≥n sobre la iteraci√≥n actual de la prueba que se est√° repitiendo.
- A trav√©s del m√©todo `opsForValue()` obtenemos un componente que permite realizar operaciones espec√≠ficas sobre
  `valores simples (tipo String)` en Redis.
- Este componente reactivo (`ReactiveValueOperations`) expone m√©todos como `get()`, `set()`, `increment()`, etc.
- Generamos un `Flux` de 500,000 elementos (del 1 al 500,000).
- Por cada elemento, se ejecuta una operaci√≥n `increment()` sobre la clave `user:1:visit`.
    - Redis incrementar√° el valor almacenado (inicialmente nulo o 0).
- El m√©todo `.then()` transforma el `Flux` en un `Mono<Void>`, indicando que solo nos interesa saber cu√°ndo la ejecuci√≥n
  haya finalizado.

> üîç `Nota`: Utilizamos `@RepeatedTest(3)` para ejecutar la prueba tres veces consecutivas. En general,
> la `primera ejecuci√≥n suele ser m√°s lenta` debido a la inicializaci√≥n del contexto o calentamiento de JIT. Las
> siguientes repeticiones nos dan una medici√≥n m√°s representativa del rendimiento sostenido.

Observemos la consola del ide el siguiente resultado.

````bash
2025-07-28T12:52:22.207-05:00  INFO 18504 --- [redis-spring] [           main] d.m.r.RedisSpringApplicationTests        : Repetition: 1/3 - Total time: 24748ms
2025-07-28T12:52:44.938-05:00  INFO 18504 --- [redis-spring] [           main] d.m.r.RedisSpringApplicationTests        : Repetition: 2/3 - Total time: 22709ms
2025-07-28T12:53:07.188-05:00  INFO 18504 --- [redis-spring] [           main] d.m.r.RedisSpringApplicationTests        : Repetition: 3/3 - Total time: 22244ms
````

> üìù `Nota`: Esta prueba se ejecut√≥ con la dependencia `spring-boot-starter-data-redis-reactive`, por lo tanto
> `ReactiveStringRedisTemplate` us√≥ internamente el cliente `Lettuce`. M√°s adelante, al cambiar la configuraci√≥n
> para usar `Redisson`, este comportamiento se modificar√° autom√°ticamente.

## Modifica dependencias para trabajar con Redisson

Para evaluar el rendimiento de `Redisson` en lugar de `Spring Data Redis`, realizamos algunos cambios en las
dependencias y ejecutamos pruebas equivalentes.

Primero, reemplazamos la dependencia de `spring-boot-starter-data-redis-reactive` por `redisson-spring-boot-starter`.

````xml

<dependencies>
    <!--
      No es necesario incluir 'spring-boot-starter-data-redis-reactive',
      ya que 'redisson-spring-boot-starter' provee 'spring-boot-starter-data-redis' (modo bloqueante)
      y 'spring-boot-starter-webflux' habilita el entorno reactivo.
  
      Spring Boot detectar√° autom√°ticamente 'RedissonConnectionFactory' como la implementaci√≥n
      de 'ReactiveRedisConnectionFactory', permitiendo el uso de ReactiveStringRedisTemplate
      sin necesidad del cliente Lettuce.
  -->
    <!--
      <dependency>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-starter-data-redis-reactive</artifactId>
      </dependency>
    -->

    <!-- Dependencia activa: Redisson Starter -->
    <dependency>
        <groupId>org.redisson</groupId>
        <artifactId>redisson-spring-boot-starter</artifactId>
        <version>3.50.0</version>
        <exclusions>
            <!-- Excluimos dependencias innecesarias para evitar conflictos -->
            <exclusion>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-web</artifactId>
            </exclusion>
            <exclusion>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-aop</artifactId>
            </exclusion>
        </exclusions>
    </dependency>
</dependencies>
````

En este proyecto, no es necesario incluir la dependencia `spring-boot-starter-data-redis-reactive`, ya que:

- `redisson-spring-boot-starter` incluye `spring-boot-starter-data-redis` (modo bloqueante).
- `spring-boot-starter-webflux` habilita el entorno reactivo.
- `Spring Boot` detecta autom√°ticamente la clase `RedissonConnectionFactory` (proporcionada por `Redisson`) y la
  utiliza como implementaci√≥n de `ReactiveRedisConnectionFactory`.

Esto permite que `ReactiveStringRedisTemplate` funcione correctamente sin necesidad de `Lettuce` ni de la dependencia
`spring-boot-starter-data-redis-reactive`.

‚úÖ Esto ha sido verificado personalmente en un test que imprime el tipo de conexi√≥n, arrojando:

````bash
Connection Factory class: org.redisson.spring.data.connection.RedissonConnectionFactory 
````

Por lo tanto, si volvemos a ejecutar el c√≥digo anterior, lo cual recordamos a continuaci√≥n:

````java

@Slf4j
@SpringBootTest
class RedisSpringApplicationTests {

    @Autowired
    private ReactiveStringRedisTemplate template;

    @RepeatedTest(3)
    void springDataRedisTest(RepetitionInfo info) {
        ReactiveValueOperations<String, String> valueOperations = this.template.opsForValue();

        //¬øCu√°nto tiempo se tarja en ejecutar este bloque?
        long before = System.currentTimeMillis();

        Mono<Void> mono = Flux.range(1, 500_000)
                .flatMap(i -> valueOperations.increment("user:1:visit"))
                .then();
        StepVerifier.create(mono)
                .verifyComplete();

        long after = System.currentTimeMillis();
        log.info("Repetition: {}/{} - Total time: {}ms", info.getCurrentRepetition(), info.getTotalRepetitions(), (after - before));
    }
}
````

Obtendremos el siguiente resultado en consola. Sin embargo, debemos notar que ya no estamos trabajando con
`Lettuce` (el cliente por defecto en `spring-boot-starter-data-redis-reactive`), sino con la implementaci√≥n
proporcionada por `Redisson`:

````bash
2025-07-28T13:14:33.851-05:00  INFO 7848 --- [redis-spring] [           main] d.m.r.RedisSpringApplicationTests        : Repetition: 1/3 - Total time: 25380ms
2025-07-28T13:14:56.774-05:00  INFO 7848 --- [redis-spring] [           main] d.m.r.RedisSpringApplicationTests        : Repetition: 2/3 - Total time: 22897ms
2025-07-28T13:15:18.841-05:00  INFO 7848 --- [redis-spring] [           main] d.m.r.RedisSpringApplicationTests        : Repetition: 3/3 - Total time: 22060ms 
````

> üìù `Nota importante`: Aunque el c√≥digo de prueba no ha cambiado, el cliente subyacente s√≠ lo ha hecho. Al eliminar
> la dependencia `spring-boot-starter-data-redis-reactive` y utilizar en su lugar `redisson-spring-boot-starter`,
> el bean `ReactiveStringRedisTemplate` ya no utiliza `Lettuce` (como era por defecto), sino que es respaldado por
> `RedissonConnectionFactory`.
>
> Este cambio ocurre autom√°ticamente gracias a la autoconfiguraci√≥n de `Spring Boot`, que detecta la nueva
> `ConnectionFactory` proporcionada por `Redisson` y la aplica a todos los componentes dependientes, incluyendo
> `ReactiveStringRedisTemplate`.

‚úÖ Este resultado servir√° como punto de comparaci√≥n frente al uso de la API `RedissonReactiveClient`, que veremos a
continuaci√≥n. Aunque ambos enfoques utilizan internamente `Redisson` como cliente, aqu√≠ estamos contrastando el
rendimiento entre dos formas distintas de interactuar con `Redis` de forma reactiva.

## Prueba con Redisson (Reactivo)

Creamos un nuevo test utilizando el cliente reactivo de Redisson `RedissonReactiveClient`.

````java

@Slf4j
@SpringBootTest
class RedisSpringApplicationTests {

    @Autowired
    private RedissonReactiveClient client;

    @RepeatedTest(3)
    void redissonTest(RepetitionInfo info) {
        RAtomicLongReactive atomicLong = this.client.getAtomicLong("user:2:visit");

        //¬øCu√°nto tiempo se tarja en ejecutar este bloque?
        long before = System.currentTimeMillis();
        Mono<Void> mono = Flux.range(1, 500_000)
                .flatMap(i -> atomicLong.incrementAndGet())
                .then();
        StepVerifier.create(mono)
                .verifyComplete();
        long after = System.currentTimeMillis();
        log.info("Repetition= {}/{} - Total time= {}ms", info.getCurrentRepetition(), info.getTotalRepetitions(), (after - before));
    }
}
````

**D√≥nde**

- `RedissonReactiveClient`: Es el cliente reactivo proporcionado por `Redisson`, capaz de acceder a m√∫ltiples
  estructuras distribuidas.
- `client.getAtomicLong("user:2:visit")`: Devuelve un objeto `RAtomicLongReactive`, que representa un contador de tipo
  long almacenado en Redis.
- `.incrementAndGet()`: Incrementa el valor actual y devuelve el nuevo valor, de forma reactiva.
- Igual que antes, generamos `500,000` operaciones de incremento con `Flux.range(...).flatMap(...)`.

> ‚òëÔ∏è El uso de `StepVerifier` garantiza que el flujo se complete correctamente, y medimos el tiempo total de ejecuci√≥n
> usando `System.currentTimeMillis()`.

Ejecutamos 3 veces el test y vemos en consola el siguiente resultado

````bash
2025-07-28T13:21:38.355-05:00  INFO 12164 --- [redis-spring] [           main] d.m.r.RedisSpringApplicationTests        : Repetition= 1/3 - Total time= 23836ms
2025-07-28T13:21:58.538-05:00  INFO 12164 --- [redis-spring] [           main] d.m.r.RedisSpringApplicationTests        : Repetition= 2/3 - Total time= 20162ms
2025-07-28T13:22:18.903-05:00  INFO 12164 --- [redis-spring] [           main] d.m.r.RedisSpringApplicationTests        : Repetition= 3/3 - Total time= 20359ms
````

> üìä Aunque no es una diferencia abismal, la API `RedissonReactiveClient` mostr√≥ mejores tiempos promedio en las
> repeticiones 2 y 3, que son las m√°s representativas.
>
> Esto sugiere que, para operaciones masivas como incrementos secuenciales, la API nativa de Redisson puede ofrecer un
> rendimiento ligeramente superior respecto a `ReactiveStringRedisTemplate`, aun cuando ambas comparten el mismo cliente
> subyacente (`Redisson`)

## Conclusi√≥n

Con base en las pruebas realizadas:

- La API `ReactiveStringRedisTemplate` (parte de `Spring Data Redis`) present√≥ tiempos de ejecuci√≥n ligeramente
  superiores (es decir, m√°s lentos).
    - Esto se mantuvo tanto cuando utiliz√≥ `Lettuce` como cliente (al inicio), como cuando pas√≥ a usar `Redisson` como
      backend (tras modificar las dependencias). Es decir, el menor rendimiento est√° asociado al enfoque de la API, no
      solo al cliente.
- No ofrece integraci√≥n directa con `ReactiveCrudRepository`, lo que limita su uso como repositorio reactivo
  completo en aplicaciones Spring.
- La API `RedissonReactiveClient` mostr√≥ un leve mejor rendimiento en operaciones intensivas como incrementos, y
  adem√°s proporciona un conjunto m√°s amplio de estructuras distribuidas y primitivas reactivas (colas, locks, maps,
  etc.).

> üí° Para aplicaciones reactivas que requieren mayor rendimiento, concurrencia distribuida o estructuras de datos
> avanzadas, `Redisson` representa una alternativa m√°s robusta, flexible y lista para escenarios exigentes.

### ‚úÖ Spring Boot 3.5.4 + Java 21

Con las √∫ltimas versiones de Spring y Java:

- `Spring Data Redis` (basado en `Lettuce`) ha mejorado en compatibilidad con `Reactor 3.6+`, y tambi√©n tiene mejor
  gesti√≥n de conexiones.
- Sin embargo, `Redisson` a√∫n es preferido cuando se requieren:
    - Operaciones distribuidas (locks, sem√°foros, etc.)
    - Estructuras de datos complejas (listas, colas, mapas multivalorados, etc.)
    - Un rendimiento m√°s predecible bajo carga intensiva

Por tanto, si bien `Spring Data Redis` es suficiente para tareas simples (como caching, sesiones, contadores),
`Redisson` sigue siendo una opci√≥n m√°s potente y escalable para escenarios m√°s exigentes.

## Cache Aside Pattern

El `patr√≥n Cache Aside` (tambi√©n conocido como `Lazy Loading`) es uno de los patrones m√°s comunes para implementar
almacenamiento en cach√© con `Redis`. Su prop√≥sito es claro:
`reducir la carga sobre las bases de datos o servicios externos` almacenando los resultados de operaciones costosas
para su reutilizaci√≥n posterior.

### üß† ¬øCu√°ndo aplicarlo?

Este patr√≥n es √∫til principalmente en los siguientes casos:

- Cuando necesitamos cachear respuestas generadas din√°micamente.
- Para reducir la carga sobre bases de datos en operaciones de lectura frecuente.
- Para disminuir llamadas a APIs externas o servicios de terceros.

### ü§î ¬øPor qu√© no usar solo cach√© en memoria dentro de cada instancia?

Porque esto genera m√∫ltiples problemas en arquitecturas distribuidas:

- `Desperdicio de memoria`: cada instancia de la aplicaci√≥n mantiene su propia copia en cach√©, lo que es ineficiente.
- `Falta de sincronizaci√≥n`: las instancias no comparten el estado de la cach√©, por lo que pueden tener versiones
  inconsistentes de los datos.

### üöÄ ¬øC√≥mo Redis nos ayuda?

La idea es simple: permitir que una instancia haga el trabajo pesado, y que todas las dem√°s lo reutilicen. Veamos c√≥mo
funciona con un ejemplo:

1. Un usuario realiza una solicitud a la aplicaci√≥n.
2. El `Load Balancer` redirige la petici√≥n a una instancia disponible.
3. Esa instancia procesa la solicitud, consultando una base de datos o un servicio externo.
4. Antes de retornar la respuesta, guarda el resultado en Redis con una clave.
5. Las pr√≥ximas solicitudes que lleguen a cualquier instancia pueden consultar directamente `Redis` usando esa clave,
   evitando repetir el trabajo.

![01.png](assets/section-05/01.png)

> üìå `Redis` act√∫a como una cach√© compartida entre todas las instancias.

### üß≠ Flujo del patr√≥n Cache Aside

Este flujo ilustra los pasos t√≠picos del patr√≥n:

1. Consultar primero `Redis` con la clave correspondiente.
2. Si no se encuentra (cache miss):
    - Consultar la fuente de datos original (base de datos, API, c√°lculo, etc.).
3. Guardar el resultado en `Redis` para futuras peticiones.
4. Retornar la respuesta al cliente.

![02.png](assets/section-05/02.png)

Este enfoque permite que `Redis` act√∫e como un almacenamiento de lectura r√°pida y compartida, eliminando la necesidad
de duplicar l√≥gica o almacenamiento entre m√∫ltiples instancias de la aplicaci√≥n.

## Fibonacci Service

Como punto de partida, creamos un servicio muy sencillo que calcula el valor de la secuencia de `Fibonacci` para un
√≠ndice dado. Este ejemplo ser√° la base para aplicar luego un `patr√≥n de cach√© con Redis`.

![03.png](assets/section-05/03.png)

### L√≥gica del servicio

````java

@Slf4j
@Service
public class FibService {
    public int getFib(int index) {
        log.info("Calculando fib para √≠ndice: {}", index);
        int fib = this.fib(index);
        log.info("C√°lculo obtenido: {}", fib);
        return fib;
    }

    // Intencional 2^N, usamos recursividad intencionalmente,
    // este es el peor algoritmo, lo hacemos para que se tarde en calcular
    private int fib(int index) {
        if (index < 2) return index;
        return fib(index - 1) + fib(index - 2);
    }
}
````

- Usamos un algoritmo recursivo puro, sin optimizaciones.
- Este algoritmo tiene complejidad exponencial `(O(2^n))`, lo cual provoca un alto costo computacional, especialmente
  en √≠ndices altos.
- Lo hacemos intencionalmente para simular una operaci√≥n costosa, que se pueda beneficiar del uso de `cache`.

### Exponiendo el servicio por API REST

````java

@RequiredArgsConstructor
@RestController
@RequestMapping(path = "/api/v1/fib")
public class FibController {

    private final FibService fibService;

    @GetMapping(path = "/{index}")
    public Mono<ResponseEntity<Integer>> getFib(@PathVariable int index) {
        return Mono.fromSupplier(() -> ResponseEntity.ok(this.fibService.getFib(index)));
    }

}
````

- El endpoint `/api/v1/fib/{index}` permite calcular el `n-√©simo` n√∫mero de `Fibonacci`.
- Retorna una respuesta `200 OK` con el resultado.
- El uso de `Mono.fromSupplier(...)` garantiza que el c√°lculo se ejecute de forma perezosa y no bloqueante, aunque el
  algoritmo en s√≠ no es reactivo internamente (usa recursividad tradicional).

### üß™ Prueba 1: √çndice peque√±o

Realizamos una prueba de c√°lculo con un √≠ndice moderado `(6)`, el cual deber√≠a responder en tiempo aceptable:

````bash
$ curl -v http://localhost:8080/api/v1/fib/6 | jq
>
< HTTP/1.1 200 OK
< Content-Type: application/json
< Content-Length: 1
<
8
````

Log en consola:

````bash
INFO 18588 --- [redis-spring] [ctor-http-nio-3] d.m.redis.app.fib.service.FibService     : Calculando fib para √≠ndice: 6
INFO 18588 --- [redis-spring] [ctor-http-nio-3] d.m.redis.app.fib.service.FibService     : C√°lculo obtenido: 8
````

### üß™ Prueba 2: √çndice elevado

Al solicitar el valor para `index=48`, el sistema tarda varios segundos en responder debido a la complejidad del
algoritmo:

````bash
$ curl -v http://localhost:8080/api/v1/fib/48 | jq
>
< HTTP/1.1 200 OK
< Content-Type: application/json
< Content-Length: 9
<
--:--:--  0:00:17 --:--:--
512559680
````

Log en consola:

````bash
INFO 18588 --- [redis-spring] [ctor-http-nio-5] d.m.redis.app.fib.service.FibService     : Calculando fib para √≠ndice: 48
INFO 18588 --- [redis-spring] [ctor-http-nio-5] d.m.redis.app.fib.service.FibService     : C√°lculo obtenido: 512559680
````

Tiempo de respuesta aproximado: `17 segundos`.

üß† Observaci√≥n
> Este escenario simula una operaci√≥n costosa que se repite innecesariamente si m√∫ltiples usuarios solicitan el mismo
> √≠ndice. Justamente aqu√≠ es donde aplicaremos un patr√≥n de cacheo para evitar c√°lculos redundantes, mejorar la
> eficiencia y reducir la carga del sistema.

## Uso de `@Cacheable` ‚Äì Parte 1

Para mejorar el rendimiento de operaciones costosas (como c√°lculos intensivos o consultas externas), podemos aprovechar
el `sistema de cacheo autom√°tico` que proporciona `Spring` usando `Redis como backend`. En este ejemplo, cachearemos
los resultados de la funci√≥n de Fibonacci.

### üõ† Configuraci√≥n de Spring Boot con Cache y Redisson

Primero, activamos el mecanismo de cacheo en la aplicaci√≥n usando la anotaci√≥n `@EnableCaching` en la clase principal:

````java

@EnableCaching
@SpringBootApplication
public class RedisSpringApplication {
    public static void main(String[] args) {
        SpringApplication.run(RedisSpringApplication.class, args);
    }
}
````

- `@EnableCaching`: Habilita la infraestructura de cacheo en Spring. Esto permite utilizar anotaciones como
  `@Cacheable`, `@CachePut`, y `@CacheEvict`.
- Esta configuraci√≥n es compatible con m√∫ltiples proveedores de cach√©, pero en este caso usaremos `Redis` a trav√©s de
  `Redisson`.

Luego, definimos un `CacheManager` basado en `Redisson`:

````java

@Configuration
public class RedissonCacheConfig {
    @Bean
    public CacheManager cacheManager(RedissonClient redissonClient) {
        return new RedissonSpringCacheManager(redissonClient);
    }
}
````

- `RedissonSpringCacheManager`: Implementa la interfaz `org.springframework.cache.CacheManager` usando `Redisson`.
  Gestiona las operaciones de cacheo sobre `Redis`.
- Este bean se integrar√° autom√°ticamente con Spring al detectar `@Cacheable`, y almacenar√° los datos en `Redis`.

Finalmente, anotamos el m√©todo costoso que queremos cachear con `@Cacheable`:

````java

@Slf4j
@Service
public class FibService {

    @Cacheable(cacheNames = "math:fib")
    public int getFib(int index) {
        log.info("Calculando fib para √≠ndice: {}", index);
        int fib = this.fib(index);
        log.info("C√°lculo obtenido: {}", fib);
        return fib;
    }

    // Intencionalmente lento (complejidad O(2^N))
    private int fib(int index) {
        if (index < 2) return index;
        return fib(index - 1) + fib(index - 2);
    }
}
````

- `@Cacheable(cacheNames = "math:fib")`: Indica que el resultado del m√©todo `getFib(index)` debe almacenarse en una
  cach√© llamada `math:fib`.
    - Si se invoca el m√©todo nuevamente con el mismo argumento `index`, Spring retornar√° el valor desde `Redis` sin
      ejecutar el m√©todo.
- El valor se almacena como un `Hash` en `Redis` bajo la clave `math:fib` y con el `index` como subclave interna.

### üöÄ Pruebas de comportamiento con @Cacheable

En el apartado anterior incorporamos anotaciones de `Spring` para implementar el `patr√≥n Cache Aside` de forma
`declarativa`, y as√≠ evitar recalcular resultados costosos como el de la serie de Fibonacci.

> üìå En este apartado observaremos c√≥mo Spring `almacena autom√°ticamente en Redis` los resultados retornados por el
> servicio, acelerando dr√°sticamente las respuestas subsecuentes.

### Primera solicitud

Realizamos una primera solicitud al endpoint `/api/v1/fib/48`, que calcula el valor de Fibonacci para el √≠ndice `48`.

````bash
$ curl -v http://localhost:8080/api/v1/fib/48 | jq
>
< HTTP/1.1 200 OK
< Content-Type: application/json
< Content-Length: 9
<
--:--:--  0:00:17 --:--:--
512559680
````

- La respuesta tarda aproximadamente `17 segundos`, lo cual es esperado debido a la implementaci√≥n recursiva
  ineficiente (complejidad exponencial `O(2^n)`).
- En la consola del IDE podemos ver los logs generados por el m√©todo del servicio:

````bash
d.m.redis.app.fib.service.FibService     : Calculando fib para √≠ndice: 48
d.m.redis.app.fib.service.FibService     : C√°lculo obtenido: 512559680
````

üß† Importante: Aqu√≠ se ejecuta todo el c√°lculo real, ya que no hay ning√∫n valor almacenado a√∫n en cach√©.

### Segunda solicitud

Inmediatamente despu√©s, repetimos la misma solicitud:

````bash
$ curl -v http://localhost:8080/api/v1/fib/48 | jq
>
< HTTP/1.1 200 OK
< Content-Type: application/json
< Content-Length: 9
<
--:--:-- --:--:-- --:--:--
512559680
````

- La respuesta ahora es `instant√°nea`.
- En la consola del IDE no se imprimen los logs de c√°lculo, lo que indica que el m√©todo `getFib(...)` no fue ejecutado.

‚úÖ Spring intercept√≥ la llamada y retorn√≥ directamente el valor desde la cach√©, evitando el c√≥mputo.

### Inspecci√≥n en Redis CLI

Luego de estar realizando varias solicitudes al endpoint, vamos a consultar mediante la consola de redis los valores
almacenados. En ese sentido, el resultado que observamos a continuaci√≥n nos hace confirmar que las respuestas han
sido almacenadas autom√°ticamente en `Redis` bajo una clave:

````bash
127.0.0.1:6379> keys *
(empty array)
127.0.0.1:6379> keys *
127.0.0.1:6379> keys *
1) "math:fib"
127.0.0.1:6379> type math:fib
hash
127.0.0.1:6379> hgetall math:fib
1) "\x02\n"
2) "\x02\n"
3) "\x02Z"
4) "\x02\x84\xfe\xa9\xba\b"
5) "\x02`"
6) "\x02\x80\xa9\xe8\xe8\x03"
127.0.0.1:6379> 
````

> ‚ö†Ô∏è Observaci√≥n: Los datos se encuentran serializados en formato binario. Spring utiliza por defecto una serializaci√≥n
> binaria (basada en Java Serialization) para almacenar objetos complejos.

M√°s adelante aprenderemos c√≥mo personalizar esta serializaci√≥n para hacerla m√°s legible o interoperable (por ejemplo,
usando JSON).

## Uso de `@Cacheable` ‚Äì Parte 2

Vamos a modificar nuestro m√©todo de c√°lculo de Fibonacci para que reciba un par√°metro adicional. Este nuevo par√°metro
no afectar√° el resultado del c√°lculo, pero nos servir√° para explorar c√≥mo funciona la `cach√© con m√∫ltiples argumentos`.

````java

@Slf4j
@Service
public class FibService {

    @Cacheable(cacheNames = "math:fib", key = "#index")
    public int getFib(int index, String name) {
        log.info("Calculando fib para √≠ndice: {} , nombre: {}", index, name);
        int fib = this.fib(index);
        log.info("C√°lculo obtenido: {}", fib);
        return fib;
    }

    private int fib(int index) { /*code*/ }
}
````

En el controlador tambi√©n actualizamos el endpoint para aceptar ambos par√°metros:

````java

@GetMapping(path = "/{index}/{name}")
public Mono<ResponseEntity<Integer>> getFib(@PathVariable int index, @PathVariable String name) {
    return Mono.fromSupplier(() -> ResponseEntity.ok(this.fibService.getFib(index, name)));
}
````

### üß™ Primera prueba: nueva combinaci√≥n de argumentos

Realizamos una primera solicitud con el √≠ndice `48` y el nombre `sam`:

````bash
$ curl -v http://localhost:8080/api/v1/fib/48/sam | jq
>
< HTTP/1.1 200 OK
< Content-Type: application/json
< Content-Length: 9
<
--:--:--  0:00:17 --:--:--
512559680
````

En los logs vemos claramente que el m√©todo fue ejecutado:

````bash
d.m.redis.app.fib.service.FibService     : Calculando fib para √≠ndice: 48 , nombre: sam
d.m.redis.app.fib.service.FibService     : C√°lculo obtenido: 512559680 
````

### üß™ Segunda prueba: solo cambia el nombre

Ahora repetimos la solicitud, pero cambiamos √∫nicamente el nombre:

````bash
$ curl -v http://localhost:8080/api/v1/fib/48/jake | jq
>
< HTTP/1.1 200 OK
< Content-Type: application/json
< Content-Length: 9
<
--:--:--  0:00:19 --:--:--
512559680
````

Tambi√©n en este caso el m√©todo fue ejecutado nuevamente:

````bash
d.m.redis.app.fib.service.FibService     : Calculando fib para √≠ndice: 48 , nombre: jake
d.m.redis.app.fib.service.FibService     : C√°lculo obtenido: 512559680
````

### ü§î ¬øPor qu√© se ejecuta otra vez?

El m√©todo `getFib(...)` ahora tiene dos par√°metros:

````java

@Cacheable(cacheNames = "math:fib")
public int getFib(int index, String name) {/*code*/}
````

Como `no se especific√≥ expl√≠citamente una clave de cach√©`, Spring utilizar√° por defecto todos los par√°metros del m√©todo
para generar una clave compuesta. Por lo tanto, aunque el √≠ndice sea el mismo (`48`), el par√°metro `name` es distinto
en cada solicitud, lo que genera `claves diferentes` y fuerza el rec√°lculo.

### ‚úÖ Prueba de que se almacena por combinaci√≥n exacta

Si repetimos la solicitud con los mismos par√°metros que ya fueron ejecutados (por ejemplo, `index = 48` y
`name = "jake"`), esta vez el resultado se recupera desde `Redis` al instante:

````bash
$ curl -v http://localhost:8080/api/v1/fib/48/jake | jq
>
< HTTP/1.1 200 OK
< Content-Type: application/json
< Content-Length: 9
<
--:--:-- --:--:-- --:--:--
512559680 
````

Y los logs del m√©todo no aparecen, lo cual confirma que no se volvi√≥ a ejecutar, sino que el valor fue obtenido desde
la cach√©.

### üßæ Conclusi√≥n

El `cacheName` (`math:fib`) define la regi√≥n donde se almacenan las entradas en Redis, pero la clave espec√≠fica
generada depende de los par√°metros del m√©todo.

- Si usamos varios par√°metros, Spring los considera todos al generar la clave.
- Por eso, aunque el resultado del c√°lculo sea el mismo, la cach√© no lo reutiliza si los argumentos difieren.
- En este punto, podemos optimizar el comportamiento indicando expl√≠citamente cu√°l par√°metro usar como clave (por
  ejemplo, `@Cacheable(..., key = "#index"))`, lo cual veremos a continuaci√≥n.

### üéØ Mejorando el comportamiento del cacheo con `key = "#index"`

Anteriormente, observamos que al agregar un segundo par√°metro (`name`) al m√©todo `getFib(...)`, `Spring` consideraba
toda la combinaci√≥n de argumentos para generar la key del cach√©. Esto implicaba que, aunque el valor de index fuera
el mismo, un cambio en el nombre causaba que el m√©todo se volviera a ejecutar y recalculara el resultado.

Sin embargo, en nuestro escenario, `el par√°metro name no influye en el resultado del c√°lculo`, por lo que podemos
optimizar el comportamiento de la cach√© indic√°ndole a Spring que `solo utilice index como clave de cacheo`. Para ello,
usamos el atributo `key` dentro de la anotaci√≥n `@Cacheable`:

````java

@Cacheable(cacheNames = "math:fib", key = "#index")
public int getFib(int index, String name) {
    log.info("Calculando fib para √≠ndice: {} , nombre: {}", index, name);
    int fib = this.fib(index);
    log.info("C√°lculo obtenido: {}", fib);
    return fib;
}
````

### üß™ Comprobaci√≥n pr√°ctica

1. `Limpiar el contenido de Redis`. Antes de probar la mejora, vaciamos el cach√© ejecutando el siguiente comando desde
   Redis CLI:
    ````bash
    $ flushdb
    ````
2. `Primera solicitud ‚Äì se ejecuta el c√°lculo`. Al invocar por primera vez el endpoint con `index=48` y `name=sam`,
   `Redis` no tiene la key almacenada, por lo tanto, el m√©todo se ejecuta y tarda los esperados 18 segundos:
    ````bash
    $ curl -v http://localhost:8080/api/v1/fib/48/sam | jq
    >
    < HTTP/1.1 200 OK
    < Content-Type: application/json
    < Content-Length: 9
    <
    --:--:--  0:00:18 --:--:--
    512559680
    ````
   Log del c√°lculo en consola:
    ````bash
    d.m.redis.app.fib.service.FibService     : Calculando fib para √≠ndice: 48 , nombre: sam
    d.m.redis.app.fib.service.FibService     : C√°lculo obtenido: 512559680
    ````
3. `Segunda solicitud ‚Äì cache hit`. Si volvemos a invocar el endpoint, pero ahora cambiamos solo el nombre (`index=48`,
   `name=jake`), el resultado ser√° retornado inmediatamente desde Redis. El m√©todo `no se ejecuta nuevamente`,
   demostrando que la clave generada depende √∫nicamente de index:
    ````bash
    $ curl -v http://localhost:8080/api/v1/fib/48/jake | jq
    --:--:-- --:--:-- --:--:--
    512559680
    ````

> ‚úÖ Gracias al uso de `key = "#index"`, conseguimos que Spring reutilice el valor almacenado para cualquier invocaci√≥n
> cuyo √≠ndice sea el mismo, sin importar los dem√°s par√°metros. Esto reduce c√°lculos innecesarios y mejora
> significativamente el rendimiento.

## üßπUso de `@CacheEvict` para limpiar cach√©

En este apartado, aprenderemos a eliminar entradas espec√≠ficas de Redis utilizando la anotaci√≥n `@CacheEvict`,
lo cual es especialmente √∫til cuando los datos almacenados en cach√© deben invalidarse o actualizarse.

> üìå Como primer paso, eliminaremos el par√°metro `name` del m√©todo `getFib(...)`, ya que fue introducido √∫nicamente con
> fines demostrativos en el apartado anterior.

1. Modificaci√≥n del servicio

Agregamos un nuevo m√©todo `clearCache(...)` anotado con `@CacheEvict`. Este m√©todo nos permite eliminar una clave
espec√≠fica del hash `math:fib` en Redis, utilizando el mismo criterio de `key` que usamos para almacenar
(`key = "#index"`).

````java

@Slf4j
@Service
public class FibService {

    @Cacheable(cacheNames = "math:fib", key = "#index")
    public int getFib(int index) {
        log.info("Calculando fib para √≠ndice: {}", index);
        int fib = this.fib(index);
        log.info("C√°lculo obtenido: {}", fib);
        return fib;
    }

    @CacheEvict(cacheNames = "math:fib", key = "#index")
    public void clearCache(int index) {
        log.info("Limpiando hash key");

    }

    private int fib(int index) {/*code*/}
}
````

2. Actualizaci√≥n del controlador

Exponemos un nuevo endpoint para acceder al m√©todo `clearCache(...)`. Este endpoint permitir√° eliminar una entrada
espec√≠fica del cache v√≠a HTTP GET.

````java

@RequiredArgsConstructor
@RestController
@RequestMapping(path = "/api/v1/fib")
public class FibController {

    private final FibService fibService;

    @GetMapping(path = "/{index}")
    public Mono<ResponseEntity<Integer>> getFib(@PathVariable int index) {
        return Mono.fromSupplier(() -> ResponseEntity.ok(this.fibService.getFib(index)));
    }

    @GetMapping(path = "/{index}/clear")
    public Mono<ResponseEntity<Void>> clear(@PathVariable int index) {
        return Mono.fromSupplier(() -> {
            this.fibService.clearCache(index);
            return ResponseEntity.noContent().build();
        });
    }

}
````

### üß™ Pruebas

1. Limpiamos Redis ejecutando `flushdb`.
2. Ejecutamos una solicitud con `index=48`. Como es la primera vez, el c√°lculo se realiza normalmente
   (tarda `~17 segundos`).
    ````bash
    $ curl -v http://localhost:8080/api/v1/fib/48 | jq
    >
    < HTTP/1.1 200 OK
    < Content-Type: application/json
    < Content-Length: 9
    <
    --:--:--  0:00:17 --:--:--
    512559680
    ````
   Logs:
    ````bash
    d.m.redis.app.fib.service.FibService     : Calculando fib para √≠ndice: 48
    d.m.redis.app.fib.service.FibService     : C√°lculo obtenido: 512559680 
    ````

3. Hacemos la misma solicitud por segunda vez. El resultado se devuelve al instante gracias a Redis:
    ````bash
    $ curl -v http://localhost:8080/api/v1/fib/48 | jq
    >
    < HTTP/1.1 200 OK
    < Content-Type: application/json
    < Content-Length: 9
    <
    --:--:-- --:--:-- --:--:--
    512559680
    ````
4. Validamos en Redis que el hash `math:fib` contiene la entrada cacheada:
    ````bash
    127.0.0.1:6379> keys *
    (empty array)
    127.0.0.1:6379> keys *
    1) "math:fib"
    127.0.0.1:6379> hgetall math:fib
    1) "\x02`"
    2) "\x02\x80\xa9\xe8\xe8\x03"
    127.0.0.1:6379> 
    ````

‚úÖ Hasta este punto, se mantiene el comportamiento esperado usando `@Cacheable` para almacenar resultados.

### ‚úÖ Verificaci√≥n del comportamiento de @CacheEvict

````bash
$ curl -v http://localhost:8080/api/v1/fib/48/clear | jq
>
< HTTP/1.1 204 No Content
````

Vemos que la petici√≥n se ejecuta correctamente, incluso el log del m√©todo `clearCache(int index)` se ejecuta sin
problemas.

````bash
d.m.redis.app.fib.service.FibService     : Limpiando hash key 
````

Ahora, si consultamos en redis, vemos que ya no tenemos ning√∫n registro almacenado.

````bash
127.0.0.1:6379> keys *
(empty array) 
````

Con esto comprobamos que hemos limpiado el valor del `key = "#index"` asociado al hash `math:fib` correctamente. Ahora,
si volvemos a hacer la petici√≥n para calcular el fibonacci con el `index=48`, el m√©todo se volver√° a ejecutar.

````bash
$ curl -v http://localhost:8080/api/v1/fib/48 | jq
>
< HTTP/1.1 200 OK
< Content-Type: application/json
< Content-Length: 9
<
--:--:--  0:00:17 --:--:--
512559680
````

Como pudimos observar:

- La llamada al endpoint `/api/v1/fib/48/clear` activa el m√©todo `clearCache(int index)`, el cual est√° anotado con
  `@CacheEvict`.
- Esta anotaci√≥n indica a Spring que debe eliminar la entrada correspondiente al `√≠ndice 48` dentro del `hash`
  `math:fib` almacenado en Redis.
- La respuesta 204 No Content confirma que la operaci√≥n se realiz√≥ exitosamente.
- Al verificar en Redis CLI, vemos que la key `math:fib` ha sido eliminada del almacenamiento.
- Como consecuencia, la siguiente vez que se solicita `/fib/48`, el sistema no encuentra el valor en cach√©, por lo que
  vuelve a ejecutar el c√°lculo completo de Fibonacci.

> üß† `Conclusi√≥n`: La anotaci√≥n `@CacheEvict` nos permite `invalidar de forma puntual` y declarativa
> `entradas espec√≠ficas de la cach√©`, lo que es especialmente √∫til cuando los datos han cambiado y es necesario
> refrescar el contenido en Redis.

## üïí Evicci√≥n programada de cach√© (@Scheduled + @CacheEvict)

En este apartado implementaremos una estrategia autom√°tica para limpiar peri√≥dicamente la cach√© de Redis usando las
anotaciones `@Scheduled` y `@CacheEvict`.

El objetivo ser√° eliminar todas las entradas del cach√© `math:fib` cada cierto intervalo de tiempo (`10 segundos`), sin
necesidad de que un cliente realice una solicitud directa para limpiar manualmente.

````java

@Slf4j
@Service
public class FibService {

    @Cacheable(cacheNames = "math:fib", key = "#index")
    public int getFib(int index) {
        log.info("Calculando fib para √≠ndice: {}", index);
        int fib = this.fib(index);
        log.info("C√°lculo obtenido: {}", fib);
        return fib;
    }

    @CacheEvict(cacheNames = "math:fib", key = "#index")
    public void clearCache(int index) {
        log.info("Limpiando hash key");

    }

    // Cada 10 segundos que limpie todas las entradas del math:fib
    @Scheduled(fixedRate = 10_000)
    @CacheEvict(cacheNames = "math:fib", allEntries = true)
    public void clearCache() {
        log.info("Limpiando todas las keys del math:fib");

    }

    private int fib(int index) {/*code*/}
}
````

**D√≥nde**

- `@Cacheable(...)`: Indica que el resultado del m√©todo `getFib(...)` se almacenar√° en el cach√© con nombre `math:fib`,
  usando como clave el valor de index.
- `@CacheEvict(key = "#index")`: M√©todo para eliminar solo una entrada espec√≠fica del hash `math:fib`.
- `@Scheduled(fixedRate = 10_000)`: Indica que el m√©todo se ejecutar√° cada 10 segundos, sin importar cu√°nto tiempo
  demore.
- `@CacheEvict(allEntries = true)`: Borra todas las entradas asociadas al cach√© `math:fib`.

üîÅ La combinaci√≥n de `@Scheduled` y `@CacheEvict` permite que esta limpieza ocurra autom√°ticamente de forma peri√≥dica.

Para que el `@Scheduled` funcione, debes habilitar la programaci√≥n de tareas en la clase principal:

````java

@EnableCaching
@EnableScheduling
@SpringBootApplication
public class RedisSpringApplication {
    public static void main(String[] args) {
        SpringApplication.run(RedisSpringApplication.class, args);
    }
}
````

- `@EnableCaching`: Activa el soporte de cach√© en la aplicaci√≥n Spring (ya lo ven√≠amos usando).
- `@EnableScheduling`: Habilita el procesamiento de tareas programadas como `@Scheduled`.

### üß™ Ejecuci√≥n y verificaci√≥n

Si levantamos la aplicaci√≥n y observamos la consola, veremos que el m√©todo `clearCache()` se ejecuta autom√°ticamente
cada 10 segundos:

````bash
d.m.redis.app.fib.service.FibService     : Limpiando todas las keys del math:fib
d.m.redis.app.fib.service.FibService     : Limpiando todas las keys del math:fib
d.m.redis.app.fib.service.FibService     : Limpiando todas las keys del math:fib
...
````

Adem√°s, si consultamos Redis en esos momentos, veremos que la clave `math:fib` es eliminada:

````bash
127.0.0.1:6379> keys *
1) "math:fib"
127.0.0.1:6379> keys *
(empty array)
127.0.0.1:6379> 
````

### ‚úÖ Conclusi√≥n

Este enfoque es √∫til cuando:

- Queremos evitar acumulaci√≥n innecesaria de datos en cach√©.
- Los datos almacenados tienen una vida √∫til corta o son muy din√°micos.
- No necesitamos granularidad en la limpieza (es decir, no nos interesa borrar entradas espec√≠ficas, sino todo el cach√©
  asociado).

> üí° `Tip`: Esta estrategia tambi√©n puede ser combinada con `TTL (tiempo de vida por entrada)` para tener un control
> m√°s fino del ciclo de vida del cach√©.
