# Secci√≥n 03: Redis - Curso Intensivo

- [Redis Cheat Sheet](https://cheatography.com/tasjaevan/cheat-sheets/redis/)
- [Commands](https://redis.io/docs/latest/commands/)

---

## üîπ Introducci√≥n a Redis

`Redis (Remote Dictionary Server)` es una base de datos `NoSQL`, en memoria, de estructura de datos `clave-valor`.
Es ampliamente reconocida por su alto rendimiento, baja latencia y su versatilidad para resolver distintos problemas
de arquitectura de software. Su enfoque en el almacenamiento en memoria hace que sea incre√≠blemente r√°pido en
comparaci√≥n con otras bases de datos que dependen del disco.

### ‚úÖ Caracter√≠sticas principales

- üöÄ `Velocidad extrema`: Redis opera en `memoria RAM`, lo que permite tiempos de respuesta del orden de microsegundos.
- üîÑ `Persistencia opcional`: Aunque es una base de datos en memoria, puede configurarse para guardar datos en disco,
  usando mecanismos como RDB snapshots o AOF (Append-Only File).
- ‚öôÔ∏è `Estructuras de datos avanzadas`: A diferencia de otras bases de datos `clave-valor` simples, `Redis` ofrece
  estructuras como:
    - Strings
    - Lists
    - Sets
    - Hashes
    - Sorted Sets
    - Bitmaps
    - HyperLogLogs
    - Streams
    - Geo data

- üîÅ Soporte para replicaci√≥n, clustering y alta disponibilidad.
- üß© Extensibilidad mediante m√≥dulos adicionales.

### üß† Piensa en Redis como

> Un servidor de estructuras de datos multiprop√≥sito, que vive en memoria y responde con extrema rapidez.
> Es √∫til no solo como base de datos, sino tambi√©n como middleware para acelerar y coordinar aplicaciones distribuidas.

### üìå Casos de uso comunes

Redis puede cumplir distintos roles dentro de una arquitectura moderna:

- üß† `Caching (Almacenamiento en cach√©)`: Ideal para almacenar resultados de consultas a bases de datos tradicionales o
  llamadas a APIs costosas, acelerando las respuestas.
- üì£ `Pub/Sub (Publicaci√≥n/Suscripci√≥n)`: Redis permite comunicaci√≥n en tiempo real entre servicios o usuarios mediante
  canales de mensajes.
- üì¨ `Message Queue (Cola de mensajes)`: Redis puede funcionar como sistema de colas, similar a RabbitMQ o Kafka, usando
  listas o streams.
- üì∫ `Streaming de datos`: Con Redis Streams, se puede manejar flujo de datos continuo (por ejemplo, logs, eventos de
  usuarios, sensores IoT).
- üåç `GeoSpatial`: Redis permite almacenar, indexar y consultar datos geoespaciales (latitud/longitud), muy √∫til para
  mapas o servicios de geolocalizaci√≥n.
- üîê `Rate limiting (limitaci√≥n de solicitudes)`: Muy usado para proteger APIs ante abusos o sobrecarga.
- ‚è±Ô∏è` Expiraci√≥n y TTL (time-to-live)`: Ideal para datos temporales o sensibles.

### üîÑ Redis en la arquitectura de una aplicaci√≥n

Redis no reemplaza a una base de datos relacional o documental como PostgreSQL o MongoDB. En lugar de eso, Redis
complementa estas tecnolog√≠as como un acelerador de rendimiento, o como componente especializado dentro de una
arquitectura m√°s robusta.

üìå Ejemplo de integraci√≥n:

- PostgreSQL para almacenamiento transaccional.
- Redis para cach√© de resultados o para gestionar sesiones de usuario.

![01.png](assets/section-03/01.png)

### üåê Ecosistema Redis

- Redis es gratuito y de c√≥digo abierto (`Open Source`).
- Existen dos portales principales que encontrar√°s al buscar informaci√≥n:
    - üîó `redis.io` ‚Äì Sitio oficial del proyecto `open source`.
    - üîó `redislabs.com` ‚Äì Redis Labs, ahora conocido como `Redis Inc.`, ofrece servicios comerciales y Redis en la
      nube (Redis Enterprise).

## üõ†Ô∏è Configuraci√≥n de Redis mediante Docker

### üîπ Componentes clave de Redis

`Redis` se compone principalmente de dos herramientas fundamentales que trabajan juntas para permitir su uso efectivo:

- üß± `redis-server`: Es el proceso principal del servidor Redis, encargado de gestionar las estructuras de datos,
  el almacenamiento en memoria, recibir comandos, mantener conexiones activas y ejecutar operaciones.
  `Es el servidor Redis propiamente dicho`.


- üñ•Ô∏è `redis-cli`: Es la herramienta de l√≠nea de comandos que permite interactuar con el `servidor Redis`. Nos permite
  conectarnos al servidor y enviarle comandos interactivos. Es esencial para pruebas, inspecci√≥n o manipulaci√≥n directa
  de datos. A trav√©s de `redis-cli`, podr√°s ejecutar comandos como `PING`, `SET`, `GET`, `DEL`, entre muchos otros.

![02.png](assets/section-03/02.png)

Estos dos componentes existen independientemente de c√≥mo decidas instalar Redis, ya sea:

- Directamente en tu sistema operativo (por ejemplo, con apt, brew, o desde el c√≥digo fuente).
- Mediante un contenedor Docker.
- A trav√©s de una distribuci√≥n en la nube.

üìå En resumen, tanto `redis-server` como `redis-cli` son elementos esenciales de `Redis` y se utilizan en todos los
entornos, no solo cuando se usa Docker.

### üì¶ Creaci√≥n del servicio Redis con Docker Compose

Para comenzar a trabajar con `Redis` en un entorno local de forma r√°pida y aislada, es muy com√∫n utilizar `Docker`.
Esto evita instalaciones complejas en el sistema operativo y permite que podamos levantar servicios reproducibles en
diferentes entornos (desarrollo, pruebas, producci√≥n).

> **Atenci√≥n: Usuario de Windows (que no desea usar Docker)**
>
> `Redis` no admite la instalaci√≥n directa en Windows. Existe una soluci√≥n alternativa. El equipo de Redis ha creado un
> v√≠deo oficial con los pasos para la instalaci√≥n de Redis en Windows,
> [disponible en YouTube](https://www.youtube.com/watch?v=1psWME8UH_0).

Para levantar el contenedor de Redis f√°cilmente, se recomienda usar `Docker Compose`, lo cual nos permite definir los
servicios en un archivo `compose.yml`. Este archivo especifica qu√© imagen usar, el nombre del contenedor, las reglas de
red, puertos expuestos, entre otros detalles.

````yml
services:
  s-redis:
    image: redis:8.0.3-alpine
    container_name: c-redis
    restart: unless-stopped
    ports:
      - '6379:6379'
````

### ‚ñ∂Ô∏è Ejecutar el contenedor

Para levantar el servicio, nos posicionamos en el directorio d√≥nde se encuentra el `compose.yml` y ejecutamos el
siguiente comando.

````bash
D:\programming\spring\01.udemy\03.vinoth_selvaraj\reactive-redis-masterclass\docker (feature/section-3)
$ docker compose up -d                                                                                 
[+] Running 8/8                                                                                        
 ‚úî s-redis Pulled                                                                                      
   ‚úî f18232174bc9 Already exists                                                                       
   ‚úî 10753f8102ef Pull complete                                                                        
   ‚úî a9c51c568321 Pull complete                                                                        
   ‚úî b96ac5b0d90b Pull complete                                                                        
   ‚úî 3b985785c0a3 Pull complete                                                                        
   ‚úî 4f4fb700ef54 Pull complete                                                                        
   ‚úî 6b9706545272 Pull complete                                                                        
[+] Running 2/2                                                                                        
 ‚úî Network docker_default  Created                                                                     
 ‚úî Container c-redis       Started                                                                     
````

Puedes listar los contenedores en ejecuci√≥n con el siguiente comando.

````bash
$ docker container ls -a
CONTAINER ID   IMAGE                COMMAND                  CREATED              STATUS              PORTS                                         NAMES
f37a8bd54269   redis:8.0.3-alpine   "docker-entrypoint.s‚Ä¶"   About a minute ago   Up About a minute   0.0.0.0:6379->6379/tcp, [::]:6379->6379/tcp   c-redis
````

### üß™ Probar conexi√≥n al servidor Redis

Para comprobar que el servidor Redis est√° activo y accesible, podemos ingresar al contenedor y ejecutar el cliente de
l√≠nea de comandos (`redis-cli`):

````bash
$ docker container exec -it c-redis /bin/sh
/data # redis-cli
127.0.0.1:6379> ping
PONG
127.0.0.1:6379>
````

El comando `PING` es una forma simple de testear conectividad con el servidor. La respuesta `PONG` indica que el
servidor Redis est√° funcionando correctamente y est√° aceptando comandos.

### ‚úÖ Conclusi√≥n

Gracias al uso de `Docker` y `Docker Compose`, podemos levantar una instancia funcional de `Redis` en segundos, sin
necesidad de instalar nada en el sistema operativo. Esto es especialmente √∫til para pruebas locales, desarrollo o
para integrarlo dentro de arquitecturas de microservicios.

## üîë Almacenamiento de valores clave simples en Redis

### üîπ Fundamentos de clave-valor en Redis

Una de las operaciones m√°s b√°sicas y esenciales en `Redis` es el almacenamiento de datos usando el modelo `clave-valor`
(`key-value`). En este modelo, se asocia un valor a una clave √∫nica, y `Redis` se encarga de guardar esa informaci√≥n
en memoria.

### üß† Conceptos clave:

- `Redis` es, en esencia, un almac√©n de estructuras de datos basado en `clave-valor`.
- Tanto las claves como los valores son, por defecto, cadenas de texto (`strings`). Incluso los valores num√©ricos se
  almacenan internamente como texto.
- `Redis` permite trabajar con claves binarias arbitrarias, lo que significa que puedes usar casi cualquier secuencia
  de bytes como nombre de clave. Aun as√≠, se recomienda usar nombres legibles y cortos para facilitar su mantenimiento
  y comprensi√≥n.
- Redis puede manejar m√°s de 2^32 claves (m√°s de 4 mil millones), aunque la limitaci√≥n real estar√° dada por la memoria
  disponible en el sistema.
- El tama√±o m√°ximo permitido para una clave o valor tipo string es de 512 MB.

### ‚ñ∂Ô∏è Ejemplo pr√°ctico con SET y GET

Antes de ejecutar comandos, debemos asegurarnos de tener acceso al servidor `Redis` desde el contenedor. Comprobamos la
conexi√≥n con un `PING`:

````bash
$ docker container exec -it c-redis /bin/sh
/data # redis-cli
127.0.0.1:6379> ping
PONG
````

La respuesta `PONG` indica que el cliente (`redis-cli`) se est√° comunicando exitosamente con el servidor
(`redis-server`).

### üì¶ Almacenar y recuperar datos

Probamos las operaciones b√°sicas SET y GET en Redis:

````bash
127.0.0.1:6379> set a b
OK
127.0.0.1:6379> get a
"b"
127.0.0.1:6379> get c
(nil)
127.0.0.1:6379> set a 1
OK
127.0.0.1:6379> get a
"1"
127.0.0.1:6379>
````

1. `SET a b`: Se crea la clave a y se le asigna el valor "b". Redis responde con OK, lo que indica √©xito en la
   operaci√≥n.
2. `GET a`: Recupera el valor de la clave a, devolviendo `"b"`.
3. `GET c`: La clave c no existe, por lo tanto, Redis devuelve (nil), lo que indica ausencia de valor.
4. `SET a 1`: Sobrescribe el valor anterior de la clave a con `"1"`.
5. `GET a`: Devuelve `"1"`. Aunque sea un n√∫mero, Redis lo almacena como cadena de texto, salvo que se utilicen
   comandos espec√≠ficos para operar como n√∫meros (`INCR`, `DECR`, etc.).

### üìù Nota t√©cnica: Strings en Redis

Aunque `Redis` almacena los valores como cadenas (`strings`), internamente es muy eficiente al detectar si el contenido
es num√©rico. Esto le permite ejecutar operaciones aritm√©ticas directamente sobre ellos, lo cual veremos m√°s adelante.

Ejemplo de operaci√≥n con n√∫mero:

````bash
127.0.0.1:6379> set a 1
OK
127.0.0.1:6379> incr a
(integer) 2
127.0.0.1:6379> get a
"2"
127.0.0.1:6379>
````

Si `a` contiene una cadena que representa un n√∫mero, `INCR` lo convertir√° en entero, lo incrementar√° y actualizar√° el
valor.

### üß≠ Convenciones para nombrar claves en Redis

A diferencia de bases de datos relacionales como `PostgreSQL` o documentales como `MongoDB`, `Redis` no organiza los
datos en tablas, colecciones ni esquemas estructurados.

- No hay columnas, filas, ni tipos complejos de entidades.
- Redis opera a nivel de claves individuales que apuntan a valores.
- Cada clave es totalmente independiente y no est√° "agrupada" en ninguna estructura formal.

Esto le da gran flexibilidad, pero traslada la responsabilidad de la organizaci√≥n a los desarrolladores, quienes deben
seguir convenciones claras al nombrar claves.

### üß† Convenciones comunes para definir claves

Como `Redis` no impone una jerarqu√≠a o agrupamiento, la comunidad ha adoptado convenciones sem√°nticas para nombrar
claves de forma organizada.

Una muy extendida consiste en `simular rutas o endpoints`, como si fueran URLs, siguiendo una estructura l√≥gica que
represente el recurso. Ejemplos:

| id | name | endpoint                     |
|----|------|------------------------------|
| 1  | sam  | /user/1/name                 |
| 2  | jake | /user/2/name or /user/name/2 |

Sin embargo, por convenci√≥n, la comunidad `Redis` prefiere usar el car√°cter dos puntos `(:)` para estructurar las claves
de forma l√≥gica y visual, como si fueran "rutas" jer√°rquicas. Esto ayuda a mantener orden y claridad al trabajar con
grandes vol√∫menes de claves.

‚ú® El car√°cter `:` no tiene ning√∫n significado especial para Redis, pero se utiliza como una convenci√≥n humana para
mantener un sistema de nombres limpio, predecible y m√°s f√°cil de consultar.

````bash
127.0.0.1:6379> set user:1:name martin
OK
127.0.0.1:6379> set user:2:name milagros
OK
127.0.0.1:6379> get user:1:name
"martin"
127.0.0.1:6379> get user:2:name
"milagros"
127.0.0.1:6379>
````

En este caso:

- Las claves `user:1:name` y `user:2:name` siguen una convenci√≥n de tipo: `recurso:id:atributo`
- Esto hace que sea m√°s f√°cil visualizar, mantener y recuperar datos relacionados con estructuras complejas como
  usuarios, productos, sesiones, etc.

‚úÖ Conclusi√≥n
> El modelo `clave-valor` de `Redis` es simple pero extremadamente poderoso. Las operaciones `SET` y `GET` permiten
> guardar y recuperar datos r√°pidamente, y su comportamiento predecible lo convierte en una herramienta ideal para
> casos de uso como almacenamiento en cach√©, configuraci√≥n, sesiones, contadores y mucho m√°s.

## üîç Accediendo a todas las claves en Redis

En Redis, las claves no est√°n agrupadas por tabla o colecci√≥n, por lo que si queremos inspeccionar las que ya existen,
podemos usar comandos especiales para listarlas. Esto es √∫til para `debugging`, `exploraci√≥n` o `scripting`.

````bash
127.0.0.1:6379> keys *
1) "a"
2) "1"
3) "user:1:name"
4) "user:2:name"
5) "user/name/1"

127.0.0.1:6379> keys user*
1) "user:1:name"
2) "user:2:name"
3) "user/name/1"
````

- `KEYS *` devuelve todas las claves del servidor Redis.
- Tambi√©n puedes usar patrones con comodines:
    - `user*` ‚Äì Claves que empiezan con `user`
    - `*name` ‚Äì Claves que terminan en `name`
    - `*:*:name` ‚Äì Claves con dos `:` y terminadas en `name`

‚ö†Ô∏è Advertencia importante:
> El comando `KEYS` recorre todas las claves en memoria, por lo que es muy costoso en rendimiento si tienes muchas
> claves (por ejemplo, millones). `Nunca debe usarse en producci√≥n`.

### üîÑ Alternativa segura: comando SCAN

`Redis` ofrece el comando `SCAN` como una alternativa no bloqueante al comando `KEYS`. En lugar de devolver todas
las claves de una sola vez, lo hace de forma iterativa y paginada.

Para ver en funcionamiento el comando `SCAN` vamos a agregar muchas claves. Estas claves adicionales nos permiten
simular una base de datos con m√∫ltiples elementos para probar el comportamiento de SCAN.

````bash
127.0.0.1:6379> set user:3:name 3
OK
127.0.0.1:6379> set user:4:name 4
OK
127.0.0.1:6379> set user:5:name 5
OK
127.0.0.1:6379> set user:6:name 6
OK
127.0.0.1:6379> set user:7:name 7
OK
127.0.0.1:6379> set user:8:name 8
OK
127.0.0.1:6379> set user:9:name 9
OK
127.0.0.1:6379> set user:10:name 10
OK
127.0.0.1:6379> set user:11:name 11
OK
127.0.0.1:6379> set user:12:name 12
OK
127.0.0.1:6379> set user:13:name 13
OK
127.0.0.1:6379> set user:14:name 14
````

A continuaci√≥n, veremos en ejecuci√≥n el comando `SCAN`.

````bash
127.0.0.1:6379> scan 0
1) "25"
2)  1) "user:9:name"
    2) "user:11:name"
    3) "user:7:name"
    4) "user:13:name"
    5) "user:10:name"
    6) "a"
    7) "user:4:name"
    8) "user:3:name"
    9) "1"
   10) "user:1:name"
127.0.0.1:6379> scan 25
1) "0"
2) 1) "user:2:name"
   2) "user:8:name"
   3) "user:14:name"
   4) "user/name/1"
   5) "user:12:name"
   6) "user:6:name"
   7) "user:5:name"
127.0.0.1:6379>
````

- `scan 0:` comienza desde el `cursor 0`, que representa el `inicio del escaneo`.
- El primer valor de la respuesta `("25")` es el nuevo cursor que se debe usar para la siguiente iteraci√≥n.
- La segunda parte contiene una lista parcial de claves.
- Cuando el cursor devuelto sea `0`, significa que el escaneo ha finalizado.

üìå Esto lo hace ideal para aplicaciones que necesitan explorar claves sin bloquear el servidor `Redis`.

### üéØ SCAN con filtros y l√≠mite de resultados

Aqu√≠ le decimos que nos retorne el listado de claves que hagan match con `user*` pero que solo nos muestre 2 resultados.

````bash
127.0.0.1:6379> scan 0 match user* count 2
1) "16"
2) 1) "user:9:name"
   2) "user:11:name"
````

Par√°metros √∫tiles:

- `MATCH <pattern>`: Filtra claves seg√∫n un patr√≥n, similar a KEYS.
- `COUNT <n>`: Indica cu√°ntas claves `aproximadamente` se desea obtener por iteraci√≥n. `No garantiza exactitud`.

> ‚ÑπÔ∏è `SCAN` est√° dise√±ado para exploraci√≥n segura en entornos productivos. Se recomienda usarlo junto con ciclos de
> c√≥digo (loops) para recorrer todos los resultados.

## üóëÔ∏è Eliminando claves en Redis

`Redis` nos permite `eliminar una o m√°s claves` de la `base de datos en memoria` usando el comando `DEL`. Es una
operaci√≥n sencilla pero muy √∫til, especialmente durante desarrollo, limpieza de datos temporales o invalidaci√≥n de
cach√©s.

A continuaci√≥n eliminamos m√∫ltiples claves: `a`, `1` y `user/name/1`:

- `Redis` devuelve el n√∫mero total de claves eliminadas con √©xito.
- Si una de las claves no existiera, el contador disminuir√≠a seg√∫n corresponda.

````bash
127.0.0.1:6379> del a 1 user/name/1
(integer) 3 
````

Si eliminamos una clave que no existe, simplemente nos indica que se han eliminado 0 claves. Esto es completamente
normal y no genera error. Redis ignora silenciosamente claves inexistentes.

````bash
127.0.0.1:6379> del user:100:name
(integer) 0 
````

### üßπ Eliminando todas las claves de Redis

Redis permite eliminar todas las claves de la base de datos actual utilizando el comando `flushdb`. Este comando
reinicia por completo la base de datos seleccionada (por defecto, la n√∫mero 0), eliminando todos los datos almacenados.

````bash
127.0.0.1:6379> flushdb
OK
127.0.0.1:6379> keys *
(empty array)
127.0.0.1:6379> 
````

## ‚è±Ô∏è Claves con expiraci√≥n en Redis ‚Äì Parte 1

`Redis` permite asociar un tiempo de vida `(TTL: Time To Live)` a cualquier clave. Esto significa que una vez cumplido
ese tiempo, la clave ser√° `eliminada autom√°ticamente` por Redis, liberando espacio en memoria.

Esta funcionalidad es √∫til para:

- Cachear datos temporales.
- Manejar sesiones que caducan.
- Invalidar tokens o autorizaciones.
- Implementar l√≥gica de "desaparici√≥n" (expiring state).

### ‚ñ∂Ô∏è Usando SET con expiraci√≥n

Redis nos permite definir el tiempo de vida directamente al momento de guardar una clave usando el modificador
`EX` (en segundos) o `PX` (en milisegundos).

````bash
127.0.0.1:6379> set a b EX 10
OK
127.0.0.1:6379> get a
"b"
127.0.0.1:6379> get a
"b"
127.0.0.1:6379> get a
"b"
127.0.0.1:6379> get a
(nil) 
````

- El valor `"b"` se almacena en la clave `a`.
- Luego de 10 segundos, al hacer `GET`, `Redis` devuelve (`nil`) porque la clave ha expirado.

### üìè Verificando tiempo restante con TTL

`Redis` ofrece el comando `TTL (Time To Live)` para ver cu√°ntos segundos le quedan de vida a una clave:

````bash
127.0.0.1:6379> set a b ex 10
OK
127.0.0.1:6379> ttl a
(integer) 7
127.0.0.1:6379> ttl a
(integer) 5
````

- El resultado indica cu√°ntos segundos faltan para que la clave expire.
- Si la clave no tiene expiraci√≥n, `TTL` devuelve `-1`.
- Si la clave no existe, `TTL` devuelve `-2`.

### üîÅ Extendiendo el TTL con EXPIRE

Puedes modificar o extender el tiempo de vida de una clave en cualquier momento usando `EXPIRE <clave> <segundos>`.

````bash
127.0.0.1:6379> expire a 60
(integer) 1
127.0.0.1:6379> ttl a
(integer) 58
127.0.0.1:6379> ttl a
(integer) 55

127.0.0.1:6379> expire a 600
(integer) 1
127.0.0.1:6379> ttl a
(integer) 598
127.0.0.1:6379> ttl a
(integer) 597
127.0.0.1:6379> ttl a
(integer) 595
127.0.0.1:6379>  
````

- Redis responde `1` si la expiraci√≥n fue aplicada con √©xito.

## ‚è±Ô∏è Claves con expiraci√≥n en Redis ‚Äì Parte 2

### üîπ Establecer expiraci√≥n con una fecha exacta (EXAT)

Redis permite definir la expiraci√≥n de una clave en un momento espec√≠fico del tiempo (en segundos desde la √©poca UNIX)
usando el modificador `EXAT`.

La sintaxis es `SET key value EXAT <timestamp_en_segundos>`. Esto es equivalente a decir: "Esta clave debe expirar
exactamente en el segundo `UNIX 1752161050`."

> `Nota`, en mi caso obtuve ese `timestamp` en java usando `Instant.now().plusSeconds(120).getEpochSecond();`

Veamos el siguiente ejemplo.

````bash
$ 127.0.0.1:6379> set a b exat 1752161050
OK
127.0.0.1:6379> ttl a
(integer) 98
127.0.0.1:6379> ttl a
(integer) 98
127.0.0.1:6379> ttl a
(integer) 92
127.0.0.1:6379> ttl a
(integer) 85
127.0.0.1:6379>
````

### üîπ Establecer expiraci√≥n en milisegundos (PX)

Redis tambi√©n permite definir el tiempo de vida en milisegundos con el modificador `PX`.

````bash
127.0.0.1:6379> set a b px 3000
OK
127.0.0.1:6379> get a
"b"
127.0.0.1:6379> get a
"b"
127.0.0.1:6379> get a
(nil) 
````

- La clave `a` fue eliminada autom√°ticamente luego de 3 segundos (3000 ms).
- Es √∫til cuando necesitas mayor precisi√≥n temporal, como para `throttling` o `expiraci√≥n de tokens temporales`.

### üß® ¬øQu√© pasa si sobrescribo una clave con TTL?

Cuando sobrescribes una clave con `SET`, por defecto:

- ‚úÖ El nuevo valor es guardado
- ‚ùå Pero el TTL anterior se pierde

Veamos el siguiente ejemplo.

````bash
127.0.0.1:6379> set a b ex 60
OK
127.0.0.1:6379> ttl a
(integer) 58
127.0.0.1:6379> ttl a
(integer) 22
127.0.0.1:6379> set a c
OK
127.0.0.1:6379> ttl a
(integer) -1
````

- El valor fue actualizado, pero Redis elimin√≥ el TTL anterior.
- Esto puede romper una l√≥gica si esperabas que expirara igual.

### üîí Mantener el TTL al sobrescribir (KEEPTTL)

Para evitar la p√©rdida del tiempo de expiraci√≥n cuando sobrescribes una clave, Redis ofrece el modificador `KEEPTTL`.

````bash
127.0.0.1:6379> set a b ex 60
OK
127.0.0.1:6379> ttl a
(integer) 56
127.0.0.1:6379> ttl a
(integer) 52
127.0.0.1:6379> get a
"b"
127.0.0.1:6379> set a c keepttl
OK
127.0.0.1:6379> ttl a
(integer) 32
127.0.0.1:6379> ttl a
(integer) 29
127.0.0.1:6379> get a
"c"
````

- La clave `a` cambi√≥ su valor de `"b"` a `"c"`, pero mantuvo la expiraci√≥n original.
- Redis continuar√° eliminando la clave en el momento previsto.

### üìò Resumen de modificadores de expiraci√≥n

| Modificador    | Significado                                         |
|----------------|-----------------------------------------------------|
| `EX <seg>`     | Expira en N segundos                                |
| `PX <ms>`      | Expira en N milisegundos                            |
| `EXAT <epoch>` | Expira en un instante UNIX exacto                   |
| `PXAT <epoch>` | Expira en un instante UNIX exacto (en milisegundos) |
| `KEEPTTL`      | Mantiene el TTL actual al sobrescribir la clave     |

## ‚öôÔ∏è Opciones Condicionales para SET: NX y XX

### üîπ ¬øQu√© son NX y XX?

Cuando usamos el comando `SET` en Redis, podemos aplicar condiciones sobre si la clave ya existe o no antes de realizar
la operaci√≥n.

Estas opciones te permiten controlar si quieres:

- ‚úÖ Crear una clave solo si no existe (`NX`)
- ‚úÖ Actualizar una clave solo si ya existe (`XX`)

### Sintaxis general

````bash
SET <clave> <valor> [NX | XX] 
````

| Opci√≥n | Significado                                       |
|--------|---------------------------------------------------|
| `NX`   | Solo establece el valor **si la clave NO existe** |
| `XX`   | Solo establece el valor **si la clave S√ç existe** |

### üî∏ Usando XX (Solo si la clave ya existe)

````bash
127.0.0.1:6379>  SET a b XX
(nil) 
````

Como la clave a no existe, Redis no hace nada y devuelve (nil).

### üî∏ Usando NX (Solo si la clave no existe)

````bash
127.0.0.1:6379>  SET a b NX
OK
127.0.0.1:6379> GET a
"b" 
````

Redis crea la clave `a` con valor  `"b"` porque a√∫n no exist√≠a.

### üî∏ Intento de sobrescribir usando NX

````bash
127.0.0.1:6379> SET a c NX
(nil)
127.0.0.1:6379> GET a
"b"
127.0.0.1:6379>
````

Como `a` ya existe, Redis ignora la operaci√≥n y mantiene el valor anterior.

## üîç Comando EXISTS en Redis

El comando `EXISTS` permite verificar si una o m√°s claves est√°n presentes actualmente en Redis.

- Devuelve 1 si la clave existe.
- Devuelve 0 si la clave no existe o ya expir√≥.

Este comando es √∫til para verificar la existencia de claves antes de realizar operaciones adicionales.

Con el comando `exists` podemos saber si una clave existe o no. Si la clave est√° presente retorna `1`, si la clave no
est√° presente retorna `0`.

````bash
127.0.0.1:6379> exists user:1:session
(integer) 0
127.0.0.1:6379> set user:1:session token ex 20
OK
127.0.0.1:6379> exists user:1:session
(integer) 1
127.0.0.1:6379> get user:1:session
"token"
````

- Inicialmente, la clave `user:1:session` no existe ‚Üí devuelve 0.
- Luego se define la clave con un valor y una expiraci√≥n ‚Üí devuelve 1.

### üìâ Expiraci√≥n autom√°tica

Despu√©s de que expira el TTL, Redis elimina la clave autom√°ticamente, y `EXISTS` lo refleja:

````bash
127.0.0.1:6379> get user:1:session
(nil)
127.0.0.1:6379> exists user:1:session
(integer) 0 
````

Redis confirma que la clave ya fue eliminada ‚Üí retorna 0.

## üîºüîΩ Comandos INCR / DECR en Redis

Redis ofrece una serie de comandos para incrementar o decrementar valores num√©ricos almacenados como cadenas. Estas
operaciones son at√≥micas, lo que las hace ideales para contadores, sistemas de votos, limitadores de uso, etc.

### üß™ Ejemplo b√°sico con INCR

````bash
127.0.0.1:6379> set a 1
OK
127.0.0.1:6379> get a
"1"
127.0.0.1:6379> incr a
(integer) 2
127.0.0.1:6379> get a
"2"
127.0.0.1:6379>  incr a
(integer) 3
127.0.0.1:6379> get a
"3" 
````

- INCR incrementa el valor de a en +1.
- El valor es almacenado como una cadena, pero Redis lo trata como un n√∫mero entero.

### üî∏ ¬øY si la clave no existe?

````bash
127.0.0.1:6379> keys *
(empty array)
127.0.0.1:6379> incr a
(integer) 1
127.0.0.1:6379> get a
"1"
````

Si la clave no existe, Redis la inicializa autom√°ticamente en 0 y luego la incrementa.

### üîΩ Uso de DECR (decremento)

````bash
127.0.0.1:6379> get a
"5"
127.0.0.1:6379> decr a
(integer) 4
127.0.0.1:6379> decr a
(integer) 3
127.0.0.1:6379> decr a
(integer) 2
````

- DECR reduce el valor en -1.
- Tambi√©n funciona si la clave no existe: se inicializa como 0 y luego se decrementa.

### üî∏ INCRBYFLOAT ‚Äì con decimales

````bash
127.0.0.1:6379> set a 1.05
OK
127.0.0.1:6379> incrbyfloat a 0.52
"1.57"
127.0.0.1:6379> get a
"1.57"
127.0.0.1:6379> incrbyfloat a -0.07
"1.5"
127.0.0.1:6379> get a
"1.5"
````

- INCRBYFLOAT permite usar valores decimales (flotantes).
- Redis sigue almacenando el resultado como string, pero lo interpreta correctamente como n√∫mero.

### üî∏ INCRBY y DECRBY ‚Äì con enteros

````bash
127.0.0.1:6379> set a 100
OK
127.0.0.1:6379> get a
"100"
127.0.0.1:6379> incrby a 20
(integer) 120
127.0.0.1:6379> get a
"120"
127.0.0.1:6379> decrby a 5
(integer) 115
127.0.0.1:6379> get a
"115"
````

- INCRBY incrementa en el n√∫mero especificado.
- DECRBY decrementa en el n√∫mero especificado.

### üß† Consideraciones importantes

- Todos estos comandos `fallar√°n si el valor actual no es num√©rico` (por ejemplo, si la clave contiene texto).
- Redis maneja todo como string, pero internamente convierte para operaciones num√©ricas.
- Estas operaciones son at√≥micas, es decir, seguras frente a concurrencia.
- Son muy √∫tiles para:
    - Contadores de visitas
    - Sistemas de votos (like/dislike)
    - L√≠mite de peticiones por usuario (rate limiting)

### üìò Resumen de comandos

| Comando             | Descripci√≥n                                            |
|---------------------|--------------------------------------------------------|
| `INCR key`          | Incrementa en +1                                       |
| `DECR key`          | Decrementa en -1                                       |
| `INCRBY key N`      | Incrementa en N                                        |
| `DECRBY key N`      | Decrementa en N                                        |
| `INCRBYFLOAT key F` | Incrementa por n√∫mero flotante F (positiva o negativa) |

## üß± Redis Hash ‚Äì Parte 1

### üîπ ¬øQu√© es un Hash en Redis?

Un hash en Redis es una estructura de datos que almacena pares `campo-valor` dentro de una clave √∫nica. Se utiliza
principalmente para representar objetos o entidades, como usuarios, productos o configuraciones.

### üìå Diferencias con SET/GET

- `SET/GET`: se usan para pares clave-valor simples (una sola entrada por clave).
- `HSET/HGET`: se usan para almacenar m√∫ltiples atributos o propiedades de un objeto bajo una sola clave.

### üì¶ Caso de uso

Supongamos que quieres representar usuarios:

| id | name | age | city    |
|----|------|-----|---------|
| 1  | sam  | 10  | atlanta |
| 2  | jake | 20  | miami   |

Puedes usar un hash por cada usuario:

````bash
127.0.0.1:6379> hset user:1 name sam age 10 city atlanta
(integer) 3
````

- Crea la clave `user:1` como un hash.
- Inserta 3 campos: `name`, `age`, `city`.

### üîç Verificaci√≥n

````bash
127.0.0.1:6379> keys *
1) "user:1"
127.0.0.1:6379> type user:1
hash
````

Redis identifica `user:1` como tipo `hash`.

### üì• Acceder a valores individuales

````bash
127.0.0.1:6379> hget user:1 name
"sam"
127.0.0.1:6379> hget user:1 age
"10"
127.0.0.1:6379> hget user:1 city
"atlanta"
````

Puedes recuperar campos espec√≠ficos sin obtener todo el hash.

### üì§ Obtener todos los campos

````bash
127.0.0.1:6379> hgetall user:1
1) "name"
2) "sam"
3) "age"
4) "10"
5) "city"
6) "atlanta" 
````

Retorna todos los pares `campo-valor` del `hash` como una lista.

### ‚úÖ Ventajas de usar HASH

- Permite manejar objetos estructurados en una sola clave.
- Ideal para representar entidades del dominio (usuarios, productos, etc.).
- Reduce el n√∫mero de claves en Redis (evita user:1:name, user:1:age, etc.).
- Puedes actualizar campos de forma selectiva sin sobrescribir todo el valor.

### üìò Comandos clave de hash

| Comando               | Descripci√≥n                             |
|-----------------------|-----------------------------------------|
| `HSET key field val`  | Define un campo dentro de un hash       |
| `HGET key field`      | Obtiene el valor de un campo espec√≠fico |
| `HGETALL key`         | Retorna todos los campos y valores      |
| `HDEL key field`      | Elimina uno o m√°s campos                |
| `HEXISTS key field`   | Verifica si existe un campo             |
| `HLEN key`            | Cantidad de campos en el hash           |
| `HINCRBY key field n` | Incrementa valor num√©rico               |

## üß± Redis Hash ‚Äì Parte 2

### üîπ Comandos adicionales para trabajar con Hashes

Una vez que tienes un hash en Redis, puedes realizar operaciones m√°s espec√≠ficas como obtener solo las claves o valores,
verificar si existen ciertos campos, o eliminar alguno de ellos.

### üîç HKEYS ‚Äì Obtener solo los nombres de campos

````bash
127.0.0.1:6379> hkeys user:1
1) "name"
2) "age"
3) "city"
````

### üì• HVALS ‚Äì Obtener solo los valores

````bash
127.0.0.1:6379> hvals user:1
1) "sam"
2) "10"
3) "atlanta"
````

### ‚úÖ HEXISTS ‚Äì Verificar si un campo existe

````bash
127.0.0.1:6379> hexists user:1 name
(integer) 1
````

- Devuelve 1 si el campo name existe dentro del hash user:1.
- Devuelve 0 si el campo no existe.

### ‚ùå HDEL ‚Äì Eliminar uno o m√°s campos

````bash
127.0.0.1:6379> hdel user:1 age
(integer) 1
````

- Elimina el campo `age` del hash `user:1`.
- El n√∫mero retornado indica cu√°ntos campos fueron eliminados (en este caso, 1).

### üîÑ Verificar nuevamente los campos restantes

````bash
127.0.0.1:6379> hkeys user:1
1) "name"
2) "city"
127.0.0.1:6379> hvals user:1
1) "sam"
2) "atlanta"
````

Confirma que el campo age fue eliminado correctamente.

### ‚ö†Ô∏è Importante: Redis Hash ‚â† Tabla Relacional

Aunque los hashes de Redis se parezcan a las filas de una tabla, Redis no impone ninguna estructura fija para los
campos. No existe una `"definici√≥n de esquema"` como en una tabla de SQL.

üìå Ejemplo:

````bash
127.0.0.1:6379> hset user:1 name sam age 10 city atlanta
(integer) 3

127.0.0.1:6379> hset user:2 status active score 100 admin false
(integer) 3
````

üîé Como ves:

- `user:1` tiene campos como name, age, city.
- `user:2` tiene campos completamente distintos: status, score, admin.

‚úÖ Conclusi√≥n:

- Redis no fuerza consistencia de campos entre hashes.
- Cada hash puede tener campos diferentes.
- Redis no valida tipos, ni exige que un "objeto" tenga una estructura determinada.
- Esto le da flexibilidad, pero tambi√©n implica que la consistencia depende del desarrollador.
- üí° Si necesitas consistencia entre estructuras de datos, debes manejarla t√∫ mismo desde la aplicaci√≥n.

## üìö Redis List & Queue

### üîπ ¬øQu√© es una List en Redis?

Una `List` en `Redis` es una estructura de datos que almacena una `colecci√≥n ordenada de strings`. Internamente,
se implementa de forma muy eficiente, lo que la hace ideal para operaciones como `inserci√≥n/extracci√≥n` en los extremos.

### ‚úÖ Caracter√≠sticas:

- Ordenada por inserci√≥n.
- Puede contener elementos repetidos.
- Equivalente a una `LinkedList` en `Java`.
- Puede funcionar como:
    - `Queue (cola)`: comportamiento `FIFO` (First-In, First-Out).
    - `Stack (pila)`: comportamiento `LIFO` (Last-In, First-Out).

### üîß Casos de uso comunes

- Message Queue (cola de mensajes).
- Log de eventos o acciones de usuario.
- Pila temporal de tareas por procesar.
- Sistema de chat (buffer de mensajes).

### üß™ Ejemplo pr√°ctico

‚ñ∂Ô∏è Agregar elementos con `RPUSH`

````bash
127.0.0.1:6379> rpush users martin milagros kiara
(integer) 3
````

- Crea la lista users.
- Inserta los valores al final de la lista (r = right).

üîç Verificar contenido y tipo

````bash
127.0.0.1:6379> keys *
1) "users"
127.0.0.1:6379> type users
list
127.0.0.1:6379> llen users
(integer) 3
````

- `type` confirma que la clave users es una lista.
- `llen` muestra que hay 3 elementos (l=list, len=length)

üì• Leer rangos con `LRANGE`

````bash
127.0.0.1:6379> lrange users 0 -1
1) "martin"
2) "milagros"
3) "kiara"
127.0.0.1:6379> lrange users 0 1
1) "martin"
2) "milagros"
````

- `LRANGE users 0 -1`: obtiene todos los elementos.
- `LRANGE users 0 1`: obtiene solo del √≠ndice 0 al 1.

üßπ Eliminar elementos

````bash
127.0.0.1:6379> lpop users
"martin"
````

- `LPOP`: elimina el primer elemento (inicio) ‚Üí Comportamiento FIFO. (l=left)

````bash
127.0.0.1:6379> rpop users
"kiara"
````

- `RPOP`: elimina el √∫ltimo elemento (final) ‚Üí Comportamiento LIFO. (r=right)

````bash
127.0.0.1:6379> lrange users 0 -1
(empty array)
127.0.0.1:6379> llen users
(integer) 0
````

- Lista vac√≠a: se ha eliminado todo.

### üìò Comandos comunes para List

| Comando                | Descripci√≥n                                  |
|------------------------|----------------------------------------------|
| `RPUSH key val...`     | Inserta al final de la lista                 |
| `LPUSH key val...`     | Inserta al inicio de la lista                |
| `LPOP key`             | Elimina y retorna el primer elemento         |
| `RPOP key`             | Elimina y retorna el √∫ltimo elemento         |
| `LRANGE key start end` | Retorna una porci√≥n de la lista (como slice) |
| `LLEN key`             | Retorna la cantidad de elementos             |
| `LTRIM key start end`  | Recorta la lista a un rango espec√≠fico       |

### üí° Notas adicionales

- Redis List es muy r√°pida para operaciones en los extremos (LPUSH, RPUSH, LPOP, RPOP) incluso con millones de
  elementos.
- Si no existe la clave y haces RPUSH o LPUSH, Redis crea autom√°ticamente la lista.
- A diferencia de un array, acceder a un elemento en una posici√≥n intermedia o profunda de una lista en Redis puede ser
  lento, ya que Redis recorre la lista desde el inicio o el final hasta alcanzar el √≠ndice.

## üì¶ Redis List como Stack (Pila)

Una `pila (stack)` es una estructura de datos basada en el principio `LIFO (Last-In, First-Out)`, es decir:
> El √∫ltimo elemento en entrar es el primero en salir.

`Redis` no tiene un tipo de dato espec√≠fico `Stack`, pero podemos simular este comportamiento perfectamente usando la
estructura List.

### üõ†Ô∏è C√≥mo implementarlo en Redis

Para que una lista se comporte como pila:

- Usamos `RPUSH` para insertar elementos al final de la lista (lado derecho).
- Usamos `RPOP` para eliminar y retornar el √∫ltimo elemento (lado derecho).

Este patr√≥n imita el comportamiento de una pila tradicional.

üîç En este punto, la lista users contiene

````bash
127.0.0.1:6379> rpush users 1 2
(integer) 2
127.0.0.1:6379> rpush users 3 4
(integer) 4
127.0.0.1:6379> rpush users 5
(integer) 5
127.0.0.1:6379> lrange users 0 -1
1) "1"
2) "2"
3) "3"
4) "4"
5) "5"
````

üì§ Eliminamos elementos como si fuera una pila (LIFO)

````bash
127.0.0.1:6379> rpop users
"5"
127.0.0.1:6379> rpop users
"4"
````

üìå Se eliminaron primero los √∫ltimos que se insertaron: "5" y "4".

````bash
127.0.0.1:6379> llen users
(integer) 3
````

üìè Confirmamos el tama√±o actual

### ‚úÖ Conclusi√≥n

- Redis List permite simular una pila LIFO de forma eficiente.
- Basta con insertar y eliminar siempre desde el mismo extremo (rpush y rpop o alternativamente lpush y lpop).
- Este patr√≥n es √∫til para funcionalidades como deshacer acciones, manejo de backtracking, evaluaci√≥n de expresiones,
  etc.

## Redis Set

### üß† ¬øQu√© es un Set en Redis?

Un `Set` en `Redis` es una `colecci√≥n desordenada` de valores √∫nicos (tipo String).

- Es similar a un Set en Java:
- No permite duplicados.
- El orden de los elementos no est√° garantizado.
- Muy √∫til para validar pertenencia o manejar grupos sin repetici√≥n.

### üéØ Casos de uso comunes

- Lista de usuarios actualmente conectados.
- Lista de direcciones IP bloqueadas (blacklist).
- Validar si un usuario o valor pertenece a un grupo.
- Operaciones de conjuntos: intersecci√≥n, uni√≥n, diferencia, etc.

### ‚öôÔ∏è Comandos clave con ejemplos

````bash
# Agregamos m√∫ltiples elementos al set
127.0.0.1:6379> sadd roles superadmin admin user
(integer) 3 
````

````bash
# Agregamos un nuevo rol
127.0.0.1:6379> sadd roles guest
(integer) 1

# Intentamos agregar un duplicado (no se a√±ade)
127.0.0.1:6379> sadd roles guest
(integer) 0
````

````bash
# Contamos los elementos del set
127.0.0.1:6379> scard roles
(integer) 4
````

````bash
# Obtenemos todos los elementos del set (orden no garantizado)
127.0.0.1:6379> smembers roles
1) "superadmin"
2) "admin"
3) "user"
4) "guest"
````

````bash
# Verificamos si un elemento pertenece al set
127.0.0.1:6379> sismember roles admin
(integer) 1

127.0.0.1:6379> sismember roles root
(integer) 0
````

````bash
# Eliminamos un elemento del set
127.0.0.1:6379> srem roles guest
(integer) 1

127.0.0.1:6379> smembers roles
1) "superadmin"
2) "admin"
3) "user"
````

### ‚úÖ Conclusi√≥n

- Redis Set es perfecto cuando necesitas almacenar elementos √∫nicos sin importar el orden.
- Proporciona operaciones eficientes para a√±adir, eliminar y verificar pertenencia.
- Es altamente √∫til para manejar grupos din√°micos en aplicaciones web, como roles, etiquetas, sesiones activas, etc.

## üîÅ Redis Set ‚Äì Intersecci√≥n, Uni√≥n y Diferencia

### üìå Recordatorio: ¬øQu√© es un Set en Redis?

Un Set es una colecci√≥n de elementos √∫nicos y desordenados. Redis permite realizar operaciones de conjunto similares a
las matem√°ticas de teor√≠a de conjuntos, como:

- `SINTER` ‚Üí Intersecci√≥n
- `SUNION` ‚Üí Uni√≥n
- `SDIFF` ‚Üí Diferencia
- Tambi√©n existen variantes que almacenan el resultado: `SINTERSTORE`, `SUNIONSTORE`, `SDIFFSTORE`.

### üîç Datos de entrada

Definimos varios sets de usuarios con distintas habilidades:

````bash
127.0.0.1:6379> sadd skill:java 1 2 3 4
(integer) 4

127.0.0.1:6379> sadd skill:js 2 3 4
(integer) 3

127.0.0.1:6379> sadd skill:aws 4 5 6
(integer) 3
````

### üîπ Intersecci√≥n (SINTER)

Retorna los elementos comunes entre los sets.

````bash
127.0.0.1:6379> sinter skill:java skill:js skill:aws
1) "4"
````

üìå El valor "4" es el √∫nico presente en los tres conjuntos.

### üîπ Uni√≥n (SUNION)

Retorna todos los elementos √∫nicos combinados de los sets.

````bash
127.0.0.1:6379> sunion skill:java skill:js
1) "1"
2) "2"
3) "3"
4) "4"

127.0.0.1:6379> sunion skill:java skill:aws
1) "1"
2) "2"
3) "3"
4) "4"
5) "5"
6) "6"
````

### üîπ Diferencia (SDIFF)

Retorna los elementos del primer set que no est√°n presentes en los dem√°s.

````bash
127.0.0.1:6379> sadd candidate:criminal 4 5 6
(integer) 3

127.0.0.1:6379> sdiff skill:java candidate:criminal
1) "1"
2) "2"
3) "3"
````

üìå Aqu√≠ identificamos los usuarios de `skill:java` que no tienen antecedentes.

### üíæ Almacenar resultados: SINTERSTORE

````bash
127.0.0.1:6379> sinterstore java-js skill:java skill:js
(integer) 3
````

‚úÖ El resultado de la `intersecci√≥n` se guarda en la nueva clave `java-js`:

````bash
127.0.0.1:6379> smembers java-js
1) "2"
2) "3"
3) "4"
````

### ‚úÖ Conclusi√≥n

- Estas operaciones son extremadamente √∫tiles cuando se trabaja con agrupaciones de usuarios, etiquetas, roles,
  permisos, etc.
- Redis realiza estas operaciones en memoria de manera r√°pida y eficiente.
- SINTERSTORE, SUNIONSTORE, SDIFFSTORE permiten persistir los resultados de las operaciones.

## üéØ Redis Sorted Set (ZSet)

### üìå ¬øQu√© es un Sorted Set?

Un `Sorted Set (ZSet)` en Redis es una colecci√≥n de elementos √∫nicos, al igual que un Set tradicional, pero donde cada
elemento est√° asociado a un valor num√©rico llamado `score`.

- Los elementos est√°n ordenados autom√°ticamente por su score de forma ascendente.
- Ideal para `rankings`, `puntuaciones`, `sistemas de recomendaci√≥n`, `popularidad de productos`, etc.

### ‚úÖ Principales comandos utilizados

````bash
127.0.0.1:6379> zadd products 0 books
(integer) 1
127.0.0.1:6379> zadd products 0 iphone 0 tv 0 monitor
(integer) 3
````

- `ZADD`: agrega elementos al Sorted Set junto con su score.
- Aqu√≠ insertamos productos con un score inicial de 0.

### üìà Incrementar puntuaci√≥n con ZINCRBY

````bash
127.0.0.1:6379> zincrby products 1 books
"1"
127.0.0.1:6379> zincrby products 1 iphone
"1"
127.0.0.1:6379> zincrby products 1 iphone
"2"
127.0.0.1:6379> zincrby products 1 iphone
"3"
````

- `ZINCRBY`: incrementa el score de un elemento.
- Aqu√≠ se simula que el producto iphone es m√°s popular y sube su puntuaci√≥n.

### üìä Obtener elementos ordenados

````bash
127.0.0.1:6379> zrange products 0 -1
1) "monitor"
2) "tv"
3) "books"
4) "iphone"
````

- `ZRANGE`: muestra los elementos ordenados por score de menor a mayor.
- Con `withscores`, tambi√©n muestra la puntuaci√≥n asociada.

````bash
127.0.0.1:6379> zrange products 0 -1 withscores
1) "tv"
2) "0"
3) "books"
4) "1"
5) "iphone"
6) "3"
7) "monitor"
8) "3"
````

### üîé Detalles adicionales

`ZCARD`: cuenta la cantidad total de elementos en el ZSet.

````bash
127.0.0.1:6379> zcard products
(integer) 4
````

`ZRANGE -1 -1`: obtiene el √∫ltimo elemento, es decir, el de mayor puntuaci√≥n.

````bash
127.0.0.1:6379> zrange products -1 -1
1) "monitor"
````

### üß† Conceptos clave

- Redis garantiza que los elementos est√©n ordenados autom√°ticamente al insertarlos o modificar sus scores.
- Los scores pueden ser valores negativos, decimales o enteros.
- Dos elementos pueden tener el mismo score; en ese caso se ordenan lexicogr√°ficamente.

### üõ† Casos de uso

- Ranking de usuarios por puntuaci√≥n
- Lista de productos m√°s visitados
- Noticias o posts m√°s populares
- Control de sesiones por actividad reciente

## üîÅ Redis Transactions

Las `transacciones en Redis` permiten `agrupar varios comandos` que se ejecutar√°n secuencialmente como una
`unidad at√≥mica`. Esto es √∫til cuando m√∫ltiples usuarios o procesos pueden modificar las mismas claves, y queremos
evitar inconsistencias o condiciones de carrera (`race conditions`).

### üß† Conceptos clave

- `WATCH`: Observa una o m√°s claves por cambios. Si alguna de ellas cambia antes de ejecutar la transacci√≥n (`EXEC`),
  `Redis` cancelar√° la transacci√≥n.
- `MULTI`: Indica el inicio de una transacci√≥n. A partir de aqu√≠, los comandos se encolan y no se ejecutan
  inmediatamente.
- `EXEC`: Ejecuta todos los comandos encolados dentro de MULTI. Si alguna clave observada con WATCH fue modificada, se
  aborta (retorna `nil`).
- `DISCARD`: Cancela la transacci√≥n y descarta todos los comandos encolados.

> `Importante`: `Redis` no tiene `aislamiento de transacciones` como las bases de datos relacionales (ACID completo),
> pero `garantiza consistencia secuencial`.

### üë§ Simulaci√≥n de Usuario 1

Este usuario observa las claves `user:1:balance` y `user:2:balance`, y luego inicia una transacci√≥n para transferir
saldo.

El resultado `nil` significa que `otro cliente (usuario 2)` modific√≥ alguna de las claves observadas, lo que invalid√≥ la
transacci√≥n.

````bash
127.0.0.1:6379> set user:1:balance 1
OK
127.0.0.1:6379> set user:2:balance 0
OK
127.0.0.1:6379> watch user:1:balance user:2:balance
OK
127.0.0.1:6379> multi
OK
127.0.0.1:6379(TX)> decr user:1:balance
QUEUED
127.0.0.1:6379(TX)> incr user:2:balance
QUEUED
127.0.0.1:6379(TX)> exec
(nil)
127.0.0.1:6379> get user:1:balance
"0"
127.0.0.1:6379> get user:2:balance
"1"
````

### üë§ Simulaci√≥n de Usuario 2

Este usuario tambi√©n observa las mismas claves y realiza la transacci√≥n. Como fue el primero en ejecutar `EXEC`, su
transacci√≥n se completa exitosamente.

````bash
127.0.0.1:6379> watch user:1:balance user:2:balance
OK
127.0.0.1:6379> multi
OK
127.0.0.1:6379(TX)> decr user:1:balance
QUEUED
127.0.0.1:6379(TX)> incr user:2:balance
QUEUED
127.0.0.1:6379(TX)> exec
1) (integer) 0
2) (integer) 1
````

### üîÑ Cancelar una transacci√≥n (Rollback)

Redis no tiene `rollback` autom√°tico como una base de datos relacional, pero puedes descartar manualmente una
transacci√≥n antes de ejecutarla con `DISCARD`.

Este comando cancela la transacci√≥n. Ninguno de los comandos encolados se ejecuta.

````bash
127.0.0.1:6379> multi
OK
127.0.0.1:6379(TX)> decr user:1:balance
QUEUED
127.0.0.1:6379(TX)> incr user:2:balance
QUEUED
127.0.0.1:6379(TX)> discard
OK
127.0.0.1:6379> get user:1:balance
"0"
127.0.0.1:6379> get user:2:balance
"1" 
````

## ‚úÖ Consideraciones importantes

- Redis no admite rollback parcial si un comando falla durante EXEC. Todos se ejecutan tal cual se encolaron.
- Si quieres l√≥gica m√°s compleja con garant√≠as ACID completas, considera usar Lua Scripts (EVAL), que tambi√©n son
  at√≥micos.
- Usa WATCH solo cuando haya riesgo de concurrencia. En contextos simples, basta con MULTI y EXEC.

## üíæ Guardar Datos en el Disco

`Redis es una base de datos en memoria`, lo que significa que por defecto `los datos se almacenan en la RAM`. Sin
embargo, Redis ofrece mecanismos de persistencia para guardar los datos en disco, permitiendo recuperar el estado del
servidor en caso de reinicio.

### üîÅ Persistencia con RDB (Redis Database Backup)

Redis tiene dos principales mecanismos de persistencia:

- `RDB (Redis Database)`: crea snapshots del estado actual de Redis en intervalos definidos o mediante comandos
  manuales (como `BGSAVE`).
- `AOF (Append Only File)`: registra cada operaci√≥n de escritura recibida por el servidor. Es m√°s detallado pero
  tambi√©n m√°s pesado.

En este apartado exploraremos la persistencia usando `RDB`.

### üê≥ Preparaci√≥n: Reinicio del contenedor Redis

Dado que estamos usando Docker, simularemos un reinicio del servidor eliminando el contenedor actual y creando uno
nuevo. Esto nos permite partir de un entorno limpio.

Una vez que el contenedor haya sido recreado, accedemos a Redis y creamos algunas claves simples:

````bash
127.0.0.1:6379> set user:1:balance 1
OK
127.0.0.1:6379> set user:2:balance 0
OK
````

### üìÇ Explorando el contenedor

Abrimos una nueva terminal y accedemos al contenedor Redis para inspeccionar los archivos en el directorio de trabajo
(`/data`). Al principio, no veremos ning√∫n archivo persistente:

````bash
/data # ls -al
total 8
drwxr-xr-x    2 redis    redis         4096 Jul  7 16:55 .
drwxr-xr-x    1 root     root          4096 Jul 14 16:29 ..
````

### üß† Comando BGSAVE: guardado en segundo plano

Redis ofrece el comando `BGSAVE` para guardar en disco el estado actual de la base de datos. Esto genera un archivo
`dump.rdb` que representa una imagen del contenido en ese momento:

````bash
$ 127.0.0.1:6379> bgsave
Background saving started
````

Despu√©s de unos segundos, si volvemos a listar el contenido del directorio `/data`, veremos que ahora existe el archivo
`dump.rdb`:

````bash
/data # ls -al
total 12
drwxr-xr-x    2 redis    redis         4096 Jul 14 16:31 .
drwxr-xr-x    1 root     root          4096 Jul 14 16:29 ..
-rw-------    1 redis    redis          129 Jul 14 16:31 dump.rdb
````

Este archivo contiene el estado persistido de las claves y puede ser cargado autom√°ticamente cuando Redis reinicie,
permitiendo restaurar la informaci√≥n.

### üîç Contenido binario

Aunque podr√≠amos intentar visualizar el contenido con `cat`, el archivo est√° en formato binario y no es legible
directamente:

````bash
/data # cat dump.rdb
REDIS0012ÔøΩ      redis-ver8.0.3ÔøΩ
redis-bitsÔøΩ@ÔøΩctimeÔøΩÔøΩ0uhÔøΩused-memÔøΩÔøΩÔøΩ  aof-baseÔøΩÔøΩÔøΩuser:1:balanceÔøΩuser:2:balanceÔøΩÔøΩÔøΩÔøΩaVÔøΩ8
````

### üß† Conclusi√≥n

Redis nos permite guardar informaci√≥n en disco para asegurar la durabilidad de los datos. El enfoque RDB es √∫til para
backups peri√≥dicos o cuando no se requiere persistencia inmediata de cada operaci√≥n.
