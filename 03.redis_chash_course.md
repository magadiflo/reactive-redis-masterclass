# Secci√≥n 03: Redis - Curso Intensivo

---

## üîπ Introducci√≥n a Redis

`Redis (Remote Dictionary Server)` es una base de datos `NoSQL`, en memoria, de estructura de datos `clave-valor`.
Es ampliamente reconocida por su alto rendimiento, baja latencia y su versatilidad para resolver distintos problemas
de arquitectura de software. Su enfoque en el almacenamiento en memoria hace que sea incre√≠blemente r√°pido en
comparaci√≥n con otras bases de datos que dependen del disco.

### ‚úÖ Caracter√≠sticas principales

- üöÄ `Velocidad extrema`: Redis opera en `memoria RAM`, lo que permite tiempos de respuesta del orden de microsegundos.
- üîÑ `Persistencia opcional`: Aunque es una base de datos en memoria, puede configurarse para guardar datos en disco,
  usando mecanismos como RDB snapshots o AOF (Append-Only File).
- ‚öôÔ∏è `Estructuras de datos avanzadas`: A diferencia de otras bases de datos `clave-valor` simples, `Redis` ofrece
  estructuras como:
    - Strings
    - Lists
    - Sets
    - Hashes
    - Sorted Sets
    - Bitmaps
    - HyperLogLogs
    - Streams
    - Geo data

- üîÅ Soporte para replicaci√≥n, clustering y alta disponibilidad.
- üß© Extensibilidad mediante m√≥dulos adicionales.

### üß† Piensa en Redis como

> Un servidor de estructuras de datos multiprop√≥sito, que vive en memoria y responde con extrema rapidez.
> Es √∫til no solo como base de datos, sino tambi√©n como middleware para acelerar y coordinar aplicaciones distribuidas.

### üìå Casos de uso comunes

Redis puede cumplir distintos roles dentro de una arquitectura moderna:

- üß† `Caching (Almacenamiento en cach√©)`: Ideal para almacenar resultados de consultas a bases de datos tradicionales o
  llamadas a APIs costosas, acelerando las respuestas.
- üì£ `Pub/Sub (Publicaci√≥n/Suscripci√≥n)`: Redis permite comunicaci√≥n en tiempo real entre servicios o usuarios mediante
  canales de mensajes.
- üì¨ `Message Queue (Cola de mensajes)`: Redis puede funcionar como sistema de colas, similar a RabbitMQ o Kafka, usando
  listas o streams.
- üì∫ `Streaming de datos`: Con Redis Streams, se puede manejar flujo de datos continuo (por ejemplo, logs, eventos de
  usuarios, sensores IoT).
- üåç `GeoSpatial`: Redis permite almacenar, indexar y consultar datos geoespaciales (latitud/longitud), muy √∫til para
  mapas o servicios de geolocalizaci√≥n.
- üîê `Rate limiting (limitaci√≥n de solicitudes)`: Muy usado para proteger APIs ante abusos o sobrecarga.
- ‚è±Ô∏è` Expiraci√≥n y TTL (time-to-live)`: Ideal para datos temporales o sensibles.

### üîÑ Redis en la arquitectura de una aplicaci√≥n

Redis no reemplaza a una base de datos relacional o documental como PostgreSQL o MongoDB. En lugar de eso, Redis
complementa estas tecnolog√≠as como un acelerador de rendimiento, o como componente especializado dentro de una
arquitectura m√°s robusta.

üìå Ejemplo de integraci√≥n:

- PostgreSQL para almacenamiento transaccional.
- Redis para cach√© de resultados o para gestionar sesiones de usuario.

![01.png](assets/section-03/01.png)

### üåê Ecosistema Redis

- Redis es gratuito y de c√≥digo abierto (`Open Source`).
- Existen dos portales principales que encontrar√°s al buscar informaci√≥n:
    - üîó `redis.io` ‚Äì Sitio oficial del proyecto `open source`.
    - üîó `redislabs.com` ‚Äì Redis Labs, ahora conocido como `Redis Inc.`, ofrece servicios comerciales y Redis en la
      nube (Redis Enterprise).

## üõ†Ô∏è Configuraci√≥n de Redis mediante Docker

### üîπ Componentes clave de Redis

`Redis` se compone principalmente de dos herramientas fundamentales que trabajan juntas para permitir su uso efectivo:

- üß± `redis-server`: Es el proceso principal del servidor Redis, encargado de gestionar las estructuras de datos,
  el almacenamiento en memoria, recibir comandos, mantener conexiones activas y ejecutar operaciones.
  `Es el servidor Redis propiamente dicho`.


- üñ•Ô∏è `redis-cli`: Es la herramienta de l√≠nea de comandos que permite interactuar con el `servidor Redis`. Nos permite
  conectarnos al servidor y enviarle comandos interactivos. Es esencial para pruebas, inspecci√≥n o manipulaci√≥n directa
  de datos. A trav√©s de `redis-cli`, podr√°s ejecutar comandos como `PING`, `SET`, `GET`, `DEL`, entre muchos otros.

![02.png](assets/section-03/02.png)

Estos dos componentes existen independientemente de c√≥mo decidas instalar Redis, ya sea:

- Directamente en tu sistema operativo (por ejemplo, con apt, brew, o desde el c√≥digo fuente).
- Mediante un contenedor Docker.
- A trav√©s de una distribuci√≥n en la nube.

üìå En resumen, tanto `redis-server` como `redis-cli` son elementos esenciales de `Redis` y se utilizan en todos los
entornos, no solo cuando se usa Docker.

### üì¶ Creaci√≥n del servicio Redis con Docker Compose

Para comenzar a trabajar con `Redis` en un entorno local de forma r√°pida y aislada, es muy com√∫n utilizar `Docker`.
Esto evita instalaciones complejas en el sistema operativo y permite que podamos levantar servicios reproducibles en
diferentes entornos (desarrollo, pruebas, producci√≥n).

> **Atenci√≥n: Usuario de Windows (que no desea usar Docker)**
>
> `Redis` no admite la instalaci√≥n directa en Windows. Existe una soluci√≥n alternativa. El equipo de Redis ha creado un
> v√≠deo oficial con los pasos para la instalaci√≥n de Redis en Windows,
> [disponible en YouTube](https://www.youtube.com/watch?v=1psWME8UH_0).

Para levantar el contenedor de Redis f√°cilmente, se recomienda usar `Docker Compose`, lo cual nos permite definir los
servicios en un archivo `compose.yml`. Este archivo especifica qu√© imagen usar, el nombre del contenedor, las reglas de
red, puertos expuestos, entre otros detalles.

````yml
services:
  s-redis:
    image: redis:8.0.3-alpine
    container_name: c-redis
    restart: unless-stopped
    ports:
      - '6379:6379'
````

### ‚ñ∂Ô∏è Ejecutar el contenedor

Para levantar el servicio, nos posicionamos en el directorio d√≥nde se encuentra el `compose.yml` y ejecutamos el
siguiente comando.

````bash
D:\programming\spring\01.udemy\03.vinoth_selvaraj\reactive-redis-masterclass\docker (feature/section-3)
$ docker compose up -d                                                                                 
[+] Running 8/8                                                                                        
 ‚úî s-redis Pulled                                                                                      
   ‚úî f18232174bc9 Already exists                                                                       
   ‚úî 10753f8102ef Pull complete                                                                        
   ‚úî a9c51c568321 Pull complete                                                                        
   ‚úî b96ac5b0d90b Pull complete                                                                        
   ‚úî 3b985785c0a3 Pull complete                                                                        
   ‚úî 4f4fb700ef54 Pull complete                                                                        
   ‚úî 6b9706545272 Pull complete                                                                        
[+] Running 2/2                                                                                        
 ‚úî Network docker_default  Created                                                                     
 ‚úî Container c-redis       Started                                                                     
````

Puedes listar los contenedores en ejecuci√≥n con el siguiente comando.

````bash
$ docker container ls -a
CONTAINER ID   IMAGE                COMMAND                  CREATED              STATUS              PORTS                                         NAMES
f37a8bd54269   redis:8.0.3-alpine   "docker-entrypoint.s‚Ä¶"   About a minute ago   Up About a minute   0.0.0.0:6379->6379/tcp, [::]:6379->6379/tcp   c-redis
````

### üß™ Probar conexi√≥n al servidor Redis

Para comprobar que el servidor Redis est√° activo y accesible, podemos ingresar al contenedor y ejecutar el cliente de
l√≠nea de comandos (`redis-cli`):

````bash
$ docker container exec -it c-redis /bin/sh
/data # redis-cli
127.0.0.1:6379> ping
PONG
127.0.0.1:6379>
````

El comando `PING` es una forma simple de testear conectividad con el servidor. La respuesta `PONG` indica que el
servidor Redis est√° funcionando correctamente y est√° aceptando comandos.

### ‚úÖ Conclusi√≥n

Gracias al uso de `Docker` y `Docker Compose`, podemos levantar una instancia funcional de `Redis` en segundos, sin
necesidad de instalar nada en el sistema operativo. Esto es especialmente √∫til para pruebas locales, desarrollo o
para integrarlo dentro de arquitecturas de microservicios.

## üîë Almacenamiento de valores clave simples en Redis

### üîπ Fundamentos de clave-valor en Redis

Una de las operaciones m√°s b√°sicas y esenciales en `Redis` es el almacenamiento de datos usando el modelo `clave-valor`
(`key-value`). En este modelo, se asocia un valor a una clave √∫nica, y `Redis` se encarga de guardar esa informaci√≥n
en memoria.

### üß† Conceptos clave:

- `Redis` es, en esencia, un almac√©n de estructuras de datos basado en `clave-valor`.
- Tanto las claves como los valores son, por defecto, cadenas de texto (`strings`). Incluso los valores num√©ricos se
  almacenan internamente como texto.
- `Redis` permite trabajar con claves binarias arbitrarias, lo que significa que puedes usar casi cualquier secuencia
  de bytes como nombre de clave. Aun as√≠, se recomienda usar nombres legibles y cortos para facilitar su mantenimiento
  y comprensi√≥n.
- Redis puede manejar m√°s de 2^32 claves (m√°s de 4 mil millones), aunque la limitaci√≥n real estar√° dada por la memoria
  disponible en el sistema.
- El tama√±o m√°ximo permitido para una clave o valor tipo string es de 512 MB.

### ‚ñ∂Ô∏è Ejemplo pr√°ctico con SET y GET

Antes de ejecutar comandos, debemos asegurarnos de tener acceso al servidor `Redis` desde el contenedor. Comprobamos la
conexi√≥n con un `PING`:

````bash
$ docker container exec -it c-redis /bin/sh
/data # redis-cli
127.0.0.1:6379> ping
PONG
````

La respuesta `PONG` indica que el cliente (`redis-cli`) se est√° comunicando exitosamente con el servidor
(`redis-server`).

### üì¶ Almacenar y recuperar datos

Probamos las operaciones b√°sicas SET y GET en Redis:

````bash
127.0.0.1:6379> set a b
OK
127.0.0.1:6379> get a
"b"
127.0.0.1:6379> get c
(nil)
127.0.0.1:6379> set a 1
OK
127.0.0.1:6379> get a
"1"
127.0.0.1:6379>
````

1. `SET a b`: Se crea la clave a y se le asigna el valor "b". Redis responde con OK, lo que indica √©xito en la
   operaci√≥n.
2. `GET a`: Recupera el valor de la clave a, devolviendo `"b"`.
3. `GET c`: La clave c no existe, por lo tanto, Redis devuelve (nil), lo que indica ausencia de valor.
4. `SET a 1`: Sobrescribe el valor anterior de la clave a con `"1"`.
5. `GET a`: Devuelve `"1"`. Aunque sea un n√∫mero, Redis lo almacena como cadena de texto, salvo que se utilicen
   comandos espec√≠ficos para operar como n√∫meros (`INCR`, `DECR`, etc.).

### üìù Nota t√©cnica: Strings en Redis

Aunque `Redis` almacena los valores como cadenas (`strings`), internamente es muy eficiente al detectar si el contenido
es num√©rico. Esto le permite ejecutar operaciones aritm√©ticas directamente sobre ellos, lo cual veremos m√°s adelante.

Ejemplo de operaci√≥n con n√∫mero:

````bash
127.0.0.1:6379> set a 1
OK
127.0.0.1:6379> incr a
(integer) 2
127.0.0.1:6379> get a
"2"
127.0.0.1:6379>
````

Si `a` contiene una cadena que representa un n√∫mero, `INCR` lo convertir√° en entero, lo incrementar√° y actualizar√° el
valor.

### üß≠ Convenciones para nombrar claves en Redis

A diferencia de bases de datos relacionales como `PostgreSQL` o documentales como `MongoDB`, `Redis` no organiza los
datos en tablas, colecciones ni esquemas estructurados.

- No hay columnas, filas, ni tipos complejos de entidades.
- Redis opera a nivel de claves individuales que apuntan a valores.
- Cada clave es totalmente independiente y no est√° "agrupada" en ninguna estructura formal.

Esto le da gran flexibilidad, pero traslada la responsabilidad de la organizaci√≥n a los desarrolladores, quienes deben
seguir convenciones claras al nombrar claves.

### üß† Convenciones comunes para definir claves

Como `Redis` no impone una jerarqu√≠a o agrupamiento, la comunidad ha adoptado convenciones sem√°nticas para nombrar
claves de forma organizada.

Una muy extendida consiste en `simular rutas o endpoints`, como si fueran URLs, siguiendo una estructura l√≥gica que
represente el recurso. Ejemplos:

| id | name | endpoint                     |
|----|------|------------------------------|
| 1  | sam  | /user/1/name                 |
| 2  | jake | /user/2/name or /user/name/2 |

Sin embargo, por convenci√≥n, la comunidad `Redis` prefiere usar el car√°cter dos puntos `(:)` para estructurar las claves
de forma l√≥gica y visual, como si fueran "rutas" jer√°rquicas. Esto ayuda a mantener orden y claridad al trabajar con
grandes vol√∫menes de claves.

‚ú® El car√°cter `:` no tiene ning√∫n significado especial para Redis, pero se utiliza como una convenci√≥n humana para
mantener un sistema de nombres limpio, predecible y m√°s f√°cil de consultar.

````bash
127.0.0.1:6379> set user:1:name martin
OK
127.0.0.1:6379> set user:2:name milagros
OK
127.0.0.1:6379> get user:1:name
"martin"
127.0.0.1:6379> get user:2:name
"milagros"
127.0.0.1:6379>
````

En este caso:

- Las claves `user:1:name` y `user:2:name` siguen una convenci√≥n de tipo: `recurso:id:atributo`
- Esto hace que sea m√°s f√°cil visualizar, mantener y recuperar datos relacionados con estructuras complejas como
  usuarios, productos, sesiones, etc.

‚úÖ Conclusi√≥n
> El modelo `clave-valor` de `Redis` es simple pero extremadamente poderoso. Las operaciones `SET` y `GET` permiten
> guardar y recuperar datos r√°pidamente, y su comportamiento predecible lo convierte en una herramienta ideal para
> casos de uso como almacenamiento en cach√©, configuraci√≥n, sesiones, contadores y mucho m√°s.

## üîç Accediendo a todas las claves en Redis

En Redis, las claves no est√°n agrupadas por tabla o colecci√≥n, por lo que si queremos inspeccionar las que ya existen,
podemos usar comandos especiales para listarlas. Esto es √∫til para `debugging`, `exploraci√≥n` o `scripting`.

````bash
127.0.0.1:6379> keys *
1) "a"
2) "1"
3) "user:1:name"
4) "user:2:name"
5) "user/name/1"

127.0.0.1:6379> keys user*
1) "user:1:name"
2) "user:2:name"
3) "user/name/1"
````

- `KEYS *` devuelve todas las claves del servidor Redis.
- Tambi√©n puedes usar patrones con comodines:
    - `user*` ‚Äì Claves que empiezan con `user`
    - `*name` ‚Äì Claves que terminan en `name`
    - `*:*:name` ‚Äì Claves con dos `:` y terminadas en `name`

‚ö†Ô∏è Advertencia importante:
> El comando `KEYS` recorre todas las claves en memoria, por lo que es muy costoso en rendimiento si tienes muchas
> claves (por ejemplo, millones). `Nunca debe usarse en producci√≥n`.

### üîÑ Alternativa segura: comando SCAN

`Redis` ofrece el comando `SCAN` como una alternativa no bloqueante al comando `KEYS`. En lugar de devolver todas
las claves de una sola vez, lo hace de forma iterativa y paginada.

Para ver en funcionamiento el comando `SCAN` vamos a agregar muchas claves. Estas claves adicionales nos permiten
simular una base de datos con m√∫ltiples elementos para probar el comportamiento de SCAN.

````bash
127.0.0.1:6379> set user:3:name 3
OK
127.0.0.1:6379> set user:4:name 4
OK
127.0.0.1:6379> set user:5:name 5
OK
127.0.0.1:6379> set user:6:name 6
OK
127.0.0.1:6379> set user:7:name 7
OK
127.0.0.1:6379> set user:8:name 8
OK
127.0.0.1:6379> set user:9:name 9
OK
127.0.0.1:6379> set user:10:name 10
OK
127.0.0.1:6379> set user:11:name 11
OK
127.0.0.1:6379> set user:12:name 12
OK
127.0.0.1:6379> set user:13:name 13
OK
127.0.0.1:6379> set user:14:name 14
````

A continuaci√≥n, veremos en ejecuci√≥n el comando `SCAN`.

````bash
127.0.0.1:6379> scan 0
1) "25"
2)  1) "user:9:name"
    2) "user:11:name"
    3) "user:7:name"
    4) "user:13:name"
    5) "user:10:name"
    6) "a"
    7) "user:4:name"
    8) "user:3:name"
    9) "1"
   10) "user:1:name"
127.0.0.1:6379> scan 25
1) "0"
2) 1) "user:2:name"
   2) "user:8:name"
   3) "user:14:name"
   4) "user/name/1"
   5) "user:12:name"
   6) "user:6:name"
   7) "user:5:name"
127.0.0.1:6379>
````

- `scan 0:` comienza desde el `cursor 0`, que representa el `inicio del escaneo`.
- El primer valor de la respuesta `("25")` es el nuevo cursor que se debe usar para la siguiente iteraci√≥n.
- La segunda parte contiene una lista parcial de claves.
- Cuando el cursor devuelto sea `0`, significa que el escaneo ha finalizado.

üìå Esto lo hace ideal para aplicaciones que necesitan explorar claves sin bloquear el servidor `Redis`.

### üéØ SCAN con filtros y l√≠mite de resultados

Aqu√≠ le decimos que nos retorne el listado de claves que hagan match con `user*` pero que solo nos muestre 2 resultados.

````bash
127.0.0.1:6379> scan 0 match user* count 2
1) "16"
2) 1) "user:9:name"
   2) "user:11:name"
````

Par√°metros √∫tiles:

- `MATCH <pattern>`: Filtra claves seg√∫n un patr√≥n, similar a KEYS.
- `COUNT <n>`: Indica cu√°ntas claves `aproximadamente` se desea obtener por iteraci√≥n. `No garantiza exactitud`.

> ‚ÑπÔ∏è `SCAN` est√° dise√±ado para exploraci√≥n segura en entornos productivos. Se recomienda usarlo junto con ciclos de
> c√≥digo (loops) para recorrer todos los resultados.

## üóëÔ∏è Eliminando claves en Redis

`Redis` nos permite `eliminar una o m√°s claves` de la `base de datos en memoria` usando el comando `DEL`. Es una
operaci√≥n sencilla pero muy √∫til, especialmente durante desarrollo, limpieza de datos temporales o invalidaci√≥n de
cach√©s.

A continuaci√≥n eliminamos m√∫ltiples claves: `a`, `1` y `user/name/1`:

- `Redis` devuelve el n√∫mero total de claves eliminadas con √©xito.
- Si una de las claves no existiera, el contador disminuir√≠a seg√∫n corresponda.

````bash
127.0.0.1:6379> del a 1 user/name/1
(integer) 3 
````

Si eliminamos una clave que no existe, simplemente nos indica que se han eliminado 0 claves. Esto es completamente
normal y no genera error. Redis ignora silenciosamente claves inexistentes.

````bash
127.0.0.1:6379> del user:100:name
(integer) 0 
````

### üßπ Eliminando todas las claves de Redis

Redis permite eliminar todas las claves de la base de datos actual utilizando el comando `flushdb`. Este comando
reinicia por completo la base de datos seleccionada (por defecto, la n√∫mero 0), eliminando todos los datos almacenados.

````bash
127.0.0.1:6379> flushdb
OK
127.0.0.1:6379> keys *
(empty array)
127.0.0.1:6379> 
````
